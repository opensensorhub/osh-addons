// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/config.proto

// Protobuf Java Version: 3.25.1
package com.geeksville.mesh;

public final class ConfigProtos {
  private ConfigProtos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:meshtastic.Config)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
     * @return Whether the device field is set.
     */
    boolean hasDevice();
    /**
     * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
     * @return The device.
     */
    com.geeksville.mesh.ConfigProtos.Config.DeviceConfig getDevice();
    /**
     * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.DeviceConfigOrBuilder getDeviceOrBuilder();

    /**
     * <code>.meshtastic.Config.PositionConfig position = 2;</code>
     * @return Whether the position field is set.
     */
    boolean hasPosition();
    /**
     * <code>.meshtastic.Config.PositionConfig position = 2;</code>
     * @return The position.
     */
    com.geeksville.mesh.ConfigProtos.Config.PositionConfig getPosition();
    /**
     * <code>.meshtastic.Config.PositionConfig position = 2;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.PositionConfigOrBuilder getPositionOrBuilder();

    /**
     * <code>.meshtastic.Config.PowerConfig power = 3;</code>
     * @return Whether the power field is set.
     */
    boolean hasPower();
    /**
     * <code>.meshtastic.Config.PowerConfig power = 3;</code>
     * @return The power.
     */
    com.geeksville.mesh.ConfigProtos.Config.PowerConfig getPower();
    /**
     * <code>.meshtastic.Config.PowerConfig power = 3;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.PowerConfigOrBuilder getPowerOrBuilder();

    /**
     * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
     * @return Whether the network field is set.
     */
    boolean hasNetwork();
    /**
     * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
     * @return The network.
     */
    com.geeksville.mesh.ConfigProtos.Config.NetworkConfig getNetwork();
    /**
     * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.NetworkConfigOrBuilder getNetworkOrBuilder();

    /**
     * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
     * @return Whether the display field is set.
     */
    boolean hasDisplay();
    /**
     * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
     * @return The display.
     */
    com.geeksville.mesh.ConfigProtos.Config.DisplayConfig getDisplay();
    /**
     * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.DisplayConfigOrBuilder getDisplayOrBuilder();

    /**
     * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
     * @return Whether the lora field is set.
     */
    boolean hasLora();
    /**
     * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
     * @return The lora.
     */
    com.geeksville.mesh.ConfigProtos.Config.LoRaConfig getLora();
    /**
     * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.LoRaConfigOrBuilder getLoraOrBuilder();

    /**
     * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
     * @return Whether the bluetooth field is set.
     */
    boolean hasBluetooth();
    /**
     * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
     * @return The bluetooth.
     */
    com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig getBluetooth();
    /**
     * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.BluetoothConfigOrBuilder getBluetoothOrBuilder();

    /**
     * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
     * @return Whether the security field is set.
     */
    boolean hasSecurity();
    /**
     * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
     * @return The security.
     */
    com.geeksville.mesh.ConfigProtos.Config.SecurityConfig getSecurity();
    /**
     * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.SecurityConfigOrBuilder getSecurityOrBuilder();

    /**
     * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
     * @return Whether the sessionkey field is set.
     */
    boolean hasSessionkey();
    /**
     * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
     * @return The sessionkey.
     */
    com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig getSessionkey();
    /**
     * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
     */
    com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfigOrBuilder getSessionkeyOrBuilder();

    /**
     * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
     * @return Whether the deviceUi field is set.
     */
    boolean hasDeviceUi();
    /**
     * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
     * @return The deviceUi.
     */
    com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig getDeviceUi();
    /**
     * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
     */
    com.geeksville.mesh.DeviceUIProtos.DeviceUIConfigOrBuilder getDeviceUiOrBuilder();

    com.geeksville.mesh.ConfigProtos.Config.PayloadVariantCase getPayloadVariantCase();
  }
  /**
   * Protobuf type {@code meshtastic.Config}
   */
  public static final class Config extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:meshtastic.Config)
      ConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Config.newBuilder() to construct.
    private Config(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Config() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Config();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.geeksville.mesh.ConfigProtos.Config.class, com.geeksville.mesh.ConfigProtos.Config.Builder.class);
    }

    public interface DeviceConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.DeviceConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       *
       * Sets the role of node
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
       * @return The enum numeric value on the wire for role.
       */
      int getRoleValue();
      /**
       * <pre>
       *
       * Sets the role of node
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
       * @return The role.
       */
      com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role getRole();

      /**
       * <pre>
       *
       * Disabling this will disable the SerialConsole by not initilizing the StreamAPI
       * Moved to SecurityConfig
       * </pre>
       *
       * <code>bool serial_enabled = 2 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DeviceConfig.serial_enabled is deprecated.
       *     See meshtastic/config.proto;l=207
       * @return The serialEnabled.
       */
      @java.lang.Deprecated boolean getSerialEnabled();

      /**
       * <pre>
       *
       * For boards without a hard wired button, this is the pin number that will be used
       * Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
       * </pre>
       *
       * <code>uint32 button_gpio = 4;</code>
       * @return The buttonGpio.
       */
      int getButtonGpio();

      /**
       * <pre>
       *
       * For boards without a PWM buzzer, this is the pin number that will be used
       * Defaults to PIN_BUZZER if defined.
       * </pre>
       *
       * <code>uint32 buzzer_gpio = 5;</code>
       * @return The buzzerGpio.
       */
      int getBuzzerGpio();

      /**
       * <pre>
       *
       * Sets the role of node
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
       * @return The enum numeric value on the wire for rebroadcastMode.
       */
      int getRebroadcastModeValue();
      /**
       * <pre>
       *
       * Sets the role of node
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
       * @return The rebroadcastMode.
       */
      com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode getRebroadcastMode();

      /**
       * <pre>
       *
       * Send our nodeinfo this often
       * Defaults to 900 Seconds (15 minutes)
       * </pre>
       *
       * <code>uint32 node_info_broadcast_secs = 7;</code>
       * @return The nodeInfoBroadcastSecs.
       */
      int getNodeInfoBroadcastSecs();

      /**
       * <pre>
       *
       * Treat double tap interrupt on supported accelerometers as a button press if set to true
       * </pre>
       *
       * <code>bool double_tap_as_button_press = 8;</code>
       * @return The doubleTapAsButtonPress.
       */
      boolean getDoubleTapAsButtonPress();

      /**
       * <pre>
       *
       * If true, device is considered to be "managed" by a mesh administrator
       * Clients should then limit available configuration and administrative options inside the user interface
       * Moved to SecurityConfig
       * </pre>
       *
       * <code>bool is_managed = 9 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DeviceConfig.is_managed is deprecated.
       *     See meshtastic/config.proto;l=242
       * @return The isManaged.
       */
      @java.lang.Deprecated boolean getIsManaged();

      /**
       * <pre>
       *
       * Disables the triple-press of user button to enable or disable GPS
       * </pre>
       *
       * <code>bool disable_triple_click = 10;</code>
       * @return The disableTripleClick.
       */
      boolean getDisableTripleClick();

      /**
       * <pre>
       *
       * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
       * </pre>
       *
       * <code>string tzdef = 11;</code>
       * @return The tzdef.
       */
      java.lang.String getTzdef();
      /**
       * <pre>
       *
       * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
       * </pre>
       *
       * <code>string tzdef = 11;</code>
       * @return The bytes for tzdef.
       */
      com.google.protobuf.ByteString
          getTzdefBytes();

      /**
       * <pre>
       *
       * If true, disable the default blinking LED (LED_PIN) behavior on the device
       * </pre>
       *
       * <code>bool led_heartbeat_disabled = 12;</code>
       * @return The ledHeartbeatDisabled.
       */
      boolean getLedHeartbeatDisabled();

      /**
       * <pre>
       *
       * Controls buzzer behavior for audio feedback
       * Defaults to ENABLED
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
       * @return The enum numeric value on the wire for buzzerMode.
       */
      int getBuzzerModeValue();
      /**
       * <pre>
       *
       * Controls buzzer behavior for audio feedback
       * Defaults to ENABLED
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
       * @return The buzzerMode.
       */
      com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode getBuzzerMode();
    }
    /**
     * <pre>
     *
     * Configuration
     * </pre>
     *
     * Protobuf type {@code meshtastic.Config.DeviceConfig}
     */
    public static final class DeviceConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.DeviceConfig)
        DeviceConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use DeviceConfig.newBuilder() to construct.
      private DeviceConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private DeviceConfig() {
        role_ = 0;
        rebroadcastMode_ = 0;
        tzdef_ = "";
        buzzerMode_ = 0;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new DeviceConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DeviceConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DeviceConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.class, com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Builder.class);
      }

      /**
       * <pre>
       *
       * Defines the device's role on the Mesh network
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.DeviceConfig.Role}
       */
      public enum Role
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Description: App connected or stand alone messaging device.
         * Technical Details: Default Role
         * </pre>
         *
         * <code>CLIENT = 0;</code>
         */
        CLIENT(0),
        /**
         * <pre>
         *
         *  Description: Device that does not forward packets from other devices.
         * </pre>
         *
         * <code>CLIENT_MUTE = 1;</code>
         */
        CLIENT_MUTE(1),
        /**
         * <pre>
         *
         * Description: Infrastructure node for extending network coverage by relaying messages. Visible in Nodes list.
         * Technical Details: Mesh packets will prefer to be routed over this node. This node will not be used by client apps.
         *   The wifi radio and the oled screen will be put to sleep.
         *   This mode may still potentially have higher power usage due to it's preference in message rebroadcasting on the mesh.
         * </pre>
         *
         * <code>ROUTER = 2;</code>
         */
        ROUTER(2),
        /**
         * <code>ROUTER_CLIENT = 3 [deprecated = true];</code>
         */
        @java.lang.Deprecated
        ROUTER_CLIENT(3),
        /**
         * <pre>
         *
         * Description: Infrastructure node for extending network coverage by relaying messages with minimal overhead. Not visible in Nodes list.
         * Technical Details: Mesh packets will simply be rebroadcasted over this node. Nodes configured with this role will not originate NodeInfo, Position, Telemetry
         *   or any other packet type. They will simply rebroadcast any mesh packets on the same frequency, channel num, spread factor, and coding rate.
         * Deprecated in v2.7.11 because it creates "holes" in the mesh rebroadcast chain.
         * </pre>
         *
         * <code>REPEATER = 4 [deprecated = true];</code>
         */
        @java.lang.Deprecated
        REPEATER(4),
        /**
         * <pre>
         *
         * Description: Broadcasts GPS position packets as priority.
         * Technical Details: Position Mesh packets will be prioritized higher and sent more frequently by default.
         *   When used in conjunction with power.is_power_saving = true, nodes will wake up,
         *   send position, and then sleep for position.position_broadcast_secs seconds.
         * </pre>
         *
         * <code>TRACKER = 5;</code>
         */
        TRACKER(5),
        /**
         * <pre>
         *
         * Description: Broadcasts telemetry packets as priority.
         * Technical Details: Telemetry Mesh packets will be prioritized higher and sent more frequently by default.
         *   When used in conjunction with power.is_power_saving = true, nodes will wake up,
         *   send environment telemetry, and then sleep for telemetry.environment_update_interval seconds.
         * </pre>
         *
         * <code>SENSOR = 6;</code>
         */
        SENSOR(6),
        /**
         * <pre>
         *
         * Description: Optimized for ATAK system communication and reduces routine broadcasts.
         * Technical Details: Used for nodes dedicated for connection to an ATAK EUD.
         *    Turns off many of the routine broadcasts to favor CoT packet stream
         *    from the Meshtastic ATAK plugin -&gt; IMeshService -&gt; Node
         * </pre>
         *
         * <code>TAK = 7;</code>
         */
        TAK(7),
        /**
         * <pre>
         *
         * Description: Device that only broadcasts as needed for stealth or power savings.
         * Technical Details: Used for nodes that "only speak when spoken to"
         *    Turns all of the routine broadcasts but allows for ad-hoc communication
         *    Still rebroadcasts, but with local only rebroadcast mode (known meshes only)
         *    Can be used for clandestine operation or to dramatically reduce airtime / power consumption
         * </pre>
         *
         * <code>CLIENT_HIDDEN = 8;</code>
         */
        CLIENT_HIDDEN(8),
        /**
         * <pre>
         *
         * Description: Broadcasts location as message to default channel regularly for to assist with device recovery.
         * Technical Details: Used to automatically send a text message to the mesh
         *    with the current position of the device on a frequent interval:
         *    "I'm lost! Position: lat / long"
         * </pre>
         *
         * <code>LOST_AND_FOUND = 9;</code>
         */
        LOST_AND_FOUND(9),
        /**
         * <pre>
         *
         * Description: Enables automatic TAK PLI broadcasts and reduces routine broadcasts.
         * Technical Details: Turns off many of the routine broadcasts to favor ATAK CoT packet stream
         *    and automatic TAK PLI (position location information) broadcasts.
         *    Uses position module configuration to determine TAK PLI broadcast interval.
         * </pre>
         *
         * <code>TAK_TRACKER = 10;</code>
         */
        TAK_TRACKER(10),
        /**
         * <pre>
         *
         * Description: Will always rebroadcast packets, but will do so after all other modes.
         * Technical Details: Used for router nodes that are intended to provide additional coverage
         *    in areas not already covered by other routers, or to bridge around problematic terrain,
         *    but should not be given priority over other routers in order to avoid unnecessaraily
         *    consuming hops.
         * </pre>
         *
         * <code>ROUTER_LATE = 11;</code>
         */
        ROUTER_LATE(11),
        /**
         * <pre>
         *
         * Description: Treats packets from or to favorited nodes as ROUTER, and all other packets as CLIENT.
         * Technical Details: Used for stronger attic/roof nodes to distribute messages more widely
         *    from weaker, indoor, or less-well-positioned nodes. Recommended for users with multiple nodes
         *    where one CLIENT_BASE acts as a more powerful base station, such as an attic/roof node.
         * </pre>
         *
         * <code>CLIENT_BASE = 12;</code>
         */
        CLIENT_BASE(12),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Description: App connected or stand alone messaging device.
         * Technical Details: Default Role
         * </pre>
         *
         * <code>CLIENT = 0;</code>
         */
        public static final int CLIENT_VALUE = 0;
        /**
         * <pre>
         *
         *  Description: Device that does not forward packets from other devices.
         * </pre>
         *
         * <code>CLIENT_MUTE = 1;</code>
         */
        public static final int CLIENT_MUTE_VALUE = 1;
        /**
         * <pre>
         *
         * Description: Infrastructure node for extending network coverage by relaying messages. Visible in Nodes list.
         * Technical Details: Mesh packets will prefer to be routed over this node. This node will not be used by client apps.
         *   The wifi radio and the oled screen will be put to sleep.
         *   This mode may still potentially have higher power usage due to it's preference in message rebroadcasting on the mesh.
         * </pre>
         *
         * <code>ROUTER = 2;</code>
         */
        public static final int ROUTER_VALUE = 2;
        /**
         * <code>ROUTER_CLIENT = 3 [deprecated = true];</code>
         */
        @java.lang.Deprecated public static final int ROUTER_CLIENT_VALUE = 3;
        /**
         * <pre>
         *
         * Description: Infrastructure node for extending network coverage by relaying messages with minimal overhead. Not visible in Nodes list.
         * Technical Details: Mesh packets will simply be rebroadcasted over this node. Nodes configured with this role will not originate NodeInfo, Position, Telemetry
         *   or any other packet type. They will simply rebroadcast any mesh packets on the same frequency, channel num, spread factor, and coding rate.
         * Deprecated in v2.7.11 because it creates "holes" in the mesh rebroadcast chain.
         * </pre>
         *
         * <code>REPEATER = 4 [deprecated = true];</code>
         */
        @java.lang.Deprecated public static final int REPEATER_VALUE = 4;
        /**
         * <pre>
         *
         * Description: Broadcasts GPS position packets as priority.
         * Technical Details: Position Mesh packets will be prioritized higher and sent more frequently by default.
         *   When used in conjunction with power.is_power_saving = true, nodes will wake up,
         *   send position, and then sleep for position.position_broadcast_secs seconds.
         * </pre>
         *
         * <code>TRACKER = 5;</code>
         */
        public static final int TRACKER_VALUE = 5;
        /**
         * <pre>
         *
         * Description: Broadcasts telemetry packets as priority.
         * Technical Details: Telemetry Mesh packets will be prioritized higher and sent more frequently by default.
         *   When used in conjunction with power.is_power_saving = true, nodes will wake up,
         *   send environment telemetry, and then sleep for telemetry.environment_update_interval seconds.
         * </pre>
         *
         * <code>SENSOR = 6;</code>
         */
        public static final int SENSOR_VALUE = 6;
        /**
         * <pre>
         *
         * Description: Optimized for ATAK system communication and reduces routine broadcasts.
         * Technical Details: Used for nodes dedicated for connection to an ATAK EUD.
         *    Turns off many of the routine broadcasts to favor CoT packet stream
         *    from the Meshtastic ATAK plugin -&gt; IMeshService -&gt; Node
         * </pre>
         *
         * <code>TAK = 7;</code>
         */
        public static final int TAK_VALUE = 7;
        /**
         * <pre>
         *
         * Description: Device that only broadcasts as needed for stealth or power savings.
         * Technical Details: Used for nodes that "only speak when spoken to"
         *    Turns all of the routine broadcasts but allows for ad-hoc communication
         *    Still rebroadcasts, but with local only rebroadcast mode (known meshes only)
         *    Can be used for clandestine operation or to dramatically reduce airtime / power consumption
         * </pre>
         *
         * <code>CLIENT_HIDDEN = 8;</code>
         */
        public static final int CLIENT_HIDDEN_VALUE = 8;
        /**
         * <pre>
         *
         * Description: Broadcasts location as message to default channel regularly for to assist with device recovery.
         * Technical Details: Used to automatically send a text message to the mesh
         *    with the current position of the device on a frequent interval:
         *    "I'm lost! Position: lat / long"
         * </pre>
         *
         * <code>LOST_AND_FOUND = 9;</code>
         */
        public static final int LOST_AND_FOUND_VALUE = 9;
        /**
         * <pre>
         *
         * Description: Enables automatic TAK PLI broadcasts and reduces routine broadcasts.
         * Technical Details: Turns off many of the routine broadcasts to favor ATAK CoT packet stream
         *    and automatic TAK PLI (position location information) broadcasts.
         *    Uses position module configuration to determine TAK PLI broadcast interval.
         * </pre>
         *
         * <code>TAK_TRACKER = 10;</code>
         */
        public static final int TAK_TRACKER_VALUE = 10;
        /**
         * <pre>
         *
         * Description: Will always rebroadcast packets, but will do so after all other modes.
         * Technical Details: Used for router nodes that are intended to provide additional coverage
         *    in areas not already covered by other routers, or to bridge around problematic terrain,
         *    but should not be given priority over other routers in order to avoid unnecessaraily
         *    consuming hops.
         * </pre>
         *
         * <code>ROUTER_LATE = 11;</code>
         */
        public static final int ROUTER_LATE_VALUE = 11;
        /**
         * <pre>
         *
         * Description: Treats packets from or to favorited nodes as ROUTER, and all other packets as CLIENT.
         * Technical Details: Used for stronger attic/roof nodes to distribute messages more widely
         *    from weaker, indoor, or less-well-positioned nodes. Recommended for users with multiple nodes
         *    where one CLIENT_BASE acts as a more powerful base station, such as an attic/roof node.
         * </pre>
         *
         * <code>CLIENT_BASE = 12;</code>
         */
        public static final int CLIENT_BASE_VALUE = 12;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Role valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static Role forNumber(int value) {
          switch (value) {
            case 0: return CLIENT;
            case 1: return CLIENT_MUTE;
            case 2: return ROUTER;
            case 3: return ROUTER_CLIENT;
            case 4: return REPEATER;
            case 5: return TRACKER;
            case 6: return SENSOR;
            case 7: return TAK;
            case 8: return CLIENT_HIDDEN;
            case 9: return LOST_AND_FOUND;
            case 10: return TAK_TRACKER;
            case 11: return ROUTER_LATE;
            case 12: return CLIENT_BASE;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Role>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Role> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Role>() {
                public Role findValueByNumber(int number) {
                  return Role.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDescriptor().getEnumTypes().get(0);
        }

        private static final Role[] VALUES = values();

        public static Role valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Role(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.DeviceConfig.Role)
      }

      /**
       * <pre>
       *
       * Defines the device's behavior for how messages are rebroadcast
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.DeviceConfig.RebroadcastMode}
       */
      public enum RebroadcastMode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Default behavior.
         * Rebroadcast any observed message, if it was on our private channel or from another mesh with the same lora params.
         * </pre>
         *
         * <code>ALL = 0;</code>
         */
        ALL(0),
        /**
         * <pre>
         *
         * Same as behavior as ALL but skips packet decoding and simply rebroadcasts them.
         * Only available in Repeater role. Setting this on any other roles will result in ALL behavior.
         * </pre>
         *
         * <code>ALL_SKIP_DECODING = 1;</code>
         */
        ALL_SKIP_DECODING(1),
        /**
         * <pre>
         *
         * Ignores observed messages from foreign meshes that are open or those which it cannot decrypt.
         * Only rebroadcasts message on the nodes local primary / secondary channels.
         * </pre>
         *
         * <code>LOCAL_ONLY = 2;</code>
         */
        LOCAL_ONLY(2),
        /**
         * <pre>
         *
         * Ignores observed messages from foreign meshes like LOCAL_ONLY,
         * but takes it step further by also ignoring messages from nodenums not in the node's known list (NodeDB)
         * </pre>
         *
         * <code>KNOWN_ONLY = 3;</code>
         */
        KNOWN_ONLY(3),
        /**
         * <pre>
         *
         * Only permitted for SENSOR, TRACKER and TAK_TRACKER roles, this will inhibit all rebroadcasts, not unlike CLIENT_MUTE role.
         * </pre>
         *
         * <code>NONE = 4;</code>
         */
        NONE(4),
        /**
         * <pre>
         *
         * Ignores packets from non-standard portnums such as: TAK, RangeTest, PaxCounter, etc.
         * Only rebroadcasts packets with standard portnums: NodeInfo, Text, Position, Telemetry, and Routing.
         * </pre>
         *
         * <code>CORE_PORTNUMS_ONLY = 5;</code>
         */
        CORE_PORTNUMS_ONLY(5),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Default behavior.
         * Rebroadcast any observed message, if it was on our private channel or from another mesh with the same lora params.
         * </pre>
         *
         * <code>ALL = 0;</code>
         */
        public static final int ALL_VALUE = 0;
        /**
         * <pre>
         *
         * Same as behavior as ALL but skips packet decoding and simply rebroadcasts them.
         * Only available in Repeater role. Setting this on any other roles will result in ALL behavior.
         * </pre>
         *
         * <code>ALL_SKIP_DECODING = 1;</code>
         */
        public static final int ALL_SKIP_DECODING_VALUE = 1;
        /**
         * <pre>
         *
         * Ignores observed messages from foreign meshes that are open or those which it cannot decrypt.
         * Only rebroadcasts message on the nodes local primary / secondary channels.
         * </pre>
         *
         * <code>LOCAL_ONLY = 2;</code>
         */
        public static final int LOCAL_ONLY_VALUE = 2;
        /**
         * <pre>
         *
         * Ignores observed messages from foreign meshes like LOCAL_ONLY,
         * but takes it step further by also ignoring messages from nodenums not in the node's known list (NodeDB)
         * </pre>
         *
         * <code>KNOWN_ONLY = 3;</code>
         */
        public static final int KNOWN_ONLY_VALUE = 3;
        /**
         * <pre>
         *
         * Only permitted for SENSOR, TRACKER and TAK_TRACKER roles, this will inhibit all rebroadcasts, not unlike CLIENT_MUTE role.
         * </pre>
         *
         * <code>NONE = 4;</code>
         */
        public static final int NONE_VALUE = 4;
        /**
         * <pre>
         *
         * Ignores packets from non-standard portnums such as: TAK, RangeTest, PaxCounter, etc.
         * Only rebroadcasts packets with standard portnums: NodeInfo, Text, Position, Telemetry, and Routing.
         * </pre>
         *
         * <code>CORE_PORTNUMS_ONLY = 5;</code>
         */
        public static final int CORE_PORTNUMS_ONLY_VALUE = 5;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static RebroadcastMode valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static RebroadcastMode forNumber(int value) {
          switch (value) {
            case 0: return ALL;
            case 1: return ALL_SKIP_DECODING;
            case 2: return LOCAL_ONLY;
            case 3: return KNOWN_ONLY;
            case 4: return NONE;
            case 5: return CORE_PORTNUMS_ONLY;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<RebroadcastMode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            RebroadcastMode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<RebroadcastMode>() {
                public RebroadcastMode findValueByNumber(int number) {
                  return RebroadcastMode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDescriptor().getEnumTypes().get(1);
        }

        private static final RebroadcastMode[] VALUES = values();

        public static RebroadcastMode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private RebroadcastMode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.DeviceConfig.RebroadcastMode)
      }

      /**
       * <pre>
       *
       * Defines buzzer behavior for audio feedback
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.DeviceConfig.BuzzerMode}
       */
      public enum BuzzerMode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Default behavior.
         * Buzzer is enabled for all audio feedback including button presses and alerts.
         * </pre>
         *
         * <code>ALL_ENABLED = 0;</code>
         */
        ALL_ENABLED(0),
        /**
         * <pre>
         *
         * Disabled.
         * All buzzer audio feedback is disabled.
         * </pre>
         *
         * <code>DISABLED = 1;</code>
         */
        DISABLED(1),
        /**
         * <pre>
         *
         * Notifications Only.
         * Buzzer is enabled only for notifications and alerts, but not for button presses.
         * External notification config determines the specifics of the notification behavior.
         * </pre>
         *
         * <code>NOTIFICATIONS_ONLY = 2;</code>
         */
        NOTIFICATIONS_ONLY(2),
        /**
         * <pre>
         *
         * Non-notification system buzzer tones only.
         * Buzzer is enabled only for non-notification tones such as button presses, startup, shutdown, but not for alerts.
         * </pre>
         *
         * <code>SYSTEM_ONLY = 3;</code>
         */
        SYSTEM_ONLY(3),
        /**
         * <pre>
         *
         * Direct Message notifications only.
         * Buzzer is enabled only for direct messages and alerts, but not for button presses.
         * External notification config determines the specifics of the notification behavior.
         * </pre>
         *
         * <code>DIRECT_MSG_ONLY = 4;</code>
         */
        DIRECT_MSG_ONLY(4),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Default behavior.
         * Buzzer is enabled for all audio feedback including button presses and alerts.
         * </pre>
         *
         * <code>ALL_ENABLED = 0;</code>
         */
        public static final int ALL_ENABLED_VALUE = 0;
        /**
         * <pre>
         *
         * Disabled.
         * All buzzer audio feedback is disabled.
         * </pre>
         *
         * <code>DISABLED = 1;</code>
         */
        public static final int DISABLED_VALUE = 1;
        /**
         * <pre>
         *
         * Notifications Only.
         * Buzzer is enabled only for notifications and alerts, but not for button presses.
         * External notification config determines the specifics of the notification behavior.
         * </pre>
         *
         * <code>NOTIFICATIONS_ONLY = 2;</code>
         */
        public static final int NOTIFICATIONS_ONLY_VALUE = 2;
        /**
         * <pre>
         *
         * Non-notification system buzzer tones only.
         * Buzzer is enabled only for non-notification tones such as button presses, startup, shutdown, but not for alerts.
         * </pre>
         *
         * <code>SYSTEM_ONLY = 3;</code>
         */
        public static final int SYSTEM_ONLY_VALUE = 3;
        /**
         * <pre>
         *
         * Direct Message notifications only.
         * Buzzer is enabled only for direct messages and alerts, but not for button presses.
         * External notification config determines the specifics of the notification behavior.
         * </pre>
         *
         * <code>DIRECT_MSG_ONLY = 4;</code>
         */
        public static final int DIRECT_MSG_ONLY_VALUE = 4;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static BuzzerMode valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static BuzzerMode forNumber(int value) {
          switch (value) {
            case 0: return ALL_ENABLED;
            case 1: return DISABLED;
            case 2: return NOTIFICATIONS_ONLY;
            case 3: return SYSTEM_ONLY;
            case 4: return DIRECT_MSG_ONLY;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<BuzzerMode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            BuzzerMode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<BuzzerMode>() {
                public BuzzerMode findValueByNumber(int number) {
                  return BuzzerMode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDescriptor().getEnumTypes().get(2);
        }

        private static final BuzzerMode[] VALUES = values();

        public static BuzzerMode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private BuzzerMode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.DeviceConfig.BuzzerMode)
      }

      public static final int ROLE_FIELD_NUMBER = 1;
      private int role_ = 0;
      /**
       * <pre>
       *
       * Sets the role of node
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
       * @return The enum numeric value on the wire for role.
       */
      @java.lang.Override public int getRoleValue() {
        return role_;
      }
      /**
       * <pre>
       *
       * Sets the role of node
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
       * @return The role.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role getRole() {
        com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role result = com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role.forNumber(role_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role.UNRECOGNIZED : result;
      }

      public static final int SERIAL_ENABLED_FIELD_NUMBER = 2;
      private boolean serialEnabled_ = false;
      /**
       * <pre>
       *
       * Disabling this will disable the SerialConsole by not initilizing the StreamAPI
       * Moved to SecurityConfig
       * </pre>
       *
       * <code>bool serial_enabled = 2 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DeviceConfig.serial_enabled is deprecated.
       *     See meshtastic/config.proto;l=207
       * @return The serialEnabled.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getSerialEnabled() {
        return serialEnabled_;
      }

      public static final int BUTTON_GPIO_FIELD_NUMBER = 4;
      private int buttonGpio_ = 0;
      /**
       * <pre>
       *
       * For boards without a hard wired button, this is the pin number that will be used
       * Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
       * </pre>
       *
       * <code>uint32 button_gpio = 4;</code>
       * @return The buttonGpio.
       */
      @java.lang.Override
      public int getButtonGpio() {
        return buttonGpio_;
      }

      public static final int BUZZER_GPIO_FIELD_NUMBER = 5;
      private int buzzerGpio_ = 0;
      /**
       * <pre>
       *
       * For boards without a PWM buzzer, this is the pin number that will be used
       * Defaults to PIN_BUZZER if defined.
       * </pre>
       *
       * <code>uint32 buzzer_gpio = 5;</code>
       * @return The buzzerGpio.
       */
      @java.lang.Override
      public int getBuzzerGpio() {
        return buzzerGpio_;
      }

      public static final int REBROADCAST_MODE_FIELD_NUMBER = 6;
      private int rebroadcastMode_ = 0;
      /**
       * <pre>
       *
       * Sets the role of node
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
       * @return The enum numeric value on the wire for rebroadcastMode.
       */
      @java.lang.Override public int getRebroadcastModeValue() {
        return rebroadcastMode_;
      }
      /**
       * <pre>
       *
       * Sets the role of node
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
       * @return The rebroadcastMode.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode getRebroadcastMode() {
        com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode result = com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode.forNumber(rebroadcastMode_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode.UNRECOGNIZED : result;
      }

      public static final int NODE_INFO_BROADCAST_SECS_FIELD_NUMBER = 7;
      private int nodeInfoBroadcastSecs_ = 0;
      /**
       * <pre>
       *
       * Send our nodeinfo this often
       * Defaults to 900 Seconds (15 minutes)
       * </pre>
       *
       * <code>uint32 node_info_broadcast_secs = 7;</code>
       * @return The nodeInfoBroadcastSecs.
       */
      @java.lang.Override
      public int getNodeInfoBroadcastSecs() {
        return nodeInfoBroadcastSecs_;
      }

      public static final int DOUBLE_TAP_AS_BUTTON_PRESS_FIELD_NUMBER = 8;
      private boolean doubleTapAsButtonPress_ = false;
      /**
       * <pre>
       *
       * Treat double tap interrupt on supported accelerometers as a button press if set to true
       * </pre>
       *
       * <code>bool double_tap_as_button_press = 8;</code>
       * @return The doubleTapAsButtonPress.
       */
      @java.lang.Override
      public boolean getDoubleTapAsButtonPress() {
        return doubleTapAsButtonPress_;
      }

      public static final int IS_MANAGED_FIELD_NUMBER = 9;
      private boolean isManaged_ = false;
      /**
       * <pre>
       *
       * If true, device is considered to be "managed" by a mesh administrator
       * Clients should then limit available configuration and administrative options inside the user interface
       * Moved to SecurityConfig
       * </pre>
       *
       * <code>bool is_managed = 9 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DeviceConfig.is_managed is deprecated.
       *     See meshtastic/config.proto;l=242
       * @return The isManaged.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getIsManaged() {
        return isManaged_;
      }

      public static final int DISABLE_TRIPLE_CLICK_FIELD_NUMBER = 10;
      private boolean disableTripleClick_ = false;
      /**
       * <pre>
       *
       * Disables the triple-press of user button to enable or disable GPS
       * </pre>
       *
       * <code>bool disable_triple_click = 10;</code>
       * @return The disableTripleClick.
       */
      @java.lang.Override
      public boolean getDisableTripleClick() {
        return disableTripleClick_;
      }

      public static final int TZDEF_FIELD_NUMBER = 11;
      @SuppressWarnings("serial")
      private volatile java.lang.Object tzdef_ = "";
      /**
       * <pre>
       *
       * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
       * </pre>
       *
       * <code>string tzdef = 11;</code>
       * @return The tzdef.
       */
      @java.lang.Override
      public java.lang.String getTzdef() {
        java.lang.Object ref = tzdef_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          tzdef_ = s;
          return s;
        }
      }
      /**
       * <pre>
       *
       * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
       * </pre>
       *
       * <code>string tzdef = 11;</code>
       * @return The bytes for tzdef.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTzdefBytes() {
        java.lang.Object ref = tzdef_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tzdef_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int LED_HEARTBEAT_DISABLED_FIELD_NUMBER = 12;
      private boolean ledHeartbeatDisabled_ = false;
      /**
       * <pre>
       *
       * If true, disable the default blinking LED (LED_PIN) behavior on the device
       * </pre>
       *
       * <code>bool led_heartbeat_disabled = 12;</code>
       * @return The ledHeartbeatDisabled.
       */
      @java.lang.Override
      public boolean getLedHeartbeatDisabled() {
        return ledHeartbeatDisabled_;
      }

      public static final int BUZZER_MODE_FIELD_NUMBER = 13;
      private int buzzerMode_ = 0;
      /**
       * <pre>
       *
       * Controls buzzer behavior for audio feedback
       * Defaults to ENABLED
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
       * @return The enum numeric value on the wire for buzzerMode.
       */
      @java.lang.Override public int getBuzzerModeValue() {
        return buzzerMode_;
      }
      /**
       * <pre>
       *
       * Controls buzzer behavior for audio feedback
       * Defaults to ENABLED
       * </pre>
       *
       * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
       * @return The buzzerMode.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode getBuzzerMode() {
        com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode result = com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode.forNumber(buzzerMode_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (role_ != com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role.CLIENT.getNumber()) {
          output.writeEnum(1, role_);
        }
        if (serialEnabled_ != false) {
          output.writeBool(2, serialEnabled_);
        }
        if (buttonGpio_ != 0) {
          output.writeUInt32(4, buttonGpio_);
        }
        if (buzzerGpio_ != 0) {
          output.writeUInt32(5, buzzerGpio_);
        }
        if (rebroadcastMode_ != com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode.ALL.getNumber()) {
          output.writeEnum(6, rebroadcastMode_);
        }
        if (nodeInfoBroadcastSecs_ != 0) {
          output.writeUInt32(7, nodeInfoBroadcastSecs_);
        }
        if (doubleTapAsButtonPress_ != false) {
          output.writeBool(8, doubleTapAsButtonPress_);
        }
        if (isManaged_ != false) {
          output.writeBool(9, isManaged_);
        }
        if (disableTripleClick_ != false) {
          output.writeBool(10, disableTripleClick_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tzdef_)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 11, tzdef_);
        }
        if (ledHeartbeatDisabled_ != false) {
          output.writeBool(12, ledHeartbeatDisabled_);
        }
        if (buzzerMode_ != com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode.ALL_ENABLED.getNumber()) {
          output.writeEnum(13, buzzerMode_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (role_ != com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role.CLIENT.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, role_);
        }
        if (serialEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(2, serialEnabled_);
        }
        if (buttonGpio_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(4, buttonGpio_);
        }
        if (buzzerGpio_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(5, buzzerGpio_);
        }
        if (rebroadcastMode_ != com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode.ALL.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(6, rebroadcastMode_);
        }
        if (nodeInfoBroadcastSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(7, nodeInfoBroadcastSecs_);
        }
        if (doubleTapAsButtonPress_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(8, doubleTapAsButtonPress_);
        }
        if (isManaged_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(9, isManaged_);
        }
        if (disableTripleClick_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(10, disableTripleClick_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tzdef_)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, tzdef_);
        }
        if (ledHeartbeatDisabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(12, ledHeartbeatDisabled_);
        }
        if (buzzerMode_ != com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode.ALL_ENABLED.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(13, buzzerMode_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.DeviceConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.DeviceConfig other = (com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) obj;

        if (role_ != other.role_) return false;
        if (getSerialEnabled()
            != other.getSerialEnabled()) return false;
        if (getButtonGpio()
            != other.getButtonGpio()) return false;
        if (getBuzzerGpio()
            != other.getBuzzerGpio()) return false;
        if (rebroadcastMode_ != other.rebroadcastMode_) return false;
        if (getNodeInfoBroadcastSecs()
            != other.getNodeInfoBroadcastSecs()) return false;
        if (getDoubleTapAsButtonPress()
            != other.getDoubleTapAsButtonPress()) return false;
        if (getIsManaged()
            != other.getIsManaged()) return false;
        if (getDisableTripleClick()
            != other.getDisableTripleClick()) return false;
        if (!getTzdef()
            .equals(other.getTzdef())) return false;
        if (getLedHeartbeatDisabled()
            != other.getLedHeartbeatDisabled()) return false;
        if (buzzerMode_ != other.buzzerMode_) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + ROLE_FIELD_NUMBER;
        hash = (53 * hash) + role_;
        hash = (37 * hash) + SERIAL_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSerialEnabled());
        hash = (37 * hash) + BUTTON_GPIO_FIELD_NUMBER;
        hash = (53 * hash) + getButtonGpio();
        hash = (37 * hash) + BUZZER_GPIO_FIELD_NUMBER;
        hash = (53 * hash) + getBuzzerGpio();
        hash = (37 * hash) + REBROADCAST_MODE_FIELD_NUMBER;
        hash = (53 * hash) + rebroadcastMode_;
        hash = (37 * hash) + NODE_INFO_BROADCAST_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getNodeInfoBroadcastSecs();
        hash = (37 * hash) + DOUBLE_TAP_AS_BUTTON_PRESS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getDoubleTapAsButtonPress());
        hash = (37 * hash) + IS_MANAGED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsManaged());
        hash = (37 * hash) + DISABLE_TRIPLE_CLICK_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getDisableTripleClick());
        hash = (37 * hash) + TZDEF_FIELD_NUMBER;
        hash = (53 * hash) + getTzdef().hashCode();
        hash = (37 * hash) + LED_HEARTBEAT_DISABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getLedHeartbeatDisabled());
        hash = (37 * hash) + BUZZER_MODE_FIELD_NUMBER;
        hash = (53 * hash) + buzzerMode_;
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.DeviceConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       *
       * Configuration
       * </pre>
       *
       * Protobuf type {@code meshtastic.Config.DeviceConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.DeviceConfig)
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DeviceConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DeviceConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.class, com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          role_ = 0;
          serialEnabled_ = false;
          buttonGpio_ = 0;
          buzzerGpio_ = 0;
          rebroadcastMode_ = 0;
          nodeInfoBroadcastSecs_ = 0;
          doubleTapAsButtonPress_ = false;
          isManaged_ = false;
          disableTripleClick_ = false;
          tzdef_ = "";
          ledHeartbeatDisabled_ = false;
          buzzerMode_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DeviceConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfig result = new com.geeksville.mesh.ConfigProtos.Config.DeviceConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.DeviceConfig result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.role_ = role_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.serialEnabled_ = serialEnabled_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.buttonGpio_ = buttonGpio_;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.buzzerGpio_ = buzzerGpio_;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.rebroadcastMode_ = rebroadcastMode_;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.nodeInfoBroadcastSecs_ = nodeInfoBroadcastSecs_;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.doubleTapAsButtonPress_ = doubleTapAsButtonPress_;
          }
          if (((from_bitField0_ & 0x00000080) != 0)) {
            result.isManaged_ = isManaged_;
          }
          if (((from_bitField0_ & 0x00000100) != 0)) {
            result.disableTripleClick_ = disableTripleClick_;
          }
          if (((from_bitField0_ & 0x00000200) != 0)) {
            result.tzdef_ = tzdef_;
          }
          if (((from_bitField0_ & 0x00000400) != 0)) {
            result.ledHeartbeatDisabled_ = ledHeartbeatDisabled_;
          }
          if (((from_bitField0_ & 0x00000800) != 0)) {
            result.buzzerMode_ = buzzerMode_;
          }
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.DeviceConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.DeviceConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance()) return this;
          if (other.role_ != 0) {
            setRoleValue(other.getRoleValue());
          }
          if (other.getSerialEnabled() != false) {
            setSerialEnabled(other.getSerialEnabled());
          }
          if (other.getButtonGpio() != 0) {
            setButtonGpio(other.getButtonGpio());
          }
          if (other.getBuzzerGpio() != 0) {
            setBuzzerGpio(other.getBuzzerGpio());
          }
          if (other.rebroadcastMode_ != 0) {
            setRebroadcastModeValue(other.getRebroadcastModeValue());
          }
          if (other.getNodeInfoBroadcastSecs() != 0) {
            setNodeInfoBroadcastSecs(other.getNodeInfoBroadcastSecs());
          }
          if (other.getDoubleTapAsButtonPress() != false) {
            setDoubleTapAsButtonPress(other.getDoubleTapAsButtonPress());
          }
          if (other.getIsManaged() != false) {
            setIsManaged(other.getIsManaged());
          }
          if (other.getDisableTripleClick() != false) {
            setDisableTripleClick(other.getDisableTripleClick());
          }
          if (!other.getTzdef().isEmpty()) {
            tzdef_ = other.tzdef_;
            bitField0_ |= 0x00000200;
            onChanged();
          }
          if (other.getLedHeartbeatDisabled() != false) {
            setLedHeartbeatDisabled(other.getLedHeartbeatDisabled());
          }
          if (other.buzzerMode_ != 0) {
            setBuzzerModeValue(other.getBuzzerModeValue());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  role_ = input.readEnum();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  serialEnabled_ = input.readBool();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 32: {
                  buttonGpio_ = input.readUInt32();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 32
                case 40: {
                  buzzerGpio_ = input.readUInt32();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 40
                case 48: {
                  rebroadcastMode_ = input.readEnum();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 48
                case 56: {
                  nodeInfoBroadcastSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 56
                case 64: {
                  doubleTapAsButtonPress_ = input.readBool();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 64
                case 72: {
                  isManaged_ = input.readBool();
                  bitField0_ |= 0x00000080;
                  break;
                } // case 72
                case 80: {
                  disableTripleClick_ = input.readBool();
                  bitField0_ |= 0x00000100;
                  break;
                } // case 80
                case 90: {
                  tzdef_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000200;
                  break;
                } // case 90
                case 96: {
                  ledHeartbeatDisabled_ = input.readBool();
                  bitField0_ |= 0x00000400;
                  break;
                } // case 96
                case 104: {
                  buzzerMode_ = input.readEnum();
                  bitField0_ |= 0x00000800;
                  break;
                } // case 104
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int role_ = 0;
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
         * @return The enum numeric value on the wire for role.
         */
        @java.lang.Override public int getRoleValue() {
          return role_;
        }
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
         * @param value The enum numeric value on the wire for role to set.
         * @return This builder for chaining.
         */
        public Builder setRoleValue(int value) {
          role_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
         * @return The role.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role getRole() {
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role result = com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role.forNumber(role_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
         * @param value The role to set.
         * @return This builder for chaining.
         */
        public Builder setRole(com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Role value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000001;
          role_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.Role role = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearRole() {
          bitField0_ = (bitField0_ & ~0x00000001);
          role_ = 0;
          onChanged();
          return this;
        }

        private boolean serialEnabled_ ;
        /**
         * <pre>
         *
         * Disabling this will disable the SerialConsole by not initilizing the StreamAPI
         * Moved to SecurityConfig
         * </pre>
         *
         * <code>bool serial_enabled = 2 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DeviceConfig.serial_enabled is deprecated.
         *     See meshtastic/config.proto;l=207
         * @return The serialEnabled.
         */
        @java.lang.Override
        @java.lang.Deprecated public boolean getSerialEnabled() {
          return serialEnabled_;
        }
        /**
         * <pre>
         *
         * Disabling this will disable the SerialConsole by not initilizing the StreamAPI
         * Moved to SecurityConfig
         * </pre>
         *
         * <code>bool serial_enabled = 2 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DeviceConfig.serial_enabled is deprecated.
         *     See meshtastic/config.proto;l=207
         * @param value The serialEnabled to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setSerialEnabled(boolean value) {

          serialEnabled_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Disabling this will disable the SerialConsole by not initilizing the StreamAPI
         * Moved to SecurityConfig
         * </pre>
         *
         * <code>bool serial_enabled = 2 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DeviceConfig.serial_enabled is deprecated.
         *     See meshtastic/config.proto;l=207
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder clearSerialEnabled() {
          bitField0_ = (bitField0_ & ~0x00000002);
          serialEnabled_ = false;
          onChanged();
          return this;
        }

        private int buttonGpio_ ;
        /**
         * <pre>
         *
         * For boards without a hard wired button, this is the pin number that will be used
         * Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
         * </pre>
         *
         * <code>uint32 button_gpio = 4;</code>
         * @return The buttonGpio.
         */
        @java.lang.Override
        public int getButtonGpio() {
          return buttonGpio_;
        }
        /**
         * <pre>
         *
         * For boards without a hard wired button, this is the pin number that will be used
         * Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
         * </pre>
         *
         * <code>uint32 button_gpio = 4;</code>
         * @param value The buttonGpio to set.
         * @return This builder for chaining.
         */
        public Builder setButtonGpio(int value) {

          buttonGpio_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * For boards without a hard wired button, this is the pin number that will be used
         * Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
         * </pre>
         *
         * <code>uint32 button_gpio = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearButtonGpio() {
          bitField0_ = (bitField0_ & ~0x00000004);
          buttonGpio_ = 0;
          onChanged();
          return this;
        }

        private int buzzerGpio_ ;
        /**
         * <pre>
         *
         * For boards without a PWM buzzer, this is the pin number that will be used
         * Defaults to PIN_BUZZER if defined.
         * </pre>
         *
         * <code>uint32 buzzer_gpio = 5;</code>
         * @return The buzzerGpio.
         */
        @java.lang.Override
        public int getBuzzerGpio() {
          return buzzerGpio_;
        }
        /**
         * <pre>
         *
         * For boards without a PWM buzzer, this is the pin number that will be used
         * Defaults to PIN_BUZZER if defined.
         * </pre>
         *
         * <code>uint32 buzzer_gpio = 5;</code>
         * @param value The buzzerGpio to set.
         * @return This builder for chaining.
         */
        public Builder setBuzzerGpio(int value) {

          buzzerGpio_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * For boards without a PWM buzzer, this is the pin number that will be used
         * Defaults to PIN_BUZZER if defined.
         * </pre>
         *
         * <code>uint32 buzzer_gpio = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearBuzzerGpio() {
          bitField0_ = (bitField0_ & ~0x00000008);
          buzzerGpio_ = 0;
          onChanged();
          return this;
        }

        private int rebroadcastMode_ = 0;
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
         * @return The enum numeric value on the wire for rebroadcastMode.
         */
        @java.lang.Override public int getRebroadcastModeValue() {
          return rebroadcastMode_;
        }
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
         * @param value The enum numeric value on the wire for rebroadcastMode to set.
         * @return This builder for chaining.
         */
        public Builder setRebroadcastModeValue(int value) {
          rebroadcastMode_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
         * @return The rebroadcastMode.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode getRebroadcastMode() {
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode result = com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode.forNumber(rebroadcastMode_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
         * @param value The rebroadcastMode to set.
         * @return This builder for chaining.
         */
        public Builder setRebroadcastMode(com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.RebroadcastMode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000010;
          rebroadcastMode_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Sets the role of node
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearRebroadcastMode() {
          bitField0_ = (bitField0_ & ~0x00000010);
          rebroadcastMode_ = 0;
          onChanged();
          return this;
        }

        private int nodeInfoBroadcastSecs_ ;
        /**
         * <pre>
         *
         * Send our nodeinfo this often
         * Defaults to 900 Seconds (15 minutes)
         * </pre>
         *
         * <code>uint32 node_info_broadcast_secs = 7;</code>
         * @return The nodeInfoBroadcastSecs.
         */
        @java.lang.Override
        public int getNodeInfoBroadcastSecs() {
          return nodeInfoBroadcastSecs_;
        }
        /**
         * <pre>
         *
         * Send our nodeinfo this often
         * Defaults to 900 Seconds (15 minutes)
         * </pre>
         *
         * <code>uint32 node_info_broadcast_secs = 7;</code>
         * @param value The nodeInfoBroadcastSecs to set.
         * @return This builder for chaining.
         */
        public Builder setNodeInfoBroadcastSecs(int value) {

          nodeInfoBroadcastSecs_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Send our nodeinfo this often
         * Defaults to 900 Seconds (15 minutes)
         * </pre>
         *
         * <code>uint32 node_info_broadcast_secs = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearNodeInfoBroadcastSecs() {
          bitField0_ = (bitField0_ & ~0x00000020);
          nodeInfoBroadcastSecs_ = 0;
          onChanged();
          return this;
        }

        private boolean doubleTapAsButtonPress_ ;
        /**
         * <pre>
         *
         * Treat double tap interrupt on supported accelerometers as a button press if set to true
         * </pre>
         *
         * <code>bool double_tap_as_button_press = 8;</code>
         * @return The doubleTapAsButtonPress.
         */
        @java.lang.Override
        public boolean getDoubleTapAsButtonPress() {
          return doubleTapAsButtonPress_;
        }
        /**
         * <pre>
         *
         * Treat double tap interrupt on supported accelerometers as a button press if set to true
         * </pre>
         *
         * <code>bool double_tap_as_button_press = 8;</code>
         * @param value The doubleTapAsButtonPress to set.
         * @return This builder for chaining.
         */
        public Builder setDoubleTapAsButtonPress(boolean value) {

          doubleTapAsButtonPress_ = value;
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Treat double tap interrupt on supported accelerometers as a button press if set to true
         * </pre>
         *
         * <code>bool double_tap_as_button_press = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearDoubleTapAsButtonPress() {
          bitField0_ = (bitField0_ & ~0x00000040);
          doubleTapAsButtonPress_ = false;
          onChanged();
          return this;
        }

        private boolean isManaged_ ;
        /**
         * <pre>
         *
         * If true, device is considered to be "managed" by a mesh administrator
         * Clients should then limit available configuration and administrative options inside the user interface
         * Moved to SecurityConfig
         * </pre>
         *
         * <code>bool is_managed = 9 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DeviceConfig.is_managed is deprecated.
         *     See meshtastic/config.proto;l=242
         * @return The isManaged.
         */
        @java.lang.Override
        @java.lang.Deprecated public boolean getIsManaged() {
          return isManaged_;
        }
        /**
         * <pre>
         *
         * If true, device is considered to be "managed" by a mesh administrator
         * Clients should then limit available configuration and administrative options inside the user interface
         * Moved to SecurityConfig
         * </pre>
         *
         * <code>bool is_managed = 9 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DeviceConfig.is_managed is deprecated.
         *     See meshtastic/config.proto;l=242
         * @param value The isManaged to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setIsManaged(boolean value) {

          isManaged_ = value;
          bitField0_ |= 0x00000080;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If true, device is considered to be "managed" by a mesh administrator
         * Clients should then limit available configuration and administrative options inside the user interface
         * Moved to SecurityConfig
         * </pre>
         *
         * <code>bool is_managed = 9 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DeviceConfig.is_managed is deprecated.
         *     See meshtastic/config.proto;l=242
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder clearIsManaged() {
          bitField0_ = (bitField0_ & ~0x00000080);
          isManaged_ = false;
          onChanged();
          return this;
        }

        private boolean disableTripleClick_ ;
        /**
         * <pre>
         *
         * Disables the triple-press of user button to enable or disable GPS
         * </pre>
         *
         * <code>bool disable_triple_click = 10;</code>
         * @return The disableTripleClick.
         */
        @java.lang.Override
        public boolean getDisableTripleClick() {
          return disableTripleClick_;
        }
        /**
         * <pre>
         *
         * Disables the triple-press of user button to enable or disable GPS
         * </pre>
         *
         * <code>bool disable_triple_click = 10;</code>
         * @param value The disableTripleClick to set.
         * @return This builder for chaining.
         */
        public Builder setDisableTripleClick(boolean value) {

          disableTripleClick_ = value;
          bitField0_ |= 0x00000100;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Disables the triple-press of user button to enable or disable GPS
         * </pre>
         *
         * <code>bool disable_triple_click = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearDisableTripleClick() {
          bitField0_ = (bitField0_ & ~0x00000100);
          disableTripleClick_ = false;
          onChanged();
          return this;
        }

        private java.lang.Object tzdef_ = "";
        /**
         * <pre>
         *
         * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
         * </pre>
         *
         * <code>string tzdef = 11;</code>
         * @return The tzdef.
         */
        public java.lang.String getTzdef() {
          java.lang.Object ref = tzdef_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            tzdef_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         *
         * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
         * </pre>
         *
         * <code>string tzdef = 11;</code>
         * @return The bytes for tzdef.
         */
        public com.google.protobuf.ByteString
            getTzdefBytes() {
          java.lang.Object ref = tzdef_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            tzdef_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         *
         * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
         * </pre>
         *
         * <code>string tzdef = 11;</code>
         * @param value The tzdef to set.
         * @return This builder for chaining.
         */
        public Builder setTzdef(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          tzdef_ = value;
          bitField0_ |= 0x00000200;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
         * </pre>
         *
         * <code>string tzdef = 11;</code>
         * @return This builder for chaining.
         */
        public Builder clearTzdef() {
          tzdef_ = getDefaultInstance().getTzdef();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
         * </pre>
         *
         * <code>string tzdef = 11;</code>
         * @param value The bytes for tzdef to set.
         * @return This builder for chaining.
         */
        public Builder setTzdefBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          checkByteStringIsUtf8(value);
          tzdef_ = value;
          bitField0_ |= 0x00000200;
          onChanged();
          return this;
        }

        private boolean ledHeartbeatDisabled_ ;
        /**
         * <pre>
         *
         * If true, disable the default blinking LED (LED_PIN) behavior on the device
         * </pre>
         *
         * <code>bool led_heartbeat_disabled = 12;</code>
         * @return The ledHeartbeatDisabled.
         */
        @java.lang.Override
        public boolean getLedHeartbeatDisabled() {
          return ledHeartbeatDisabled_;
        }
        /**
         * <pre>
         *
         * If true, disable the default blinking LED (LED_PIN) behavior on the device
         * </pre>
         *
         * <code>bool led_heartbeat_disabled = 12;</code>
         * @param value The ledHeartbeatDisabled to set.
         * @return This builder for chaining.
         */
        public Builder setLedHeartbeatDisabled(boolean value) {

          ledHeartbeatDisabled_ = value;
          bitField0_ |= 0x00000400;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If true, disable the default blinking LED (LED_PIN) behavior on the device
         * </pre>
         *
         * <code>bool led_heartbeat_disabled = 12;</code>
         * @return This builder for chaining.
         */
        public Builder clearLedHeartbeatDisabled() {
          bitField0_ = (bitField0_ & ~0x00000400);
          ledHeartbeatDisabled_ = false;
          onChanged();
          return this;
        }

        private int buzzerMode_ = 0;
        /**
         * <pre>
         *
         * Controls buzzer behavior for audio feedback
         * Defaults to ENABLED
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
         * @return The enum numeric value on the wire for buzzerMode.
         */
        @java.lang.Override public int getBuzzerModeValue() {
          return buzzerMode_;
        }
        /**
         * <pre>
         *
         * Controls buzzer behavior for audio feedback
         * Defaults to ENABLED
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
         * @param value The enum numeric value on the wire for buzzerMode to set.
         * @return This builder for chaining.
         */
        public Builder setBuzzerModeValue(int value) {
          buzzerMode_ = value;
          bitField0_ |= 0x00000800;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Controls buzzer behavior for audio feedback
         * Defaults to ENABLED
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
         * @return The buzzerMode.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode getBuzzerMode() {
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode result = com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode.forNumber(buzzerMode_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Controls buzzer behavior for audio feedback
         * Defaults to ENABLED
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
         * @param value The buzzerMode to set.
         * @return This builder for chaining.
         */
        public Builder setBuzzerMode(com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.BuzzerMode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000800;
          buzzerMode_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Controls buzzer behavior for audio feedback
         * Defaults to ENABLED
         * </pre>
         *
         * <code>.meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;</code>
         * @return This builder for chaining.
         */
        public Builder clearBuzzerMode() {
          bitField0_ = (bitField0_ & ~0x00000800);
          buzzerMode_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.DeviceConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.DeviceConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.DeviceConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.DeviceConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.DeviceConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<DeviceConfig>
          PARSER = new com.google.protobuf.AbstractParser<DeviceConfig>() {
        @java.lang.Override
        public DeviceConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<DeviceConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<DeviceConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface PositionConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.PositionConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       *
       * We should send our position this often (but only if it has changed significantly)
       * Defaults to 15 minutes
       * </pre>
       *
       * <code>uint32 position_broadcast_secs = 1;</code>
       * @return The positionBroadcastSecs.
       */
      int getPositionBroadcastSecs();

      /**
       * <pre>
       *
       * Adaptive position braoadcast, which is now the default.
       * </pre>
       *
       * <code>bool position_broadcast_smart_enabled = 2;</code>
       * @return The positionBroadcastSmartEnabled.
       */
      boolean getPositionBroadcastSmartEnabled();

      /**
       * <pre>
       *
       * If set, this node is at a fixed position.
       * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
       * The lat/lon/alt can be set by an internal GPS or with the help of the app.
       * </pre>
       *
       * <code>bool fixed_position = 3;</code>
       * @return The fixedPosition.
       */
      boolean getFixedPosition();

      /**
       * <pre>
       *
       * Is GPS enabled for this node?
       * </pre>
       *
       * <code>bool gps_enabled = 4 [deprecated = true];</code>
       * @deprecated meshtastic.Config.PositionConfig.gps_enabled is deprecated.
       *     See meshtastic/config.proto;l=377
       * @return The gpsEnabled.
       */
      @java.lang.Deprecated boolean getGpsEnabled();

      /**
       * <pre>
       *
       * How often should we try to get GPS position (in seconds)
       * or zero for the default of once every 30 seconds
       * or a very large value (maxint) to update only once at boot.
       * </pre>
       *
       * <code>uint32 gps_update_interval = 5;</code>
       * @return The gpsUpdateInterval.
       */
      int getGpsUpdateInterval();

      /**
       * <pre>
       *
       * Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
       * </pre>
       *
       * <code>uint32 gps_attempt_time = 6 [deprecated = true];</code>
       * @deprecated meshtastic.Config.PositionConfig.gps_attempt_time is deprecated.
       *     See meshtastic/config.proto;l=389
       * @return The gpsAttemptTime.
       */
      @java.lang.Deprecated int getGpsAttemptTime();

      /**
       * <pre>
       *
       * Bit field of boolean configuration options for POSITION messages
       * (bitwise OR of PositionFlags)
       * </pre>
       *
       * <code>uint32 position_flags = 7;</code>
       * @return The positionFlags.
       */
      int getPositionFlags();

      /**
       * <pre>
       *
       * (Re)define GPS_RX_PIN for your board.
       * </pre>
       *
       * <code>uint32 rx_gpio = 8;</code>
       * @return The rxGpio.
       */
      int getRxGpio();

      /**
       * <pre>
       *
       * (Re)define GPS_TX_PIN for your board.
       * </pre>
       *
       * <code>uint32 tx_gpio = 9;</code>
       * @return The txGpio.
       */
      int getTxGpio();

      /**
       * <pre>
       *
       * The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
       * </pre>
       *
       * <code>uint32 broadcast_smart_minimum_distance = 10;</code>
       * @return The broadcastSmartMinimumDistance.
       */
      int getBroadcastSmartMinimumDistance();

      /**
       * <pre>
       *
       * The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
       * </pre>
       *
       * <code>uint32 broadcast_smart_minimum_interval_secs = 11;</code>
       * @return The broadcastSmartMinimumIntervalSecs.
       */
      int getBroadcastSmartMinimumIntervalSecs();

      /**
       * <pre>
       *
       * (Re)define PIN_GPS_EN for your board.
       * </pre>
       *
       * <code>uint32 gps_en_gpio = 12;</code>
       * @return The gpsEnGpio.
       */
      int getGpsEnGpio();

      /**
       * <pre>
       *
       * Set where GPS is enabled, disabled, or not present
       * </pre>
       *
       * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
       * @return The enum numeric value on the wire for gpsMode.
       */
      int getGpsModeValue();
      /**
       * <pre>
       *
       * Set where GPS is enabled, disabled, or not present
       * </pre>
       *
       * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
       * @return The gpsMode.
       */
      com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode getGpsMode();
    }
    /**
     * <pre>
     *
     * Position Config
     * </pre>
     *
     * Protobuf type {@code meshtastic.Config.PositionConfig}
     */
    public static final class PositionConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.PositionConfig)
        PositionConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use PositionConfig.newBuilder() to construct.
      private PositionConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private PositionConfig() {
        gpsMode_ = 0;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new PositionConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PositionConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PositionConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.PositionConfig.class, com.geeksville.mesh.ConfigProtos.Config.PositionConfig.Builder.class);
      }

      /**
       * <pre>
       *
       * Bit field of boolean configuration options, indicating which optional
       * fields to include when assembling POSITION messages.
       * Longitude, latitude, altitude, speed, heading, and DOP
       * are always included (also time if GPS-synced)
       * NOTE: the more fields are included, the larger the message will be -
       *   leading to longer airtime and a higher risk of packet loss
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.PositionConfig.PositionFlags}
       */
      public enum PositionFlags
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Required for compilation
         * </pre>
         *
         * <code>UNSET = 0;</code>
         */
        UNSET(0),
        /**
         * <pre>
         *
         * Include an altitude value (if available)
         * </pre>
         *
         * <code>ALTITUDE = 1;</code>
         */
        ALTITUDE(1),
        /**
         * <pre>
         *
         * Altitude value is MSL
         * </pre>
         *
         * <code>ALTITUDE_MSL = 2;</code>
         */
        ALTITUDE_MSL(2),
        /**
         * <pre>
         *
         * Include geoidal separation
         * </pre>
         *
         * <code>GEOIDAL_SEPARATION = 4;</code>
         */
        GEOIDAL_SEPARATION(4),
        /**
         * <pre>
         *
         * Include the DOP value ; PDOP used by default, see below
         * </pre>
         *
         * <code>DOP = 8;</code>
         */
        DOP(8),
        /**
         * <pre>
         *
         * If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
         * </pre>
         *
         * <code>HVDOP = 16;</code>
         */
        HVDOP(16),
        /**
         * <pre>
         *
         * Include number of "satellites in view"
         * </pre>
         *
         * <code>SATINVIEW = 32;</code>
         */
        SATINVIEW(32),
        /**
         * <pre>
         *
         * Include a sequence number incremented per packet
         * </pre>
         *
         * <code>SEQ_NO = 64;</code>
         */
        SEQ_NO(64),
        /**
         * <pre>
         *
         * Include positional timestamp (from GPS solution)
         * </pre>
         *
         * <code>TIMESTAMP = 128;</code>
         */
        TIMESTAMP(128),
        /**
         * <pre>
         *
         * Include positional heading
         * Intended for use with vehicle not walking speeds
         * walking speeds are likely to be error prone like the compass
         * </pre>
         *
         * <code>HEADING = 256;</code>
         */
        HEADING(256),
        /**
         * <pre>
         *
         * Include positional speed
         * Intended for use with vehicle not walking speeds
         * walking speeds are likely to be error prone like the compass
         * </pre>
         *
         * <code>SPEED = 512;</code>
         */
        SPEED(512),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Required for compilation
         * </pre>
         *
         * <code>UNSET = 0;</code>
         */
        public static final int UNSET_VALUE = 0;
        /**
         * <pre>
         *
         * Include an altitude value (if available)
         * </pre>
         *
         * <code>ALTITUDE = 1;</code>
         */
        public static final int ALTITUDE_VALUE = 1;
        /**
         * <pre>
         *
         * Altitude value is MSL
         * </pre>
         *
         * <code>ALTITUDE_MSL = 2;</code>
         */
        public static final int ALTITUDE_MSL_VALUE = 2;
        /**
         * <pre>
         *
         * Include geoidal separation
         * </pre>
         *
         * <code>GEOIDAL_SEPARATION = 4;</code>
         */
        public static final int GEOIDAL_SEPARATION_VALUE = 4;
        /**
         * <pre>
         *
         * Include the DOP value ; PDOP used by default, see below
         * </pre>
         *
         * <code>DOP = 8;</code>
         */
        public static final int DOP_VALUE = 8;
        /**
         * <pre>
         *
         * If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
         * </pre>
         *
         * <code>HVDOP = 16;</code>
         */
        public static final int HVDOP_VALUE = 16;
        /**
         * <pre>
         *
         * Include number of "satellites in view"
         * </pre>
         *
         * <code>SATINVIEW = 32;</code>
         */
        public static final int SATINVIEW_VALUE = 32;
        /**
         * <pre>
         *
         * Include a sequence number incremented per packet
         * </pre>
         *
         * <code>SEQ_NO = 64;</code>
         */
        public static final int SEQ_NO_VALUE = 64;
        /**
         * <pre>
         *
         * Include positional timestamp (from GPS solution)
         * </pre>
         *
         * <code>TIMESTAMP = 128;</code>
         */
        public static final int TIMESTAMP_VALUE = 128;
        /**
         * <pre>
         *
         * Include positional heading
         * Intended for use with vehicle not walking speeds
         * walking speeds are likely to be error prone like the compass
         * </pre>
         *
         * <code>HEADING = 256;</code>
         */
        public static final int HEADING_VALUE = 256;
        /**
         * <pre>
         *
         * Include positional speed
         * Intended for use with vehicle not walking speeds
         * walking speeds are likely to be error prone like the compass
         * </pre>
         *
         * <code>SPEED = 512;</code>
         */
        public static final int SPEED_VALUE = 512;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static PositionFlags valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static PositionFlags forNumber(int value) {
          switch (value) {
            case 0: return UNSET;
            case 1: return ALTITUDE;
            case 2: return ALTITUDE_MSL;
            case 4: return GEOIDAL_SEPARATION;
            case 8: return DOP;
            case 16: return HVDOP;
            case 32: return SATINVIEW;
            case 64: return SEQ_NO;
            case 128: return TIMESTAMP;
            case 256: return HEADING;
            case 512: return SPEED;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<PositionFlags>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            PositionFlags> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<PositionFlags>() {
                public PositionFlags findValueByNumber(int number) {
                  return PositionFlags.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDescriptor().getEnumTypes().get(0);
        }

        private static final PositionFlags[] VALUES = values();

        public static PositionFlags valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private PositionFlags(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.PositionConfig.PositionFlags)
      }

      /**
       * Protobuf enum {@code meshtastic.Config.PositionConfig.GpsMode}
       */
      public enum GpsMode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * GPS is present but disabled
         * </pre>
         *
         * <code>DISABLED = 0;</code>
         */
        DISABLED(0),
        /**
         * <pre>
         *
         * GPS is present and enabled
         * </pre>
         *
         * <code>ENABLED = 1;</code>
         */
        ENABLED(1),
        /**
         * <pre>
         *
         * GPS is not present on the device
         * </pre>
         *
         * <code>NOT_PRESENT = 2;</code>
         */
        NOT_PRESENT(2),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * GPS is present but disabled
         * </pre>
         *
         * <code>DISABLED = 0;</code>
         */
        public static final int DISABLED_VALUE = 0;
        /**
         * <pre>
         *
         * GPS is present and enabled
         * </pre>
         *
         * <code>ENABLED = 1;</code>
         */
        public static final int ENABLED_VALUE = 1;
        /**
         * <pre>
         *
         * GPS is not present on the device
         * </pre>
         *
         * <code>NOT_PRESENT = 2;</code>
         */
        public static final int NOT_PRESENT_VALUE = 2;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static GpsMode valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static GpsMode forNumber(int value) {
          switch (value) {
            case 0: return DISABLED;
            case 1: return ENABLED;
            case 2: return NOT_PRESENT;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<GpsMode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            GpsMode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<GpsMode>() {
                public GpsMode findValueByNumber(int number) {
                  return GpsMode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDescriptor().getEnumTypes().get(1);
        }

        private static final GpsMode[] VALUES = values();

        public static GpsMode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private GpsMode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.PositionConfig.GpsMode)
      }

      public static final int POSITION_BROADCAST_SECS_FIELD_NUMBER = 1;
      private int positionBroadcastSecs_ = 0;
      /**
       * <pre>
       *
       * We should send our position this often (but only if it has changed significantly)
       * Defaults to 15 minutes
       * </pre>
       *
       * <code>uint32 position_broadcast_secs = 1;</code>
       * @return The positionBroadcastSecs.
       */
      @java.lang.Override
      public int getPositionBroadcastSecs() {
        return positionBroadcastSecs_;
      }

      public static final int POSITION_BROADCAST_SMART_ENABLED_FIELD_NUMBER = 2;
      private boolean positionBroadcastSmartEnabled_ = false;
      /**
       * <pre>
       *
       * Adaptive position braoadcast, which is now the default.
       * </pre>
       *
       * <code>bool position_broadcast_smart_enabled = 2;</code>
       * @return The positionBroadcastSmartEnabled.
       */
      @java.lang.Override
      public boolean getPositionBroadcastSmartEnabled() {
        return positionBroadcastSmartEnabled_;
      }

      public static final int FIXED_POSITION_FIELD_NUMBER = 3;
      private boolean fixedPosition_ = false;
      /**
       * <pre>
       *
       * If set, this node is at a fixed position.
       * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
       * The lat/lon/alt can be set by an internal GPS or with the help of the app.
       * </pre>
       *
       * <code>bool fixed_position = 3;</code>
       * @return The fixedPosition.
       */
      @java.lang.Override
      public boolean getFixedPosition() {
        return fixedPosition_;
      }

      public static final int GPS_ENABLED_FIELD_NUMBER = 4;
      private boolean gpsEnabled_ = false;
      /**
       * <pre>
       *
       * Is GPS enabled for this node?
       * </pre>
       *
       * <code>bool gps_enabled = 4 [deprecated = true];</code>
       * @deprecated meshtastic.Config.PositionConfig.gps_enabled is deprecated.
       *     See meshtastic/config.proto;l=377
       * @return The gpsEnabled.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getGpsEnabled() {
        return gpsEnabled_;
      }

      public static final int GPS_UPDATE_INTERVAL_FIELD_NUMBER = 5;
      private int gpsUpdateInterval_ = 0;
      /**
       * <pre>
       *
       * How often should we try to get GPS position (in seconds)
       * or zero for the default of once every 30 seconds
       * or a very large value (maxint) to update only once at boot.
       * </pre>
       *
       * <code>uint32 gps_update_interval = 5;</code>
       * @return The gpsUpdateInterval.
       */
      @java.lang.Override
      public int getGpsUpdateInterval() {
        return gpsUpdateInterval_;
      }

      public static final int GPS_ATTEMPT_TIME_FIELD_NUMBER = 6;
      private int gpsAttemptTime_ = 0;
      /**
       * <pre>
       *
       * Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
       * </pre>
       *
       * <code>uint32 gps_attempt_time = 6 [deprecated = true];</code>
       * @deprecated meshtastic.Config.PositionConfig.gps_attempt_time is deprecated.
       *     See meshtastic/config.proto;l=389
       * @return The gpsAttemptTime.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getGpsAttemptTime() {
        return gpsAttemptTime_;
      }

      public static final int POSITION_FLAGS_FIELD_NUMBER = 7;
      private int positionFlags_ = 0;
      /**
       * <pre>
       *
       * Bit field of boolean configuration options for POSITION messages
       * (bitwise OR of PositionFlags)
       * </pre>
       *
       * <code>uint32 position_flags = 7;</code>
       * @return The positionFlags.
       */
      @java.lang.Override
      public int getPositionFlags() {
        return positionFlags_;
      }

      public static final int RX_GPIO_FIELD_NUMBER = 8;
      private int rxGpio_ = 0;
      /**
       * <pre>
       *
       * (Re)define GPS_RX_PIN for your board.
       * </pre>
       *
       * <code>uint32 rx_gpio = 8;</code>
       * @return The rxGpio.
       */
      @java.lang.Override
      public int getRxGpio() {
        return rxGpio_;
      }

      public static final int TX_GPIO_FIELD_NUMBER = 9;
      private int txGpio_ = 0;
      /**
       * <pre>
       *
       * (Re)define GPS_TX_PIN for your board.
       * </pre>
       *
       * <code>uint32 tx_gpio = 9;</code>
       * @return The txGpio.
       */
      @java.lang.Override
      public int getTxGpio() {
        return txGpio_;
      }

      public static final int BROADCAST_SMART_MINIMUM_DISTANCE_FIELD_NUMBER = 10;
      private int broadcastSmartMinimumDistance_ = 0;
      /**
       * <pre>
       *
       * The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
       * </pre>
       *
       * <code>uint32 broadcast_smart_minimum_distance = 10;</code>
       * @return The broadcastSmartMinimumDistance.
       */
      @java.lang.Override
      public int getBroadcastSmartMinimumDistance() {
        return broadcastSmartMinimumDistance_;
      }

      public static final int BROADCAST_SMART_MINIMUM_INTERVAL_SECS_FIELD_NUMBER = 11;
      private int broadcastSmartMinimumIntervalSecs_ = 0;
      /**
       * <pre>
       *
       * The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
       * </pre>
       *
       * <code>uint32 broadcast_smart_minimum_interval_secs = 11;</code>
       * @return The broadcastSmartMinimumIntervalSecs.
       */
      @java.lang.Override
      public int getBroadcastSmartMinimumIntervalSecs() {
        return broadcastSmartMinimumIntervalSecs_;
      }

      public static final int GPS_EN_GPIO_FIELD_NUMBER = 12;
      private int gpsEnGpio_ = 0;
      /**
       * <pre>
       *
       * (Re)define PIN_GPS_EN for your board.
       * </pre>
       *
       * <code>uint32 gps_en_gpio = 12;</code>
       * @return The gpsEnGpio.
       */
      @java.lang.Override
      public int getGpsEnGpio() {
        return gpsEnGpio_;
      }

      public static final int GPS_MODE_FIELD_NUMBER = 13;
      private int gpsMode_ = 0;
      /**
       * <pre>
       *
       * Set where GPS is enabled, disabled, or not present
       * </pre>
       *
       * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
       * @return The enum numeric value on the wire for gpsMode.
       */
      @java.lang.Override public int getGpsModeValue() {
        return gpsMode_;
      }
      /**
       * <pre>
       *
       * Set where GPS is enabled, disabled, or not present
       * </pre>
       *
       * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
       * @return The gpsMode.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode getGpsMode() {
        com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode result = com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode.forNumber(gpsMode_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (positionBroadcastSecs_ != 0) {
          output.writeUInt32(1, positionBroadcastSecs_);
        }
        if (positionBroadcastSmartEnabled_ != false) {
          output.writeBool(2, positionBroadcastSmartEnabled_);
        }
        if (fixedPosition_ != false) {
          output.writeBool(3, fixedPosition_);
        }
        if (gpsEnabled_ != false) {
          output.writeBool(4, gpsEnabled_);
        }
        if (gpsUpdateInterval_ != 0) {
          output.writeUInt32(5, gpsUpdateInterval_);
        }
        if (gpsAttemptTime_ != 0) {
          output.writeUInt32(6, gpsAttemptTime_);
        }
        if (positionFlags_ != 0) {
          output.writeUInt32(7, positionFlags_);
        }
        if (rxGpio_ != 0) {
          output.writeUInt32(8, rxGpio_);
        }
        if (txGpio_ != 0) {
          output.writeUInt32(9, txGpio_);
        }
        if (broadcastSmartMinimumDistance_ != 0) {
          output.writeUInt32(10, broadcastSmartMinimumDistance_);
        }
        if (broadcastSmartMinimumIntervalSecs_ != 0) {
          output.writeUInt32(11, broadcastSmartMinimumIntervalSecs_);
        }
        if (gpsEnGpio_ != 0) {
          output.writeUInt32(12, gpsEnGpio_);
        }
        if (gpsMode_ != com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode.DISABLED.getNumber()) {
          output.writeEnum(13, gpsMode_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (positionBroadcastSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, positionBroadcastSecs_);
        }
        if (positionBroadcastSmartEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(2, positionBroadcastSmartEnabled_);
        }
        if (fixedPosition_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(3, fixedPosition_);
        }
        if (gpsEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(4, gpsEnabled_);
        }
        if (gpsUpdateInterval_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(5, gpsUpdateInterval_);
        }
        if (gpsAttemptTime_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(6, gpsAttemptTime_);
        }
        if (positionFlags_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(7, positionFlags_);
        }
        if (rxGpio_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(8, rxGpio_);
        }
        if (txGpio_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(9, txGpio_);
        }
        if (broadcastSmartMinimumDistance_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(10, broadcastSmartMinimumDistance_);
        }
        if (broadcastSmartMinimumIntervalSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(11, broadcastSmartMinimumIntervalSecs_);
        }
        if (gpsEnGpio_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(12, gpsEnGpio_);
        }
        if (gpsMode_ != com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode.DISABLED.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(13, gpsMode_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.PositionConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.PositionConfig other = (com.geeksville.mesh.ConfigProtos.Config.PositionConfig) obj;

        if (getPositionBroadcastSecs()
            != other.getPositionBroadcastSecs()) return false;
        if (getPositionBroadcastSmartEnabled()
            != other.getPositionBroadcastSmartEnabled()) return false;
        if (getFixedPosition()
            != other.getFixedPosition()) return false;
        if (getGpsEnabled()
            != other.getGpsEnabled()) return false;
        if (getGpsUpdateInterval()
            != other.getGpsUpdateInterval()) return false;
        if (getGpsAttemptTime()
            != other.getGpsAttemptTime()) return false;
        if (getPositionFlags()
            != other.getPositionFlags()) return false;
        if (getRxGpio()
            != other.getRxGpio()) return false;
        if (getTxGpio()
            != other.getTxGpio()) return false;
        if (getBroadcastSmartMinimumDistance()
            != other.getBroadcastSmartMinimumDistance()) return false;
        if (getBroadcastSmartMinimumIntervalSecs()
            != other.getBroadcastSmartMinimumIntervalSecs()) return false;
        if (getGpsEnGpio()
            != other.getGpsEnGpio()) return false;
        if (gpsMode_ != other.gpsMode_) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + POSITION_BROADCAST_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getPositionBroadcastSecs();
        hash = (37 * hash) + POSITION_BROADCAST_SMART_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPositionBroadcastSmartEnabled());
        hash = (37 * hash) + FIXED_POSITION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getFixedPosition());
        hash = (37 * hash) + GPS_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getGpsEnabled());
        hash = (37 * hash) + GPS_UPDATE_INTERVAL_FIELD_NUMBER;
        hash = (53 * hash) + getGpsUpdateInterval();
        hash = (37 * hash) + GPS_ATTEMPT_TIME_FIELD_NUMBER;
        hash = (53 * hash) + getGpsAttemptTime();
        hash = (37 * hash) + POSITION_FLAGS_FIELD_NUMBER;
        hash = (53 * hash) + getPositionFlags();
        hash = (37 * hash) + RX_GPIO_FIELD_NUMBER;
        hash = (53 * hash) + getRxGpio();
        hash = (37 * hash) + TX_GPIO_FIELD_NUMBER;
        hash = (53 * hash) + getTxGpio();
        hash = (37 * hash) + BROADCAST_SMART_MINIMUM_DISTANCE_FIELD_NUMBER;
        hash = (53 * hash) + getBroadcastSmartMinimumDistance();
        hash = (37 * hash) + BROADCAST_SMART_MINIMUM_INTERVAL_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getBroadcastSmartMinimumIntervalSecs();
        hash = (37 * hash) + GPS_EN_GPIO_FIELD_NUMBER;
        hash = (53 * hash) + getGpsEnGpio();
        hash = (37 * hash) + GPS_MODE_FIELD_NUMBER;
        hash = (53 * hash) + gpsMode_;
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.PositionConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       *
       * Position Config
       * </pre>
       *
       * Protobuf type {@code meshtastic.Config.PositionConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.PositionConfig)
          com.geeksville.mesh.ConfigProtos.Config.PositionConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PositionConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PositionConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.PositionConfig.class, com.geeksville.mesh.ConfigProtos.Config.PositionConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.PositionConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          positionBroadcastSecs_ = 0;
          positionBroadcastSmartEnabled_ = false;
          fixedPosition_ = false;
          gpsEnabled_ = false;
          gpsUpdateInterval_ = 0;
          gpsAttemptTime_ = 0;
          positionFlags_ = 0;
          rxGpio_ = 0;
          txGpio_ = 0;
          broadcastSmartMinimumDistance_ = 0;
          broadcastSmartMinimumIntervalSecs_ = 0;
          gpsEnGpio_ = 0;
          gpsMode_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PositionConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.PositionConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.PositionConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.PositionConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.PositionConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.PositionConfig result = new com.geeksville.mesh.ConfigProtos.Config.PositionConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.PositionConfig result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.positionBroadcastSecs_ = positionBroadcastSecs_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.positionBroadcastSmartEnabled_ = positionBroadcastSmartEnabled_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.fixedPosition_ = fixedPosition_;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.gpsEnabled_ = gpsEnabled_;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.gpsUpdateInterval_ = gpsUpdateInterval_;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.gpsAttemptTime_ = gpsAttemptTime_;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.positionFlags_ = positionFlags_;
          }
          if (((from_bitField0_ & 0x00000080) != 0)) {
            result.rxGpio_ = rxGpio_;
          }
          if (((from_bitField0_ & 0x00000100) != 0)) {
            result.txGpio_ = txGpio_;
          }
          if (((from_bitField0_ & 0x00000200) != 0)) {
            result.broadcastSmartMinimumDistance_ = broadcastSmartMinimumDistance_;
          }
          if (((from_bitField0_ & 0x00000400) != 0)) {
            result.broadcastSmartMinimumIntervalSecs_ = broadcastSmartMinimumIntervalSecs_;
          }
          if (((from_bitField0_ & 0x00000800) != 0)) {
            result.gpsEnGpio_ = gpsEnGpio_;
          }
          if (((from_bitField0_ & 0x00001000) != 0)) {
            result.gpsMode_ = gpsMode_;
          }
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.PositionConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.PositionConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.PositionConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance()) return this;
          if (other.getPositionBroadcastSecs() != 0) {
            setPositionBroadcastSecs(other.getPositionBroadcastSecs());
          }
          if (other.getPositionBroadcastSmartEnabled() != false) {
            setPositionBroadcastSmartEnabled(other.getPositionBroadcastSmartEnabled());
          }
          if (other.getFixedPosition() != false) {
            setFixedPosition(other.getFixedPosition());
          }
          if (other.getGpsEnabled() != false) {
            setGpsEnabled(other.getGpsEnabled());
          }
          if (other.getGpsUpdateInterval() != 0) {
            setGpsUpdateInterval(other.getGpsUpdateInterval());
          }
          if (other.getGpsAttemptTime() != 0) {
            setGpsAttemptTime(other.getGpsAttemptTime());
          }
          if (other.getPositionFlags() != 0) {
            setPositionFlags(other.getPositionFlags());
          }
          if (other.getRxGpio() != 0) {
            setRxGpio(other.getRxGpio());
          }
          if (other.getTxGpio() != 0) {
            setTxGpio(other.getTxGpio());
          }
          if (other.getBroadcastSmartMinimumDistance() != 0) {
            setBroadcastSmartMinimumDistance(other.getBroadcastSmartMinimumDistance());
          }
          if (other.getBroadcastSmartMinimumIntervalSecs() != 0) {
            setBroadcastSmartMinimumIntervalSecs(other.getBroadcastSmartMinimumIntervalSecs());
          }
          if (other.getGpsEnGpio() != 0) {
            setGpsEnGpio(other.getGpsEnGpio());
          }
          if (other.gpsMode_ != 0) {
            setGpsModeValue(other.getGpsModeValue());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  positionBroadcastSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  positionBroadcastSmartEnabled_ = input.readBool();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 24: {
                  fixedPosition_ = input.readBool();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 24
                case 32: {
                  gpsEnabled_ = input.readBool();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
                case 40: {
                  gpsUpdateInterval_ = input.readUInt32();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 40
                case 48: {
                  gpsAttemptTime_ = input.readUInt32();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 48
                case 56: {
                  positionFlags_ = input.readUInt32();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 56
                case 64: {
                  rxGpio_ = input.readUInt32();
                  bitField0_ |= 0x00000080;
                  break;
                } // case 64
                case 72: {
                  txGpio_ = input.readUInt32();
                  bitField0_ |= 0x00000100;
                  break;
                } // case 72
                case 80: {
                  broadcastSmartMinimumDistance_ = input.readUInt32();
                  bitField0_ |= 0x00000200;
                  break;
                } // case 80
                case 88: {
                  broadcastSmartMinimumIntervalSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000400;
                  break;
                } // case 88
                case 96: {
                  gpsEnGpio_ = input.readUInt32();
                  bitField0_ |= 0x00000800;
                  break;
                } // case 96
                case 104: {
                  gpsMode_ = input.readEnum();
                  bitField0_ |= 0x00001000;
                  break;
                } // case 104
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int positionBroadcastSecs_ ;
        /**
         * <pre>
         *
         * We should send our position this often (but only if it has changed significantly)
         * Defaults to 15 minutes
         * </pre>
         *
         * <code>uint32 position_broadcast_secs = 1;</code>
         * @return The positionBroadcastSecs.
         */
        @java.lang.Override
        public int getPositionBroadcastSecs() {
          return positionBroadcastSecs_;
        }
        /**
         * <pre>
         *
         * We should send our position this often (but only if it has changed significantly)
         * Defaults to 15 minutes
         * </pre>
         *
         * <code>uint32 position_broadcast_secs = 1;</code>
         * @param value The positionBroadcastSecs to set.
         * @return This builder for chaining.
         */
        public Builder setPositionBroadcastSecs(int value) {

          positionBroadcastSecs_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * We should send our position this often (but only if it has changed significantly)
         * Defaults to 15 minutes
         * </pre>
         *
         * <code>uint32 position_broadcast_secs = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearPositionBroadcastSecs() {
          bitField0_ = (bitField0_ & ~0x00000001);
          positionBroadcastSecs_ = 0;
          onChanged();
          return this;
        }

        private boolean positionBroadcastSmartEnabled_ ;
        /**
         * <pre>
         *
         * Adaptive position braoadcast, which is now the default.
         * </pre>
         *
         * <code>bool position_broadcast_smart_enabled = 2;</code>
         * @return The positionBroadcastSmartEnabled.
         */
        @java.lang.Override
        public boolean getPositionBroadcastSmartEnabled() {
          return positionBroadcastSmartEnabled_;
        }
        /**
         * <pre>
         *
         * Adaptive position braoadcast, which is now the default.
         * </pre>
         *
         * <code>bool position_broadcast_smart_enabled = 2;</code>
         * @param value The positionBroadcastSmartEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setPositionBroadcastSmartEnabled(boolean value) {

          positionBroadcastSmartEnabled_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Adaptive position braoadcast, which is now the default.
         * </pre>
         *
         * <code>bool position_broadcast_smart_enabled = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearPositionBroadcastSmartEnabled() {
          bitField0_ = (bitField0_ & ~0x00000002);
          positionBroadcastSmartEnabled_ = false;
          onChanged();
          return this;
        }

        private boolean fixedPosition_ ;
        /**
         * <pre>
         *
         * If set, this node is at a fixed position.
         * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
         * The lat/lon/alt can be set by an internal GPS or with the help of the app.
         * </pre>
         *
         * <code>bool fixed_position = 3;</code>
         * @return The fixedPosition.
         */
        @java.lang.Override
        public boolean getFixedPosition() {
          return fixedPosition_;
        }
        /**
         * <pre>
         *
         * If set, this node is at a fixed position.
         * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
         * The lat/lon/alt can be set by an internal GPS or with the help of the app.
         * </pre>
         *
         * <code>bool fixed_position = 3;</code>
         * @param value The fixedPosition to set.
         * @return This builder for chaining.
         */
        public Builder setFixedPosition(boolean value) {

          fixedPosition_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If set, this node is at a fixed position.
         * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
         * The lat/lon/alt can be set by an internal GPS or with the help of the app.
         * </pre>
         *
         * <code>bool fixed_position = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearFixedPosition() {
          bitField0_ = (bitField0_ & ~0x00000004);
          fixedPosition_ = false;
          onChanged();
          return this;
        }

        private boolean gpsEnabled_ ;
        /**
         * <pre>
         *
         * Is GPS enabled for this node?
         * </pre>
         *
         * <code>bool gps_enabled = 4 [deprecated = true];</code>
         * @deprecated meshtastic.Config.PositionConfig.gps_enabled is deprecated.
         *     See meshtastic/config.proto;l=377
         * @return The gpsEnabled.
         */
        @java.lang.Override
        @java.lang.Deprecated public boolean getGpsEnabled() {
          return gpsEnabled_;
        }
        /**
         * <pre>
         *
         * Is GPS enabled for this node?
         * </pre>
         *
         * <code>bool gps_enabled = 4 [deprecated = true];</code>
         * @deprecated meshtastic.Config.PositionConfig.gps_enabled is deprecated.
         *     See meshtastic/config.proto;l=377
         * @param value The gpsEnabled to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setGpsEnabled(boolean value) {

          gpsEnabled_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Is GPS enabled for this node?
         * </pre>
         *
         * <code>bool gps_enabled = 4 [deprecated = true];</code>
         * @deprecated meshtastic.Config.PositionConfig.gps_enabled is deprecated.
         *     See meshtastic/config.proto;l=377
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder clearGpsEnabled() {
          bitField0_ = (bitField0_ & ~0x00000008);
          gpsEnabled_ = false;
          onChanged();
          return this;
        }

        private int gpsUpdateInterval_ ;
        /**
         * <pre>
         *
         * How often should we try to get GPS position (in seconds)
         * or zero for the default of once every 30 seconds
         * or a very large value (maxint) to update only once at boot.
         * </pre>
         *
         * <code>uint32 gps_update_interval = 5;</code>
         * @return The gpsUpdateInterval.
         */
        @java.lang.Override
        public int getGpsUpdateInterval() {
          return gpsUpdateInterval_;
        }
        /**
         * <pre>
         *
         * How often should we try to get GPS position (in seconds)
         * or zero for the default of once every 30 seconds
         * or a very large value (maxint) to update only once at boot.
         * </pre>
         *
         * <code>uint32 gps_update_interval = 5;</code>
         * @param value The gpsUpdateInterval to set.
         * @return This builder for chaining.
         */
        public Builder setGpsUpdateInterval(int value) {

          gpsUpdateInterval_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * How often should we try to get GPS position (in seconds)
         * or zero for the default of once every 30 seconds
         * or a very large value (maxint) to update only once at boot.
         * </pre>
         *
         * <code>uint32 gps_update_interval = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearGpsUpdateInterval() {
          bitField0_ = (bitField0_ & ~0x00000010);
          gpsUpdateInterval_ = 0;
          onChanged();
          return this;
        }

        private int gpsAttemptTime_ ;
        /**
         * <pre>
         *
         * Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
         * </pre>
         *
         * <code>uint32 gps_attempt_time = 6 [deprecated = true];</code>
         * @deprecated meshtastic.Config.PositionConfig.gps_attempt_time is deprecated.
         *     See meshtastic/config.proto;l=389
         * @return The gpsAttemptTime.
         */
        @java.lang.Override
        @java.lang.Deprecated public int getGpsAttemptTime() {
          return gpsAttemptTime_;
        }
        /**
         * <pre>
         *
         * Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
         * </pre>
         *
         * <code>uint32 gps_attempt_time = 6 [deprecated = true];</code>
         * @deprecated meshtastic.Config.PositionConfig.gps_attempt_time is deprecated.
         *     See meshtastic/config.proto;l=389
         * @param value The gpsAttemptTime to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setGpsAttemptTime(int value) {

          gpsAttemptTime_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
         * </pre>
         *
         * <code>uint32 gps_attempt_time = 6 [deprecated = true];</code>
         * @deprecated meshtastic.Config.PositionConfig.gps_attempt_time is deprecated.
         *     See meshtastic/config.proto;l=389
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder clearGpsAttemptTime() {
          bitField0_ = (bitField0_ & ~0x00000020);
          gpsAttemptTime_ = 0;
          onChanged();
          return this;
        }

        private int positionFlags_ ;
        /**
         * <pre>
         *
         * Bit field of boolean configuration options for POSITION messages
         * (bitwise OR of PositionFlags)
         * </pre>
         *
         * <code>uint32 position_flags = 7;</code>
         * @return The positionFlags.
         */
        @java.lang.Override
        public int getPositionFlags() {
          return positionFlags_;
        }
        /**
         * <pre>
         *
         * Bit field of boolean configuration options for POSITION messages
         * (bitwise OR of PositionFlags)
         * </pre>
         *
         * <code>uint32 position_flags = 7;</code>
         * @param value The positionFlags to set.
         * @return This builder for chaining.
         */
        public Builder setPositionFlags(int value) {

          positionFlags_ = value;
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Bit field of boolean configuration options for POSITION messages
         * (bitwise OR of PositionFlags)
         * </pre>
         *
         * <code>uint32 position_flags = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearPositionFlags() {
          bitField0_ = (bitField0_ & ~0x00000040);
          positionFlags_ = 0;
          onChanged();
          return this;
        }

        private int rxGpio_ ;
        /**
         * <pre>
         *
         * (Re)define GPS_RX_PIN for your board.
         * </pre>
         *
         * <code>uint32 rx_gpio = 8;</code>
         * @return The rxGpio.
         */
        @java.lang.Override
        public int getRxGpio() {
          return rxGpio_;
        }
        /**
         * <pre>
         *
         * (Re)define GPS_RX_PIN for your board.
         * </pre>
         *
         * <code>uint32 rx_gpio = 8;</code>
         * @param value The rxGpio to set.
         * @return This builder for chaining.
         */
        public Builder setRxGpio(int value) {

          rxGpio_ = value;
          bitField0_ |= 0x00000080;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * (Re)define GPS_RX_PIN for your board.
         * </pre>
         *
         * <code>uint32 rx_gpio = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearRxGpio() {
          bitField0_ = (bitField0_ & ~0x00000080);
          rxGpio_ = 0;
          onChanged();
          return this;
        }

        private int txGpio_ ;
        /**
         * <pre>
         *
         * (Re)define GPS_TX_PIN for your board.
         * </pre>
         *
         * <code>uint32 tx_gpio = 9;</code>
         * @return The txGpio.
         */
        @java.lang.Override
        public int getTxGpio() {
          return txGpio_;
        }
        /**
         * <pre>
         *
         * (Re)define GPS_TX_PIN for your board.
         * </pre>
         *
         * <code>uint32 tx_gpio = 9;</code>
         * @param value The txGpio to set.
         * @return This builder for chaining.
         */
        public Builder setTxGpio(int value) {

          txGpio_ = value;
          bitField0_ |= 0x00000100;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * (Re)define GPS_TX_PIN for your board.
         * </pre>
         *
         * <code>uint32 tx_gpio = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearTxGpio() {
          bitField0_ = (bitField0_ & ~0x00000100);
          txGpio_ = 0;
          onChanged();
          return this;
        }

        private int broadcastSmartMinimumDistance_ ;
        /**
         * <pre>
         *
         * The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
         * </pre>
         *
         * <code>uint32 broadcast_smart_minimum_distance = 10;</code>
         * @return The broadcastSmartMinimumDistance.
         */
        @java.lang.Override
        public int getBroadcastSmartMinimumDistance() {
          return broadcastSmartMinimumDistance_;
        }
        /**
         * <pre>
         *
         * The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
         * </pre>
         *
         * <code>uint32 broadcast_smart_minimum_distance = 10;</code>
         * @param value The broadcastSmartMinimumDistance to set.
         * @return This builder for chaining.
         */
        public Builder setBroadcastSmartMinimumDistance(int value) {

          broadcastSmartMinimumDistance_ = value;
          bitField0_ |= 0x00000200;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
         * </pre>
         *
         * <code>uint32 broadcast_smart_minimum_distance = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearBroadcastSmartMinimumDistance() {
          bitField0_ = (bitField0_ & ~0x00000200);
          broadcastSmartMinimumDistance_ = 0;
          onChanged();
          return this;
        }

        private int broadcastSmartMinimumIntervalSecs_ ;
        /**
         * <pre>
         *
         * The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
         * </pre>
         *
         * <code>uint32 broadcast_smart_minimum_interval_secs = 11;</code>
         * @return The broadcastSmartMinimumIntervalSecs.
         */
        @java.lang.Override
        public int getBroadcastSmartMinimumIntervalSecs() {
          return broadcastSmartMinimumIntervalSecs_;
        }
        /**
         * <pre>
         *
         * The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
         * </pre>
         *
         * <code>uint32 broadcast_smart_minimum_interval_secs = 11;</code>
         * @param value The broadcastSmartMinimumIntervalSecs to set.
         * @return This builder for chaining.
         */
        public Builder setBroadcastSmartMinimumIntervalSecs(int value) {

          broadcastSmartMinimumIntervalSecs_ = value;
          bitField0_ |= 0x00000400;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
         * </pre>
         *
         * <code>uint32 broadcast_smart_minimum_interval_secs = 11;</code>
         * @return This builder for chaining.
         */
        public Builder clearBroadcastSmartMinimumIntervalSecs() {
          bitField0_ = (bitField0_ & ~0x00000400);
          broadcastSmartMinimumIntervalSecs_ = 0;
          onChanged();
          return this;
        }

        private int gpsEnGpio_ ;
        /**
         * <pre>
         *
         * (Re)define PIN_GPS_EN for your board.
         * </pre>
         *
         * <code>uint32 gps_en_gpio = 12;</code>
         * @return The gpsEnGpio.
         */
        @java.lang.Override
        public int getGpsEnGpio() {
          return gpsEnGpio_;
        }
        /**
         * <pre>
         *
         * (Re)define PIN_GPS_EN for your board.
         * </pre>
         *
         * <code>uint32 gps_en_gpio = 12;</code>
         * @param value The gpsEnGpio to set.
         * @return This builder for chaining.
         */
        public Builder setGpsEnGpio(int value) {

          gpsEnGpio_ = value;
          bitField0_ |= 0x00000800;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * (Re)define PIN_GPS_EN for your board.
         * </pre>
         *
         * <code>uint32 gps_en_gpio = 12;</code>
         * @return This builder for chaining.
         */
        public Builder clearGpsEnGpio() {
          bitField0_ = (bitField0_ & ~0x00000800);
          gpsEnGpio_ = 0;
          onChanged();
          return this;
        }

        private int gpsMode_ = 0;
        /**
         * <pre>
         *
         * Set where GPS is enabled, disabled, or not present
         * </pre>
         *
         * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
         * @return The enum numeric value on the wire for gpsMode.
         */
        @java.lang.Override public int getGpsModeValue() {
          return gpsMode_;
        }
        /**
         * <pre>
         *
         * Set where GPS is enabled, disabled, or not present
         * </pre>
         *
         * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
         * @param value The enum numeric value on the wire for gpsMode to set.
         * @return This builder for chaining.
         */
        public Builder setGpsModeValue(int value) {
          gpsMode_ = value;
          bitField0_ |= 0x00001000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Set where GPS is enabled, disabled, or not present
         * </pre>
         *
         * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
         * @return The gpsMode.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode getGpsMode() {
          com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode result = com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode.forNumber(gpsMode_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Set where GPS is enabled, disabled, or not present
         * </pre>
         *
         * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
         * @param value The gpsMode to set.
         * @return This builder for chaining.
         */
        public Builder setGpsMode(com.geeksville.mesh.ConfigProtos.Config.PositionConfig.GpsMode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00001000;
          gpsMode_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Set where GPS is enabled, disabled, or not present
         * </pre>
         *
         * <code>.meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;</code>
         * @return This builder for chaining.
         */
        public Builder clearGpsMode() {
          bitField0_ = (bitField0_ & ~0x00001000);
          gpsMode_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.PositionConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.PositionConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.PositionConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.PositionConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.PositionConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<PositionConfig>
          PARSER = new com.google.protobuf.AbstractParser<PositionConfig>() {
        @java.lang.Override
        public PositionConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<PositionConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<PositionConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.PositionConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface PowerConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.PowerConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       *
       * Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio.
       * Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
       * Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
       * </pre>
       *
       * <code>bool is_power_saving = 1;</code>
       * @return The isPowerSaving.
       */
      boolean getIsPowerSaving();

      /**
       * <pre>
       *
       *  Description: If non-zero, the device will fully power off this many seconds after external power is removed.
       * </pre>
       *
       * <code>uint32 on_battery_shutdown_after_secs = 2;</code>
       * @return The onBatteryShutdownAfterSecs.
       */
      int getOnBatteryShutdownAfterSecs();

      /**
       * <pre>
       *
       * Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
       * Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
       * https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
       * Should be set to floating point value between 2 and 6
       * </pre>
       *
       * <code>float adc_multiplier_override = 3;</code>
       * @return The adcMultiplierOverride.
       */
      float getAdcMultiplierOverride();

      /**
       * <pre>
       *
       *  Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
       *  Technical Details: ESP32 Only 0 for default of 1 minute
       * </pre>
       *
       * <code>uint32 wait_bluetooth_secs = 4;</code>
       * @return The waitBluetoothSecs.
       */
      int getWaitBluetoothSecs();

      /**
       * <pre>
       *
       * Super Deep Sleep Seconds
       * While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
       * for this value (default 1 year) or a button press
       * 0 for default of one year
       * </pre>
       *
       * <code>uint32 sds_secs = 6;</code>
       * @return The sdsSecs.
       */
      int getSdsSecs();

      /**
       * <pre>
       *
       * Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
       * Technical Details: ESP32 Only 0 for default of 300
       * </pre>
       *
       * <code>uint32 ls_secs = 7;</code>
       * @return The lsSecs.
       */
      int getLsSecs();

      /**
       * <pre>
       *
       * Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
       * Technical Details: ESP32 Only 0 for default of 10 seconds
       * </pre>
       *
       * <code>uint32 min_wake_secs = 8;</code>
       * @return The minWakeSecs.
       */
      int getMinWakeSecs();

      /**
       * <pre>
       *
       * I2C address of INA_2XX to use for reading device battery voltage
       * </pre>
       *
       * <code>uint32 device_battery_ina_address = 9;</code>
       * @return The deviceBatteryInaAddress.
       */
      int getDeviceBatteryInaAddress();

      /**
       * <pre>
       *
       * If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
       * Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
       * </pre>
       *
       * <code>uint64 powermon_enables = 32;</code>
       * @return The powermonEnables.
       */
      long getPowermonEnables();
    }
    /**
     * <pre>
     *
     * Power Config&#92;
     * See [Power Config](/docs/settings/config/power) for additional power config details.
     * </pre>
     *
     * Protobuf type {@code meshtastic.Config.PowerConfig}
     */
    public static final class PowerConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.PowerConfig)
        PowerConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use PowerConfig.newBuilder() to construct.
      private PowerConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private PowerConfig() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new PowerConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PowerConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PowerConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.PowerConfig.class, com.geeksville.mesh.ConfigProtos.Config.PowerConfig.Builder.class);
      }

      public static final int IS_POWER_SAVING_FIELD_NUMBER = 1;
      private boolean isPowerSaving_ = false;
      /**
       * <pre>
       *
       * Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio.
       * Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
       * Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
       * </pre>
       *
       * <code>bool is_power_saving = 1;</code>
       * @return The isPowerSaving.
       */
      @java.lang.Override
      public boolean getIsPowerSaving() {
        return isPowerSaving_;
      }

      public static final int ON_BATTERY_SHUTDOWN_AFTER_SECS_FIELD_NUMBER = 2;
      private int onBatteryShutdownAfterSecs_ = 0;
      /**
       * <pre>
       *
       *  Description: If non-zero, the device will fully power off this many seconds after external power is removed.
       * </pre>
       *
       * <code>uint32 on_battery_shutdown_after_secs = 2;</code>
       * @return The onBatteryShutdownAfterSecs.
       */
      @java.lang.Override
      public int getOnBatteryShutdownAfterSecs() {
        return onBatteryShutdownAfterSecs_;
      }

      public static final int ADC_MULTIPLIER_OVERRIDE_FIELD_NUMBER = 3;
      private float adcMultiplierOverride_ = 0F;
      /**
       * <pre>
       *
       * Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
       * Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
       * https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
       * Should be set to floating point value between 2 and 6
       * </pre>
       *
       * <code>float adc_multiplier_override = 3;</code>
       * @return The adcMultiplierOverride.
       */
      @java.lang.Override
      public float getAdcMultiplierOverride() {
        return adcMultiplierOverride_;
      }

      public static final int WAIT_BLUETOOTH_SECS_FIELD_NUMBER = 4;
      private int waitBluetoothSecs_ = 0;
      /**
       * <pre>
       *
       *  Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
       *  Technical Details: ESP32 Only 0 for default of 1 minute
       * </pre>
       *
       * <code>uint32 wait_bluetooth_secs = 4;</code>
       * @return The waitBluetoothSecs.
       */
      @java.lang.Override
      public int getWaitBluetoothSecs() {
        return waitBluetoothSecs_;
      }

      public static final int SDS_SECS_FIELD_NUMBER = 6;
      private int sdsSecs_ = 0;
      /**
       * <pre>
       *
       * Super Deep Sleep Seconds
       * While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
       * for this value (default 1 year) or a button press
       * 0 for default of one year
       * </pre>
       *
       * <code>uint32 sds_secs = 6;</code>
       * @return The sdsSecs.
       */
      @java.lang.Override
      public int getSdsSecs() {
        return sdsSecs_;
      }

      public static final int LS_SECS_FIELD_NUMBER = 7;
      private int lsSecs_ = 0;
      /**
       * <pre>
       *
       * Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
       * Technical Details: ESP32 Only 0 for default of 300
       * </pre>
       *
       * <code>uint32 ls_secs = 7;</code>
       * @return The lsSecs.
       */
      @java.lang.Override
      public int getLsSecs() {
        return lsSecs_;
      }

      public static final int MIN_WAKE_SECS_FIELD_NUMBER = 8;
      private int minWakeSecs_ = 0;
      /**
       * <pre>
       *
       * Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
       * Technical Details: ESP32 Only 0 for default of 10 seconds
       * </pre>
       *
       * <code>uint32 min_wake_secs = 8;</code>
       * @return The minWakeSecs.
       */
      @java.lang.Override
      public int getMinWakeSecs() {
        return minWakeSecs_;
      }

      public static final int DEVICE_BATTERY_INA_ADDRESS_FIELD_NUMBER = 9;
      private int deviceBatteryInaAddress_ = 0;
      /**
       * <pre>
       *
       * I2C address of INA_2XX to use for reading device battery voltage
       * </pre>
       *
       * <code>uint32 device_battery_ina_address = 9;</code>
       * @return The deviceBatteryInaAddress.
       */
      @java.lang.Override
      public int getDeviceBatteryInaAddress() {
        return deviceBatteryInaAddress_;
      }

      public static final int POWERMON_ENABLES_FIELD_NUMBER = 32;
      private long powermonEnables_ = 0L;
      /**
       * <pre>
       *
       * If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
       * Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
       * </pre>
       *
       * <code>uint64 powermon_enables = 32;</code>
       * @return The powermonEnables.
       */
      @java.lang.Override
      public long getPowermonEnables() {
        return powermonEnables_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (isPowerSaving_ != false) {
          output.writeBool(1, isPowerSaving_);
        }
        if (onBatteryShutdownAfterSecs_ != 0) {
          output.writeUInt32(2, onBatteryShutdownAfterSecs_);
        }
        if (java.lang.Float.floatToRawIntBits(adcMultiplierOverride_) != 0) {
          output.writeFloat(3, adcMultiplierOverride_);
        }
        if (waitBluetoothSecs_ != 0) {
          output.writeUInt32(4, waitBluetoothSecs_);
        }
        if (sdsSecs_ != 0) {
          output.writeUInt32(6, sdsSecs_);
        }
        if (lsSecs_ != 0) {
          output.writeUInt32(7, lsSecs_);
        }
        if (minWakeSecs_ != 0) {
          output.writeUInt32(8, minWakeSecs_);
        }
        if (deviceBatteryInaAddress_ != 0) {
          output.writeUInt32(9, deviceBatteryInaAddress_);
        }
        if (powermonEnables_ != 0L) {
          output.writeUInt64(32, powermonEnables_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (isPowerSaving_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, isPowerSaving_);
        }
        if (onBatteryShutdownAfterSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(2, onBatteryShutdownAfterSecs_);
        }
        if (java.lang.Float.floatToRawIntBits(adcMultiplierOverride_) != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(3, adcMultiplierOverride_);
        }
        if (waitBluetoothSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(4, waitBluetoothSecs_);
        }
        if (sdsSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(6, sdsSecs_);
        }
        if (lsSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(7, lsSecs_);
        }
        if (minWakeSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(8, minWakeSecs_);
        }
        if (deviceBatteryInaAddress_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(9, deviceBatteryInaAddress_);
        }
        if (powermonEnables_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(32, powermonEnables_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.PowerConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.PowerConfig other = (com.geeksville.mesh.ConfigProtos.Config.PowerConfig) obj;

        if (getIsPowerSaving()
            != other.getIsPowerSaving()) return false;
        if (getOnBatteryShutdownAfterSecs()
            != other.getOnBatteryShutdownAfterSecs()) return false;
        if (java.lang.Float.floatToIntBits(getAdcMultiplierOverride())
            != java.lang.Float.floatToIntBits(
                other.getAdcMultiplierOverride())) return false;
        if (getWaitBluetoothSecs()
            != other.getWaitBluetoothSecs()) return false;
        if (getSdsSecs()
            != other.getSdsSecs()) return false;
        if (getLsSecs()
            != other.getLsSecs()) return false;
        if (getMinWakeSecs()
            != other.getMinWakeSecs()) return false;
        if (getDeviceBatteryInaAddress()
            != other.getDeviceBatteryInaAddress()) return false;
        if (getPowermonEnables()
            != other.getPowermonEnables()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + IS_POWER_SAVING_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsPowerSaving());
        hash = (37 * hash) + ON_BATTERY_SHUTDOWN_AFTER_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getOnBatteryShutdownAfterSecs();
        hash = (37 * hash) + ADC_MULTIPLIER_OVERRIDE_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getAdcMultiplierOverride());
        hash = (37 * hash) + WAIT_BLUETOOTH_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getWaitBluetoothSecs();
        hash = (37 * hash) + SDS_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getSdsSecs();
        hash = (37 * hash) + LS_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getLsSecs();
        hash = (37 * hash) + MIN_WAKE_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getMinWakeSecs();
        hash = (37 * hash) + DEVICE_BATTERY_INA_ADDRESS_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceBatteryInaAddress();
        hash = (37 * hash) + POWERMON_ENABLES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getPowermonEnables());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.PowerConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       *
       * Power Config&#92;
       * See [Power Config](/docs/settings/config/power) for additional power config details.
       * </pre>
       *
       * Protobuf type {@code meshtastic.Config.PowerConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.PowerConfig)
          com.geeksville.mesh.ConfigProtos.Config.PowerConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PowerConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PowerConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.PowerConfig.class, com.geeksville.mesh.ConfigProtos.Config.PowerConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.PowerConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          isPowerSaving_ = false;
          onBatteryShutdownAfterSecs_ = 0;
          adcMultiplierOverride_ = 0F;
          waitBluetoothSecs_ = 0;
          sdsSecs_ = 0;
          lsSecs_ = 0;
          minWakeSecs_ = 0;
          deviceBatteryInaAddress_ = 0;
          powermonEnables_ = 0L;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_PowerConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.PowerConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.PowerConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.PowerConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.PowerConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.PowerConfig result = new com.geeksville.mesh.ConfigProtos.Config.PowerConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.PowerConfig result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.isPowerSaving_ = isPowerSaving_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.onBatteryShutdownAfterSecs_ = onBatteryShutdownAfterSecs_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.adcMultiplierOverride_ = adcMultiplierOverride_;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.waitBluetoothSecs_ = waitBluetoothSecs_;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.sdsSecs_ = sdsSecs_;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.lsSecs_ = lsSecs_;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.minWakeSecs_ = minWakeSecs_;
          }
          if (((from_bitField0_ & 0x00000080) != 0)) {
            result.deviceBatteryInaAddress_ = deviceBatteryInaAddress_;
          }
          if (((from_bitField0_ & 0x00000100) != 0)) {
            result.powermonEnables_ = powermonEnables_;
          }
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.PowerConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.PowerConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.PowerConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance()) return this;
          if (other.getIsPowerSaving() != false) {
            setIsPowerSaving(other.getIsPowerSaving());
          }
          if (other.getOnBatteryShutdownAfterSecs() != 0) {
            setOnBatteryShutdownAfterSecs(other.getOnBatteryShutdownAfterSecs());
          }
          if (other.getAdcMultiplierOverride() != 0F) {
            setAdcMultiplierOverride(other.getAdcMultiplierOverride());
          }
          if (other.getWaitBluetoothSecs() != 0) {
            setWaitBluetoothSecs(other.getWaitBluetoothSecs());
          }
          if (other.getSdsSecs() != 0) {
            setSdsSecs(other.getSdsSecs());
          }
          if (other.getLsSecs() != 0) {
            setLsSecs(other.getLsSecs());
          }
          if (other.getMinWakeSecs() != 0) {
            setMinWakeSecs(other.getMinWakeSecs());
          }
          if (other.getDeviceBatteryInaAddress() != 0) {
            setDeviceBatteryInaAddress(other.getDeviceBatteryInaAddress());
          }
          if (other.getPowermonEnables() != 0L) {
            setPowermonEnables(other.getPowermonEnables());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  isPowerSaving_ = input.readBool();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  onBatteryShutdownAfterSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 29: {
                  adcMultiplierOverride_ = input.readFloat();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 29
                case 32: {
                  waitBluetoothSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
                case 48: {
                  sdsSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 48
                case 56: {
                  lsSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 56
                case 64: {
                  minWakeSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 64
                case 72: {
                  deviceBatteryInaAddress_ = input.readUInt32();
                  bitField0_ |= 0x00000080;
                  break;
                } // case 72
                case 256: {
                  powermonEnables_ = input.readUInt64();
                  bitField0_ |= 0x00000100;
                  break;
                } // case 256
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private boolean isPowerSaving_ ;
        /**
         * <pre>
         *
         * Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio.
         * Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
         * Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
         * </pre>
         *
         * <code>bool is_power_saving = 1;</code>
         * @return The isPowerSaving.
         */
        @java.lang.Override
        public boolean getIsPowerSaving() {
          return isPowerSaving_;
        }
        /**
         * <pre>
         *
         * Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio.
         * Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
         * Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
         * </pre>
         *
         * <code>bool is_power_saving = 1;</code>
         * @param value The isPowerSaving to set.
         * @return This builder for chaining.
         */
        public Builder setIsPowerSaving(boolean value) {

          isPowerSaving_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio.
         * Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
         * Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
         * </pre>
         *
         * <code>bool is_power_saving = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearIsPowerSaving() {
          bitField0_ = (bitField0_ & ~0x00000001);
          isPowerSaving_ = false;
          onChanged();
          return this;
        }

        private int onBatteryShutdownAfterSecs_ ;
        /**
         * <pre>
         *
         *  Description: If non-zero, the device will fully power off this many seconds after external power is removed.
         * </pre>
         *
         * <code>uint32 on_battery_shutdown_after_secs = 2;</code>
         * @return The onBatteryShutdownAfterSecs.
         */
        @java.lang.Override
        public int getOnBatteryShutdownAfterSecs() {
          return onBatteryShutdownAfterSecs_;
        }
        /**
         * <pre>
         *
         *  Description: If non-zero, the device will fully power off this many seconds after external power is removed.
         * </pre>
         *
         * <code>uint32 on_battery_shutdown_after_secs = 2;</code>
         * @param value The onBatteryShutdownAfterSecs to set.
         * @return This builder for chaining.
         */
        public Builder setOnBatteryShutdownAfterSecs(int value) {

          onBatteryShutdownAfterSecs_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         *  Description: If non-zero, the device will fully power off this many seconds after external power is removed.
         * </pre>
         *
         * <code>uint32 on_battery_shutdown_after_secs = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearOnBatteryShutdownAfterSecs() {
          bitField0_ = (bitField0_ & ~0x00000002);
          onBatteryShutdownAfterSecs_ = 0;
          onChanged();
          return this;
        }

        private float adcMultiplierOverride_ ;
        /**
         * <pre>
         *
         * Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
         * Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
         * https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
         * Should be set to floating point value between 2 and 6
         * </pre>
         *
         * <code>float adc_multiplier_override = 3;</code>
         * @return The adcMultiplierOverride.
         */
        @java.lang.Override
        public float getAdcMultiplierOverride() {
          return adcMultiplierOverride_;
        }
        /**
         * <pre>
         *
         * Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
         * Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
         * https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
         * Should be set to floating point value between 2 and 6
         * </pre>
         *
         * <code>float adc_multiplier_override = 3;</code>
         * @param value The adcMultiplierOverride to set.
         * @return This builder for chaining.
         */
        public Builder setAdcMultiplierOverride(float value) {

          adcMultiplierOverride_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
         * Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
         * https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
         * Should be set to floating point value between 2 and 6
         * </pre>
         *
         * <code>float adc_multiplier_override = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearAdcMultiplierOverride() {
          bitField0_ = (bitField0_ & ~0x00000004);
          adcMultiplierOverride_ = 0F;
          onChanged();
          return this;
        }

        private int waitBluetoothSecs_ ;
        /**
         * <pre>
         *
         *  Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
         *  Technical Details: ESP32 Only 0 for default of 1 minute
         * </pre>
         *
         * <code>uint32 wait_bluetooth_secs = 4;</code>
         * @return The waitBluetoothSecs.
         */
        @java.lang.Override
        public int getWaitBluetoothSecs() {
          return waitBluetoothSecs_;
        }
        /**
         * <pre>
         *
         *  Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
         *  Technical Details: ESP32 Only 0 for default of 1 minute
         * </pre>
         *
         * <code>uint32 wait_bluetooth_secs = 4;</code>
         * @param value The waitBluetoothSecs to set.
         * @return This builder for chaining.
         */
        public Builder setWaitBluetoothSecs(int value) {

          waitBluetoothSecs_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         *  Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
         *  Technical Details: ESP32 Only 0 for default of 1 minute
         * </pre>
         *
         * <code>uint32 wait_bluetooth_secs = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearWaitBluetoothSecs() {
          bitField0_ = (bitField0_ & ~0x00000008);
          waitBluetoothSecs_ = 0;
          onChanged();
          return this;
        }

        private int sdsSecs_ ;
        /**
         * <pre>
         *
         * Super Deep Sleep Seconds
         * While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
         * for this value (default 1 year) or a button press
         * 0 for default of one year
         * </pre>
         *
         * <code>uint32 sds_secs = 6;</code>
         * @return The sdsSecs.
         */
        @java.lang.Override
        public int getSdsSecs() {
          return sdsSecs_;
        }
        /**
         * <pre>
         *
         * Super Deep Sleep Seconds
         * While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
         * for this value (default 1 year) or a button press
         * 0 for default of one year
         * </pre>
         *
         * <code>uint32 sds_secs = 6;</code>
         * @param value The sdsSecs to set.
         * @return This builder for chaining.
         */
        public Builder setSdsSecs(int value) {

          sdsSecs_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Super Deep Sleep Seconds
         * While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
         * for this value (default 1 year) or a button press
         * 0 for default of one year
         * </pre>
         *
         * <code>uint32 sds_secs = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearSdsSecs() {
          bitField0_ = (bitField0_ & ~0x00000010);
          sdsSecs_ = 0;
          onChanged();
          return this;
        }

        private int lsSecs_ ;
        /**
         * <pre>
         *
         * Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
         * Technical Details: ESP32 Only 0 for default of 300
         * </pre>
         *
         * <code>uint32 ls_secs = 7;</code>
         * @return The lsSecs.
         */
        @java.lang.Override
        public int getLsSecs() {
          return lsSecs_;
        }
        /**
         * <pre>
         *
         * Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
         * Technical Details: ESP32 Only 0 for default of 300
         * </pre>
         *
         * <code>uint32 ls_secs = 7;</code>
         * @param value The lsSecs to set.
         * @return This builder for chaining.
         */
        public Builder setLsSecs(int value) {

          lsSecs_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
         * Technical Details: ESP32 Only 0 for default of 300
         * </pre>
         *
         * <code>uint32 ls_secs = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearLsSecs() {
          bitField0_ = (bitField0_ & ~0x00000020);
          lsSecs_ = 0;
          onChanged();
          return this;
        }

        private int minWakeSecs_ ;
        /**
         * <pre>
         *
         * Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
         * Technical Details: ESP32 Only 0 for default of 10 seconds
         * </pre>
         *
         * <code>uint32 min_wake_secs = 8;</code>
         * @return The minWakeSecs.
         */
        @java.lang.Override
        public int getMinWakeSecs() {
          return minWakeSecs_;
        }
        /**
         * <pre>
         *
         * Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
         * Technical Details: ESP32 Only 0 for default of 10 seconds
         * </pre>
         *
         * <code>uint32 min_wake_secs = 8;</code>
         * @param value The minWakeSecs to set.
         * @return This builder for chaining.
         */
        public Builder setMinWakeSecs(int value) {

          minWakeSecs_ = value;
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
         * Technical Details: ESP32 Only 0 for default of 10 seconds
         * </pre>
         *
         * <code>uint32 min_wake_secs = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearMinWakeSecs() {
          bitField0_ = (bitField0_ & ~0x00000040);
          minWakeSecs_ = 0;
          onChanged();
          return this;
        }

        private int deviceBatteryInaAddress_ ;
        /**
         * <pre>
         *
         * I2C address of INA_2XX to use for reading device battery voltage
         * </pre>
         *
         * <code>uint32 device_battery_ina_address = 9;</code>
         * @return The deviceBatteryInaAddress.
         */
        @java.lang.Override
        public int getDeviceBatteryInaAddress() {
          return deviceBatteryInaAddress_;
        }
        /**
         * <pre>
         *
         * I2C address of INA_2XX to use for reading device battery voltage
         * </pre>
         *
         * <code>uint32 device_battery_ina_address = 9;</code>
         * @param value The deviceBatteryInaAddress to set.
         * @return This builder for chaining.
         */
        public Builder setDeviceBatteryInaAddress(int value) {

          deviceBatteryInaAddress_ = value;
          bitField0_ |= 0x00000080;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * I2C address of INA_2XX to use for reading device battery voltage
         * </pre>
         *
         * <code>uint32 device_battery_ina_address = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearDeviceBatteryInaAddress() {
          bitField0_ = (bitField0_ & ~0x00000080);
          deviceBatteryInaAddress_ = 0;
          onChanged();
          return this;
        }

        private long powermonEnables_ ;
        /**
         * <pre>
         *
         * If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
         * Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
         * </pre>
         *
         * <code>uint64 powermon_enables = 32;</code>
         * @return The powermonEnables.
         */
        @java.lang.Override
        public long getPowermonEnables() {
          return powermonEnables_;
        }
        /**
         * <pre>
         *
         * If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
         * Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
         * </pre>
         *
         * <code>uint64 powermon_enables = 32;</code>
         * @param value The powermonEnables to set.
         * @return This builder for chaining.
         */
        public Builder setPowermonEnables(long value) {

          powermonEnables_ = value;
          bitField0_ |= 0x00000100;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
         * Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
         * </pre>
         *
         * <code>uint64 powermon_enables = 32;</code>
         * @return This builder for chaining.
         */
        public Builder clearPowermonEnables() {
          bitField0_ = (bitField0_ & ~0x00000100);
          powermonEnables_ = 0L;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.PowerConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.PowerConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.PowerConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.PowerConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.PowerConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<PowerConfig>
          PARSER = new com.google.protobuf.AbstractParser<PowerConfig>() {
        @java.lang.Override
        public PowerConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<PowerConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<PowerConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.PowerConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface NetworkConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.NetworkConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       *
       * Enable WiFi (disables Bluetooth)
       * </pre>
       *
       * <code>bool wifi_enabled = 1;</code>
       * @return The wifiEnabled.
       */
      boolean getWifiEnabled();

      /**
       * <pre>
       *
       * If set, this node will try to join the specified wifi network and
       * acquire an address via DHCP
       * </pre>
       *
       * <code>string wifi_ssid = 3;</code>
       * @return The wifiSsid.
       */
      java.lang.String getWifiSsid();
      /**
       * <pre>
       *
       * If set, this node will try to join the specified wifi network and
       * acquire an address via DHCP
       * </pre>
       *
       * <code>string wifi_ssid = 3;</code>
       * @return The bytes for wifiSsid.
       */
      com.google.protobuf.ByteString
          getWifiSsidBytes();

      /**
       * <pre>
       *
       * If set, will be use to authenticate to the named wifi
       * </pre>
       *
       * <code>string wifi_psk = 4;</code>
       * @return The wifiPsk.
       */
      java.lang.String getWifiPsk();
      /**
       * <pre>
       *
       * If set, will be use to authenticate to the named wifi
       * </pre>
       *
       * <code>string wifi_psk = 4;</code>
       * @return The bytes for wifiPsk.
       */
      com.google.protobuf.ByteString
          getWifiPskBytes();

      /**
       * <pre>
       *
       * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
       * </pre>
       *
       * <code>string ntp_server = 5;</code>
       * @return The ntpServer.
       */
      java.lang.String getNtpServer();
      /**
       * <pre>
       *
       * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
       * </pre>
       *
       * <code>string ntp_server = 5;</code>
       * @return The bytes for ntpServer.
       */
      com.google.protobuf.ByteString
          getNtpServerBytes();

      /**
       * <pre>
       *
       * Enable Ethernet
       * </pre>
       *
       * <code>bool eth_enabled = 6;</code>
       * @return The ethEnabled.
       */
      boolean getEthEnabled();

      /**
       * <pre>
       *
       * acquire an address via DHCP or assign static
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
       * @return The enum numeric value on the wire for addressMode.
       */
      int getAddressModeValue();
      /**
       * <pre>
       *
       * acquire an address via DHCP or assign static
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
       * @return The addressMode.
       */
      com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode getAddressMode();

      /**
       * <pre>
       *
       * struct to keep static address
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
       * @return Whether the ipv4Config field is set.
       */
      boolean hasIpv4Config();
      /**
       * <pre>
       *
       * struct to keep static address
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
       * @return The ipv4Config.
       */
      com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config getIpv4Config();
      /**
       * <pre>
       *
       * struct to keep static address
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
       */
      com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4ConfigOrBuilder getIpv4ConfigOrBuilder();

      /**
       * <pre>
       *
       * rsyslog Server and Port
       * </pre>
       *
       * <code>string rsyslog_server = 9;</code>
       * @return The rsyslogServer.
       */
      java.lang.String getRsyslogServer();
      /**
       * <pre>
       *
       * rsyslog Server and Port
       * </pre>
       *
       * <code>string rsyslog_server = 9;</code>
       * @return The bytes for rsyslogServer.
       */
      com.google.protobuf.ByteString
          getRsyslogServerBytes();

      /**
       * <pre>
       *
       * Flags for enabling/disabling network protocols
       * </pre>
       *
       * <code>uint32 enabled_protocols = 10;</code>
       * @return The enabledProtocols.
       */
      int getEnabledProtocols();

      /**
       * <pre>
       *
       * Enable/Disable ipv6 support
       * </pre>
       *
       * <code>bool ipv6_enabled = 11;</code>
       * @return The ipv6Enabled.
       */
      boolean getIpv6Enabled();
    }
    /**
     * <pre>
     *
     * Network Config
     * </pre>
     *
     * Protobuf type {@code meshtastic.Config.NetworkConfig}
     */
    public static final class NetworkConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.NetworkConfig)
        NetworkConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use NetworkConfig.newBuilder() to construct.
      private NetworkConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private NetworkConfig() {
        wifiSsid_ = "";
        wifiPsk_ = "";
        ntpServer_ = "";
        addressMode_ = 0;
        rsyslogServer_ = "";
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new NetworkConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.class, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.Builder.class);
      }

      /**
       * Protobuf enum {@code meshtastic.Config.NetworkConfig.AddressMode}
       */
      public enum AddressMode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * obtain ip address via DHCP
         * </pre>
         *
         * <code>DHCP = 0;</code>
         */
        DHCP(0),
        /**
         * <pre>
         *
         * use static ip address
         * </pre>
         *
         * <code>STATIC = 1;</code>
         */
        STATIC(1),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * obtain ip address via DHCP
         * </pre>
         *
         * <code>DHCP = 0;</code>
         */
        public static final int DHCP_VALUE = 0;
        /**
         * <pre>
         *
         * use static ip address
         * </pre>
         *
         * <code>STATIC = 1;</code>
         */
        public static final int STATIC_VALUE = 1;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static AddressMode valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static AddressMode forNumber(int value) {
          switch (value) {
            case 0: return DHCP;
            case 1: return STATIC;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<AddressMode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            AddressMode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<AddressMode>() {
                public AddressMode findValueByNumber(int number) {
                  return AddressMode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDescriptor().getEnumTypes().get(0);
        }

        private static final AddressMode[] VALUES = values();

        public static AddressMode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private AddressMode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.NetworkConfig.AddressMode)
      }

      /**
       * <pre>
       *
       * Available flags auxiliary network protocols
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.NetworkConfig.ProtocolFlags}
       */
      public enum ProtocolFlags
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Do not broadcast packets over any network protocol
         * </pre>
         *
         * <code>NO_BROADCAST = 0;</code>
         */
        NO_BROADCAST(0),
        /**
         * <pre>
         *
         * Enable broadcasting packets via UDP over the local network
         * </pre>
         *
         * <code>UDP_BROADCAST = 1;</code>
         */
        UDP_BROADCAST(1),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Do not broadcast packets over any network protocol
         * </pre>
         *
         * <code>NO_BROADCAST = 0;</code>
         */
        public static final int NO_BROADCAST_VALUE = 0;
        /**
         * <pre>
         *
         * Enable broadcasting packets via UDP over the local network
         * </pre>
         *
         * <code>UDP_BROADCAST = 1;</code>
         */
        public static final int UDP_BROADCAST_VALUE = 1;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static ProtocolFlags valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static ProtocolFlags forNumber(int value) {
          switch (value) {
            case 0: return NO_BROADCAST;
            case 1: return UDP_BROADCAST;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<ProtocolFlags>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            ProtocolFlags> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<ProtocolFlags>() {
                public ProtocolFlags findValueByNumber(int number) {
                  return ProtocolFlags.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDescriptor().getEnumTypes().get(1);
        }

        private static final ProtocolFlags[] VALUES = values();

        public static ProtocolFlags valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private ProtocolFlags(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.NetworkConfig.ProtocolFlags)
      }

      public interface IpV4ConfigOrBuilder extends
          // @@protoc_insertion_point(interface_extends:meshtastic.Config.NetworkConfig.IpV4Config)
          com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         *
         * Static IP address
         * </pre>
         *
         * <code>fixed32 ip = 1;</code>
         * @return The ip.
         */
        int getIp();

        /**
         * <pre>
         *
         * Static gateway address
         * </pre>
         *
         * <code>fixed32 gateway = 2;</code>
         * @return The gateway.
         */
        int getGateway();

        /**
         * <pre>
         *
         * Static subnet mask
         * </pre>
         *
         * <code>fixed32 subnet = 3;</code>
         * @return The subnet.
         */
        int getSubnet();

        /**
         * <pre>
         *
         * Static DNS server address
         * </pre>
         *
         * <code>fixed32 dns = 4;</code>
         * @return The dns.
         */
        int getDns();
      }
      /**
       * Protobuf type {@code meshtastic.Config.NetworkConfig.IpV4Config}
       */
      public static final class IpV4Config extends
          com.google.protobuf.GeneratedMessageV3 implements
          // @@protoc_insertion_point(message_implements:meshtastic.Config.NetworkConfig.IpV4Config)
          IpV4ConfigOrBuilder {
      private static final long serialVersionUID = 0L;
        // Use IpV4Config.newBuilder() to construct.
        private IpV4Config(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
          super(builder);
        }
        private IpV4Config() {
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
          return new IpV4Config();
        }

        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_IpV4Config_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_IpV4Config_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.class, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.Builder.class);
        }

        public static final int IP_FIELD_NUMBER = 1;
        private int ip_ = 0;
        /**
         * <pre>
         *
         * Static IP address
         * </pre>
         *
         * <code>fixed32 ip = 1;</code>
         * @return The ip.
         */
        @java.lang.Override
        public int getIp() {
          return ip_;
        }

        public static final int GATEWAY_FIELD_NUMBER = 2;
        private int gateway_ = 0;
        /**
         * <pre>
         *
         * Static gateway address
         * </pre>
         *
         * <code>fixed32 gateway = 2;</code>
         * @return The gateway.
         */
        @java.lang.Override
        public int getGateway() {
          return gateway_;
        }

        public static final int SUBNET_FIELD_NUMBER = 3;
        private int subnet_ = 0;
        /**
         * <pre>
         *
         * Static subnet mask
         * </pre>
         *
         * <code>fixed32 subnet = 3;</code>
         * @return The subnet.
         */
        @java.lang.Override
        public int getSubnet() {
          return subnet_;
        }

        public static final int DNS_FIELD_NUMBER = 4;
        private int dns_ = 0;
        /**
         * <pre>
         *
         * Static DNS server address
         * </pre>
         *
         * <code>fixed32 dns = 4;</code>
         * @return The dns.
         */
        @java.lang.Override
        public int getDns() {
          return dns_;
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return true;
          if (isInitialized == 0) return false;

          memoizedIsInitialized = 1;
          return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                            throws java.io.IOException {
          if (ip_ != 0) {
            output.writeFixed32(1, ip_);
          }
          if (gateway_ != 0) {
            output.writeFixed32(2, gateway_);
          }
          if (subnet_ != 0) {
            output.writeFixed32(3, subnet_);
          }
          if (dns_ != 0) {
            output.writeFixed32(4, dns_);
          }
          getUnknownFields().writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
          int size = memoizedSize;
          if (size != -1) return size;

          size = 0;
          if (ip_ != 0) {
            size += com.google.protobuf.CodedOutputStream
              .computeFixed32Size(1, ip_);
          }
          if (gateway_ != 0) {
            size += com.google.protobuf.CodedOutputStream
              .computeFixed32Size(2, gateway_);
          }
          if (subnet_ != 0) {
            size += com.google.protobuf.CodedOutputStream
              .computeFixed32Size(3, subnet_);
          }
          if (dns_ != 0) {
            size += com.google.protobuf.CodedOutputStream
              .computeFixed32Size(4, dns_);
          }
          size += getUnknownFields().getSerializedSize();
          memoizedSize = size;
          return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
          if (obj == this) {
           return true;
          }
          if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config)) {
            return super.equals(obj);
          }
          com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config other = (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config) obj;

          if (getIp()
              != other.getIp()) return false;
          if (getGateway()
              != other.getGateway()) return false;
          if (getSubnet()
              != other.getSubnet()) return false;
          if (getDns()
              != other.getDns()) return false;
          if (!getUnknownFields().equals(other.getUnknownFields())) return false;
          return true;
        }

        @java.lang.Override
        public int hashCode() {
          if (memoizedHashCode != 0) {
            return memoizedHashCode;
          }
          int hash = 41;
          hash = (19 * hash) + getDescriptor().hashCode();
          hash = (37 * hash) + IP_FIELD_NUMBER;
          hash = (53 * hash) + getIp();
          hash = (37 * hash) + GATEWAY_FIELD_NUMBER;
          hash = (53 * hash) + getGateway();
          hash = (37 * hash) + SUBNET_FIELD_NUMBER;
          hash = (53 * hash) + getSubnet();
          hash = (37 * hash) + DNS_FIELD_NUMBER;
          hash = (53 * hash) + getDns();
          hash = (29 * hash) + getUnknownFields().hashCode();
          memoizedHashCode = hash;
          return hash;
        }

        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(java.io.InputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
        }

        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input);
        }

        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessageV3
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input);
        }
        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessageV3
              .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
          return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config prototype) {
          return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
          return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          Builder builder = new Builder(parent);
          return builder;
        }
        /**
         * Protobuf type {@code meshtastic.Config.NetworkConfig.IpV4Config}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:meshtastic.Config.NetworkConfig.IpV4Config)
            com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4ConfigOrBuilder {
          public static final com.google.protobuf.Descriptors.Descriptor
              getDescriptor() {
            return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_IpV4Config_descriptor;
          }

          @java.lang.Override
          protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
              internalGetFieldAccessorTable() {
            return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_IpV4Config_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.class, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.Builder.class);
          }

          // Construct using com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.newBuilder()
          private Builder() {

          }

          private Builder(
              com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            super(parent);

          }
          @java.lang.Override
          public Builder clear() {
            super.clear();
            bitField0_ = 0;
            ip_ = 0;
            gateway_ = 0;
            subnet_ = 0;
            dns_ = 0;
            return this;
          }

          @java.lang.Override
          public com.google.protobuf.Descriptors.Descriptor
              getDescriptorForType() {
            return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_IpV4Config_descriptor;
          }

          @java.lang.Override
          public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config getDefaultInstanceForType() {
            return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.getDefaultInstance();
          }

          @java.lang.Override
          public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config build() {
            com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config result = buildPartial();
            if (!result.isInitialized()) {
              throw newUninitializedMessageException(result);
            }
            return result;
          }

          @java.lang.Override
          public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config buildPartial() {
            com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config result = new com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config(this);
            if (bitField0_ != 0) { buildPartial0(result); }
            onBuilt();
            return result;
          }

          private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config result) {
            int from_bitField0_ = bitField0_;
            if (((from_bitField0_ & 0x00000001) != 0)) {
              result.ip_ = ip_;
            }
            if (((from_bitField0_ & 0x00000002) != 0)) {
              result.gateway_ = gateway_;
            }
            if (((from_bitField0_ & 0x00000004) != 0)) {
              result.subnet_ = subnet_;
            }
            if (((from_bitField0_ & 0x00000008) != 0)) {
              result.dns_ = dns_;
            }
          }

          @java.lang.Override
          public Builder clone() {
            return super.clone();
          }
          @java.lang.Override
          public Builder setField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
            return super.setField(field, value);
          }
          @java.lang.Override
          public Builder clearField(
              com.google.protobuf.Descriptors.FieldDescriptor field) {
            return super.clearField(field);
          }
          @java.lang.Override
          public Builder clearOneof(
              com.google.protobuf.Descriptors.OneofDescriptor oneof) {
            return super.clearOneof(oneof);
          }
          @java.lang.Override
          public Builder setRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              int index, java.lang.Object value) {
            return super.setRepeatedField(field, index, value);
          }
          @java.lang.Override
          public Builder addRepeatedField(
              com.google.protobuf.Descriptors.FieldDescriptor field,
              java.lang.Object value) {
            return super.addRepeatedField(field, value);
          }
          @java.lang.Override
          public Builder mergeFrom(com.google.protobuf.Message other) {
            if (other instanceof com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config) {
              return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config)other);
            } else {
              super.mergeFrom(other);
              return this;
            }
          }

          public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config other) {
            if (other == com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.getDefaultInstance()) return this;
            if (other.getIp() != 0) {
              setIp(other.getIp());
            }
            if (other.getGateway() != 0) {
              setGateway(other.getGateway());
            }
            if (other.getSubnet() != 0) {
              setSubnet(other.getSubnet());
            }
            if (other.getDns() != 0) {
              setDns(other.getDns());
            }
            this.mergeUnknownFields(other.getUnknownFields());
            onChanged();
            return this;
          }

          @java.lang.Override
          public final boolean isInitialized() {
            return true;
          }

          @java.lang.Override
          public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
            if (extensionRegistry == null) {
              throw new java.lang.NullPointerException();
            }
            try {
              boolean done = false;
              while (!done) {
                int tag = input.readTag();
                switch (tag) {
                  case 0:
                    done = true;
                    break;
                  case 13: {
                    ip_ = input.readFixed32();
                    bitField0_ |= 0x00000001;
                    break;
                  } // case 13
                  case 21: {
                    gateway_ = input.readFixed32();
                    bitField0_ |= 0x00000002;
                    break;
                  } // case 21
                  case 29: {
                    subnet_ = input.readFixed32();
                    bitField0_ |= 0x00000004;
                    break;
                  } // case 29
                  case 37: {
                    dns_ = input.readFixed32();
                    bitField0_ |= 0x00000008;
                    break;
                  } // case 37
                  default: {
                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                      done = true; // was an endgroup tag
                    }
                    break;
                  } // default:
                } // switch (tag)
              } // while (!done)
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.unwrapIOException();
            } finally {
              onChanged();
            } // finally
            return this;
          }
          private int bitField0_;

          private int ip_ ;
          /**
           * <pre>
           *
           * Static IP address
           * </pre>
           *
           * <code>fixed32 ip = 1;</code>
           * @return The ip.
           */
          @java.lang.Override
          public int getIp() {
            return ip_;
          }
          /**
           * <pre>
           *
           * Static IP address
           * </pre>
           *
           * <code>fixed32 ip = 1;</code>
           * @param value The ip to set.
           * @return This builder for chaining.
           */
          public Builder setIp(int value) {

            ip_ = value;
            bitField0_ |= 0x00000001;
            onChanged();
            return this;
          }
          /**
           * <pre>
           *
           * Static IP address
           * </pre>
           *
           * <code>fixed32 ip = 1;</code>
           * @return This builder for chaining.
           */
          public Builder clearIp() {
            bitField0_ = (bitField0_ & ~0x00000001);
            ip_ = 0;
            onChanged();
            return this;
          }

          private int gateway_ ;
          /**
           * <pre>
           *
           * Static gateway address
           * </pre>
           *
           * <code>fixed32 gateway = 2;</code>
           * @return The gateway.
           */
          @java.lang.Override
          public int getGateway() {
            return gateway_;
          }
          /**
           * <pre>
           *
           * Static gateway address
           * </pre>
           *
           * <code>fixed32 gateway = 2;</code>
           * @param value The gateway to set.
           * @return This builder for chaining.
           */
          public Builder setGateway(int value) {

            gateway_ = value;
            bitField0_ |= 0x00000002;
            onChanged();
            return this;
          }
          /**
           * <pre>
           *
           * Static gateway address
           * </pre>
           *
           * <code>fixed32 gateway = 2;</code>
           * @return This builder for chaining.
           */
          public Builder clearGateway() {
            bitField0_ = (bitField0_ & ~0x00000002);
            gateway_ = 0;
            onChanged();
            return this;
          }

          private int subnet_ ;
          /**
           * <pre>
           *
           * Static subnet mask
           * </pre>
           *
           * <code>fixed32 subnet = 3;</code>
           * @return The subnet.
           */
          @java.lang.Override
          public int getSubnet() {
            return subnet_;
          }
          /**
           * <pre>
           *
           * Static subnet mask
           * </pre>
           *
           * <code>fixed32 subnet = 3;</code>
           * @param value The subnet to set.
           * @return This builder for chaining.
           */
          public Builder setSubnet(int value) {

            subnet_ = value;
            bitField0_ |= 0x00000004;
            onChanged();
            return this;
          }
          /**
           * <pre>
           *
           * Static subnet mask
           * </pre>
           *
           * <code>fixed32 subnet = 3;</code>
           * @return This builder for chaining.
           */
          public Builder clearSubnet() {
            bitField0_ = (bitField0_ & ~0x00000004);
            subnet_ = 0;
            onChanged();
            return this;
          }

          private int dns_ ;
          /**
           * <pre>
           *
           * Static DNS server address
           * </pre>
           *
           * <code>fixed32 dns = 4;</code>
           * @return The dns.
           */
          @java.lang.Override
          public int getDns() {
            return dns_;
          }
          /**
           * <pre>
           *
           * Static DNS server address
           * </pre>
           *
           * <code>fixed32 dns = 4;</code>
           * @param value The dns to set.
           * @return This builder for chaining.
           */
          public Builder setDns(int value) {

            dns_ = value;
            bitField0_ |= 0x00000008;
            onChanged();
            return this;
          }
          /**
           * <pre>
           *
           * Static DNS server address
           * </pre>
           *
           * <code>fixed32 dns = 4;</code>
           * @return This builder for chaining.
           */
          public Builder clearDns() {
            bitField0_ = (bitField0_ & ~0x00000008);
            dns_ = 0;
            onChanged();
            return this;
          }
          @java.lang.Override
          public final Builder setUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
            return super.setUnknownFields(unknownFields);
          }

          @java.lang.Override
          public final Builder mergeUnknownFields(
              final com.google.protobuf.UnknownFieldSet unknownFields) {
            return super.mergeUnknownFields(unknownFields);
          }


          // @@protoc_insertion_point(builder_scope:meshtastic.Config.NetworkConfig.IpV4Config)
        }

        // @@protoc_insertion_point(class_scope:meshtastic.Config.NetworkConfig.IpV4Config)
        private static final com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config DEFAULT_INSTANCE;
        static {
          DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config();
        }

        public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config getDefaultInstance() {
          return DEFAULT_INSTANCE;
        }

        private static final com.google.protobuf.Parser<IpV4Config>
            PARSER = new com.google.protobuf.AbstractParser<IpV4Config>() {
          @java.lang.Override
          public IpV4Config parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

        public static com.google.protobuf.Parser<IpV4Config> parser() {
          return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<IpV4Config> getParserForType() {
          return PARSER;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config getDefaultInstanceForType() {
          return DEFAULT_INSTANCE;
        }

      }

      private int bitField0_;
      public static final int WIFI_ENABLED_FIELD_NUMBER = 1;
      private boolean wifiEnabled_ = false;
      /**
       * <pre>
       *
       * Enable WiFi (disables Bluetooth)
       * </pre>
       *
       * <code>bool wifi_enabled = 1;</code>
       * @return The wifiEnabled.
       */
      @java.lang.Override
      public boolean getWifiEnabled() {
        return wifiEnabled_;
      }

      public static final int WIFI_SSID_FIELD_NUMBER = 3;
      @SuppressWarnings("serial")
      private volatile java.lang.Object wifiSsid_ = "";
      /**
       * <pre>
       *
       * If set, this node will try to join the specified wifi network and
       * acquire an address via DHCP
       * </pre>
       *
       * <code>string wifi_ssid = 3;</code>
       * @return The wifiSsid.
       */
      @java.lang.Override
      public java.lang.String getWifiSsid() {
        java.lang.Object ref = wifiSsid_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          wifiSsid_ = s;
          return s;
        }
      }
      /**
       * <pre>
       *
       * If set, this node will try to join the specified wifi network and
       * acquire an address via DHCP
       * </pre>
       *
       * <code>string wifi_ssid = 3;</code>
       * @return The bytes for wifiSsid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getWifiSsidBytes() {
        java.lang.Object ref = wifiSsid_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          wifiSsid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int WIFI_PSK_FIELD_NUMBER = 4;
      @SuppressWarnings("serial")
      private volatile java.lang.Object wifiPsk_ = "";
      /**
       * <pre>
       *
       * If set, will be use to authenticate to the named wifi
       * </pre>
       *
       * <code>string wifi_psk = 4;</code>
       * @return The wifiPsk.
       */
      @java.lang.Override
      public java.lang.String getWifiPsk() {
        java.lang.Object ref = wifiPsk_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          wifiPsk_ = s;
          return s;
        }
      }
      /**
       * <pre>
       *
       * If set, will be use to authenticate to the named wifi
       * </pre>
       *
       * <code>string wifi_psk = 4;</code>
       * @return The bytes for wifiPsk.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getWifiPskBytes() {
        java.lang.Object ref = wifiPsk_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          wifiPsk_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int NTP_SERVER_FIELD_NUMBER = 5;
      @SuppressWarnings("serial")
      private volatile java.lang.Object ntpServer_ = "";
      /**
       * <pre>
       *
       * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
       * </pre>
       *
       * <code>string ntp_server = 5;</code>
       * @return The ntpServer.
       */
      @java.lang.Override
      public java.lang.String getNtpServer() {
        java.lang.Object ref = ntpServer_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          ntpServer_ = s;
          return s;
        }
      }
      /**
       * <pre>
       *
       * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
       * </pre>
       *
       * <code>string ntp_server = 5;</code>
       * @return The bytes for ntpServer.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNtpServerBytes() {
        java.lang.Object ref = ntpServer_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          ntpServer_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int ETH_ENABLED_FIELD_NUMBER = 6;
      private boolean ethEnabled_ = false;
      /**
       * <pre>
       *
       * Enable Ethernet
       * </pre>
       *
       * <code>bool eth_enabled = 6;</code>
       * @return The ethEnabled.
       */
      @java.lang.Override
      public boolean getEthEnabled() {
        return ethEnabled_;
      }

      public static final int ADDRESS_MODE_FIELD_NUMBER = 7;
      private int addressMode_ = 0;
      /**
       * <pre>
       *
       * acquire an address via DHCP or assign static
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
       * @return The enum numeric value on the wire for addressMode.
       */
      @java.lang.Override public int getAddressModeValue() {
        return addressMode_;
      }
      /**
       * <pre>
       *
       * acquire an address via DHCP or assign static
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
       * @return The addressMode.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode getAddressMode() {
        com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode result = com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode.forNumber(addressMode_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode.UNRECOGNIZED : result;
      }

      public static final int IPV4_CONFIG_FIELD_NUMBER = 8;
      private com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config ipv4Config_;
      /**
       * <pre>
       *
       * struct to keep static address
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
       * @return Whether the ipv4Config field is set.
       */
      @java.lang.Override
      public boolean hasIpv4Config() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       *
       * struct to keep static address
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
       * @return The ipv4Config.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config getIpv4Config() {
        return ipv4Config_ == null ? com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.getDefaultInstance() : ipv4Config_;
      }
      /**
       * <pre>
       *
       * struct to keep static address
       * </pre>
       *
       * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4ConfigOrBuilder getIpv4ConfigOrBuilder() {
        return ipv4Config_ == null ? com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.getDefaultInstance() : ipv4Config_;
      }

      public static final int RSYSLOG_SERVER_FIELD_NUMBER = 9;
      @SuppressWarnings("serial")
      private volatile java.lang.Object rsyslogServer_ = "";
      /**
       * <pre>
       *
       * rsyslog Server and Port
       * </pre>
       *
       * <code>string rsyslog_server = 9;</code>
       * @return The rsyslogServer.
       */
      @java.lang.Override
      public java.lang.String getRsyslogServer() {
        java.lang.Object ref = rsyslogServer_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          rsyslogServer_ = s;
          return s;
        }
      }
      /**
       * <pre>
       *
       * rsyslog Server and Port
       * </pre>
       *
       * <code>string rsyslog_server = 9;</code>
       * @return The bytes for rsyslogServer.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRsyslogServerBytes() {
        java.lang.Object ref = rsyslogServer_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          rsyslogServer_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int ENABLED_PROTOCOLS_FIELD_NUMBER = 10;
      private int enabledProtocols_ = 0;
      /**
       * <pre>
       *
       * Flags for enabling/disabling network protocols
       * </pre>
       *
       * <code>uint32 enabled_protocols = 10;</code>
       * @return The enabledProtocols.
       */
      @java.lang.Override
      public int getEnabledProtocols() {
        return enabledProtocols_;
      }

      public static final int IPV6_ENABLED_FIELD_NUMBER = 11;
      private boolean ipv6Enabled_ = false;
      /**
       * <pre>
       *
       * Enable/Disable ipv6 support
       * </pre>
       *
       * <code>bool ipv6_enabled = 11;</code>
       * @return The ipv6Enabled.
       */
      @java.lang.Override
      public boolean getIpv6Enabled() {
        return ipv6Enabled_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (wifiEnabled_ != false) {
          output.writeBool(1, wifiEnabled_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(wifiSsid_)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 3, wifiSsid_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(wifiPsk_)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 4, wifiPsk_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(ntpServer_)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 5, ntpServer_);
        }
        if (ethEnabled_ != false) {
          output.writeBool(6, ethEnabled_);
        }
        if (addressMode_ != com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode.DHCP.getNumber()) {
          output.writeEnum(7, addressMode_);
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeMessage(8, getIpv4Config());
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(rsyslogServer_)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 9, rsyslogServer_);
        }
        if (enabledProtocols_ != 0) {
          output.writeUInt32(10, enabledProtocols_);
        }
        if (ipv6Enabled_ != false) {
          output.writeBool(11, ipv6Enabled_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (wifiEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, wifiEnabled_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(wifiSsid_)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, wifiSsid_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(wifiPsk_)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, wifiPsk_);
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(ntpServer_)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, ntpServer_);
        }
        if (ethEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(6, ethEnabled_);
        }
        if (addressMode_ != com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode.DHCP.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(7, addressMode_);
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(8, getIpv4Config());
        }
        if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(rsyslogServer_)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, rsyslogServer_);
        }
        if (enabledProtocols_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(10, enabledProtocols_);
        }
        if (ipv6Enabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(11, ipv6Enabled_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.NetworkConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.NetworkConfig other = (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) obj;

        if (getWifiEnabled()
            != other.getWifiEnabled()) return false;
        if (!getWifiSsid()
            .equals(other.getWifiSsid())) return false;
        if (!getWifiPsk()
            .equals(other.getWifiPsk())) return false;
        if (!getNtpServer()
            .equals(other.getNtpServer())) return false;
        if (getEthEnabled()
            != other.getEthEnabled()) return false;
        if (addressMode_ != other.addressMode_) return false;
        if (hasIpv4Config() != other.hasIpv4Config()) return false;
        if (hasIpv4Config()) {
          if (!getIpv4Config()
              .equals(other.getIpv4Config())) return false;
        }
        if (!getRsyslogServer()
            .equals(other.getRsyslogServer())) return false;
        if (getEnabledProtocols()
            != other.getEnabledProtocols()) return false;
        if (getIpv6Enabled()
            != other.getIpv6Enabled()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + WIFI_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getWifiEnabled());
        hash = (37 * hash) + WIFI_SSID_FIELD_NUMBER;
        hash = (53 * hash) + getWifiSsid().hashCode();
        hash = (37 * hash) + WIFI_PSK_FIELD_NUMBER;
        hash = (53 * hash) + getWifiPsk().hashCode();
        hash = (37 * hash) + NTP_SERVER_FIELD_NUMBER;
        hash = (53 * hash) + getNtpServer().hashCode();
        hash = (37 * hash) + ETH_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEthEnabled());
        hash = (37 * hash) + ADDRESS_MODE_FIELD_NUMBER;
        hash = (53 * hash) + addressMode_;
        if (hasIpv4Config()) {
          hash = (37 * hash) + IPV4_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getIpv4Config().hashCode();
        }
        hash = (37 * hash) + RSYSLOG_SERVER_FIELD_NUMBER;
        hash = (53 * hash) + getRsyslogServer().hashCode();
        hash = (37 * hash) + ENABLED_PROTOCOLS_FIELD_NUMBER;
        hash = (53 * hash) + getEnabledProtocols();
        hash = (37 * hash) + IPV6_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIpv6Enabled());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       *
       * Network Config
       * </pre>
       *
       * Protobuf type {@code meshtastic.Config.NetworkConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.NetworkConfig)
          com.geeksville.mesh.ConfigProtos.Config.NetworkConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.class, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getIpv4ConfigFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          wifiEnabled_ = false;
          wifiSsid_ = "";
          wifiPsk_ = "";
          ntpServer_ = "";
          ethEnabled_ = false;
          addressMode_ = 0;
          ipv4Config_ = null;
          if (ipv4ConfigBuilder_ != null) {
            ipv4ConfigBuilder_.dispose();
            ipv4ConfigBuilder_ = null;
          }
          rsyslogServer_ = "";
          enabledProtocols_ = 0;
          ipv6Enabled_ = false;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_NetworkConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.NetworkConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.NetworkConfig result = new com.geeksville.mesh.ConfigProtos.Config.NetworkConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.wifiEnabled_ = wifiEnabled_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.wifiSsid_ = wifiSsid_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.wifiPsk_ = wifiPsk_;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.ntpServer_ = ntpServer_;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.ethEnabled_ = ethEnabled_;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.addressMode_ = addressMode_;
          }
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.ipv4Config_ = ipv4ConfigBuilder_ == null
                ? ipv4Config_
                : ipv4ConfigBuilder_.build();
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000080) != 0)) {
            result.rsyslogServer_ = rsyslogServer_;
          }
          if (((from_bitField0_ & 0x00000100) != 0)) {
            result.enabledProtocols_ = enabledProtocols_;
          }
          if (((from_bitField0_ & 0x00000200) != 0)) {
            result.ipv6Enabled_ = ipv6Enabled_;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.NetworkConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance()) return this;
          if (other.getWifiEnabled() != false) {
            setWifiEnabled(other.getWifiEnabled());
          }
          if (!other.getWifiSsid().isEmpty()) {
            wifiSsid_ = other.wifiSsid_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          if (!other.getWifiPsk().isEmpty()) {
            wifiPsk_ = other.wifiPsk_;
            bitField0_ |= 0x00000004;
            onChanged();
          }
          if (!other.getNtpServer().isEmpty()) {
            ntpServer_ = other.ntpServer_;
            bitField0_ |= 0x00000008;
            onChanged();
          }
          if (other.getEthEnabled() != false) {
            setEthEnabled(other.getEthEnabled());
          }
          if (other.addressMode_ != 0) {
            setAddressModeValue(other.getAddressModeValue());
          }
          if (other.hasIpv4Config()) {
            mergeIpv4Config(other.getIpv4Config());
          }
          if (!other.getRsyslogServer().isEmpty()) {
            rsyslogServer_ = other.rsyslogServer_;
            bitField0_ |= 0x00000080;
            onChanged();
          }
          if (other.getEnabledProtocols() != 0) {
            setEnabledProtocols(other.getEnabledProtocols());
          }
          if (other.getIpv6Enabled() != false) {
            setIpv6Enabled(other.getIpv6Enabled());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  wifiEnabled_ = input.readBool();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 26: {
                  wifiSsid_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 26
                case 34: {
                  wifiPsk_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 34
                case 42: {
                  ntpServer_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 42
                case 48: {
                  ethEnabled_ = input.readBool();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 48
                case 56: {
                  addressMode_ = input.readEnum();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 56
                case 66: {
                  input.readMessage(
                      getIpv4ConfigFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000040;
                  break;
                } // case 66
                case 74: {
                  rsyslogServer_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000080;
                  break;
                } // case 74
                case 80: {
                  enabledProtocols_ = input.readUInt32();
                  bitField0_ |= 0x00000100;
                  break;
                } // case 80
                case 88: {
                  ipv6Enabled_ = input.readBool();
                  bitField0_ |= 0x00000200;
                  break;
                } // case 88
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private boolean wifiEnabled_ ;
        /**
         * <pre>
         *
         * Enable WiFi (disables Bluetooth)
         * </pre>
         *
         * <code>bool wifi_enabled = 1;</code>
         * @return The wifiEnabled.
         */
        @java.lang.Override
        public boolean getWifiEnabled() {
          return wifiEnabled_;
        }
        /**
         * <pre>
         *
         * Enable WiFi (disables Bluetooth)
         * </pre>
         *
         * <code>bool wifi_enabled = 1;</code>
         * @param value The wifiEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setWifiEnabled(boolean value) {

          wifiEnabled_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Enable WiFi (disables Bluetooth)
         * </pre>
         *
         * <code>bool wifi_enabled = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearWifiEnabled() {
          bitField0_ = (bitField0_ & ~0x00000001);
          wifiEnabled_ = false;
          onChanged();
          return this;
        }

        private java.lang.Object wifiSsid_ = "";
        /**
         * <pre>
         *
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 3;</code>
         * @return The wifiSsid.
         */
        public java.lang.String getWifiSsid() {
          java.lang.Object ref = wifiSsid_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            wifiSsid_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         *
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 3;</code>
         * @return The bytes for wifiSsid.
         */
        public com.google.protobuf.ByteString
            getWifiSsidBytes() {
          java.lang.Object ref = wifiSsid_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            wifiSsid_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         *
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 3;</code>
         * @param value The wifiSsid to set.
         * @return This builder for chaining.
         */
        public Builder setWifiSsid(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          wifiSsid_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearWifiSsid() {
          wifiSsid_ = getDefaultInstance().getWifiSsid();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 3;</code>
         * @param value The bytes for wifiSsid to set.
         * @return This builder for chaining.
         */
        public Builder setWifiSsidBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          checkByteStringIsUtf8(value);
          wifiSsid_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        private java.lang.Object wifiPsk_ = "";
        /**
         * <pre>
         *
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_psk = 4;</code>
         * @return The wifiPsk.
         */
        public java.lang.String getWifiPsk() {
          java.lang.Object ref = wifiPsk_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            wifiPsk_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         *
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_psk = 4;</code>
         * @return The bytes for wifiPsk.
         */
        public com.google.protobuf.ByteString
            getWifiPskBytes() {
          java.lang.Object ref = wifiPsk_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            wifiPsk_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         *
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_psk = 4;</code>
         * @param value The wifiPsk to set.
         * @return This builder for chaining.
         */
        public Builder setWifiPsk(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          wifiPsk_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_psk = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearWifiPsk() {
          wifiPsk_ = getDefaultInstance().getWifiPsk();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_psk = 4;</code>
         * @param value The bytes for wifiPsk to set.
         * @return This builder for chaining.
         */
        public Builder setWifiPskBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          checkByteStringIsUtf8(value);
          wifiPsk_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }

        private java.lang.Object ntpServer_ = "";
        /**
         * <pre>
         *
         * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
         * </pre>
         *
         * <code>string ntp_server = 5;</code>
         * @return The ntpServer.
         */
        public java.lang.String getNtpServer() {
          java.lang.Object ref = ntpServer_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            ntpServer_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         *
         * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
         * </pre>
         *
         * <code>string ntp_server = 5;</code>
         * @return The bytes for ntpServer.
         */
        public com.google.protobuf.ByteString
            getNtpServerBytes() {
          java.lang.Object ref = ntpServer_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            ntpServer_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         *
         * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
         * </pre>
         *
         * <code>string ntp_server = 5;</code>
         * @param value The ntpServer to set.
         * @return This builder for chaining.
         */
        public Builder setNtpServer(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          ntpServer_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
         * </pre>
         *
         * <code>string ntp_server = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearNtpServer() {
          ntpServer_ = getDefaultInstance().getNtpServer();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
         * </pre>
         *
         * <code>string ntp_server = 5;</code>
         * @param value The bytes for ntpServer to set.
         * @return This builder for chaining.
         */
        public Builder setNtpServerBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          checkByteStringIsUtf8(value);
          ntpServer_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }

        private boolean ethEnabled_ ;
        /**
         * <pre>
         *
         * Enable Ethernet
         * </pre>
         *
         * <code>bool eth_enabled = 6;</code>
         * @return The ethEnabled.
         */
        @java.lang.Override
        public boolean getEthEnabled() {
          return ethEnabled_;
        }
        /**
         * <pre>
         *
         * Enable Ethernet
         * </pre>
         *
         * <code>bool eth_enabled = 6;</code>
         * @param value The ethEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setEthEnabled(boolean value) {

          ethEnabled_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Enable Ethernet
         * </pre>
         *
         * <code>bool eth_enabled = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearEthEnabled() {
          bitField0_ = (bitField0_ & ~0x00000010);
          ethEnabled_ = false;
          onChanged();
          return this;
        }

        private int addressMode_ = 0;
        /**
         * <pre>
         *
         * acquire an address via DHCP or assign static
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
         * @return The enum numeric value on the wire for addressMode.
         */
        @java.lang.Override public int getAddressModeValue() {
          return addressMode_;
        }
        /**
         * <pre>
         *
         * acquire an address via DHCP or assign static
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
         * @param value The enum numeric value on the wire for addressMode to set.
         * @return This builder for chaining.
         */
        public Builder setAddressModeValue(int value) {
          addressMode_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * acquire an address via DHCP or assign static
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
         * @return The addressMode.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode getAddressMode() {
          com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode result = com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode.forNumber(addressMode_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * acquire an address via DHCP or assign static
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
         * @param value The addressMode to set.
         * @return This builder for chaining.
         */
        public Builder setAddressMode(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.AddressMode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000020;
          addressMode_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * acquire an address via DHCP or assign static
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearAddressMode() {
          bitField0_ = (bitField0_ & ~0x00000020);
          addressMode_ = 0;
          onChanged();
          return this;
        }

        private com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config ipv4Config_;
        private com.google.protobuf.SingleFieldBuilderV3<
            com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.Builder, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4ConfigOrBuilder> ipv4ConfigBuilder_;
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         * @return Whether the ipv4Config field is set.
         */
        public boolean hasIpv4Config() {
          return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         * @return The ipv4Config.
         */
        public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config getIpv4Config() {
          if (ipv4ConfigBuilder_ == null) {
            return ipv4Config_ == null ? com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.getDefaultInstance() : ipv4Config_;
          } else {
            return ipv4ConfigBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         */
        public Builder setIpv4Config(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config value) {
          if (ipv4ConfigBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ipv4Config_ = value;
          } else {
            ipv4ConfigBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         */
        public Builder setIpv4Config(
            com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.Builder builderForValue) {
          if (ipv4ConfigBuilder_ == null) {
            ipv4Config_ = builderForValue.build();
          } else {
            ipv4ConfigBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         */
        public Builder mergeIpv4Config(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config value) {
          if (ipv4ConfigBuilder_ == null) {
            if (((bitField0_ & 0x00000040) != 0) &&
              ipv4Config_ != null &&
              ipv4Config_ != com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.getDefaultInstance()) {
              getIpv4ConfigBuilder().mergeFrom(value);
            } else {
              ipv4Config_ = value;
            }
          } else {
            ipv4ConfigBuilder_.mergeFrom(value);
          }
          if (ipv4Config_ != null) {
            bitField0_ |= 0x00000040;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         */
        public Builder clearIpv4Config() {
          bitField0_ = (bitField0_ & ~0x00000040);
          ipv4Config_ = null;
          if (ipv4ConfigBuilder_ != null) {
            ipv4ConfigBuilder_.dispose();
            ipv4ConfigBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         */
        public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.Builder getIpv4ConfigBuilder() {
          bitField0_ |= 0x00000040;
          onChanged();
          return getIpv4ConfigFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         */
        public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4ConfigOrBuilder getIpv4ConfigOrBuilder() {
          if (ipv4ConfigBuilder_ != null) {
            return ipv4ConfigBuilder_.getMessageOrBuilder();
          } else {
            return ipv4Config_ == null ?
                com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.getDefaultInstance() : ipv4Config_;
          }
        }
        /**
         * <pre>
         *
         * struct to keep static address
         * </pre>
         *
         * <code>.meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.Builder, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4ConfigOrBuilder> 
            getIpv4ConfigFieldBuilder() {
          if (ipv4ConfigBuilder_ == null) {
            ipv4ConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4Config.Builder, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.IpV4ConfigOrBuilder>(
                    getIpv4Config(),
                    getParentForChildren(),
                    isClean());
            ipv4Config_ = null;
          }
          return ipv4ConfigBuilder_;
        }

        private java.lang.Object rsyslogServer_ = "";
        /**
         * <pre>
         *
         * rsyslog Server and Port
         * </pre>
         *
         * <code>string rsyslog_server = 9;</code>
         * @return The rsyslogServer.
         */
        public java.lang.String getRsyslogServer() {
          java.lang.Object ref = rsyslogServer_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            rsyslogServer_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         *
         * rsyslog Server and Port
         * </pre>
         *
         * <code>string rsyslog_server = 9;</code>
         * @return The bytes for rsyslogServer.
         */
        public com.google.protobuf.ByteString
            getRsyslogServerBytes() {
          java.lang.Object ref = rsyslogServer_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            rsyslogServer_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         *
         * rsyslog Server and Port
         * </pre>
         *
         * <code>string rsyslog_server = 9;</code>
         * @param value The rsyslogServer to set.
         * @return This builder for chaining.
         */
        public Builder setRsyslogServer(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          rsyslogServer_ = value;
          bitField0_ |= 0x00000080;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * rsyslog Server and Port
         * </pre>
         *
         * <code>string rsyslog_server = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearRsyslogServer() {
          rsyslogServer_ = getDefaultInstance().getRsyslogServer();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * rsyslog Server and Port
         * </pre>
         *
         * <code>string rsyslog_server = 9;</code>
         * @param value The bytes for rsyslogServer to set.
         * @return This builder for chaining.
         */
        public Builder setRsyslogServerBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          checkByteStringIsUtf8(value);
          rsyslogServer_ = value;
          bitField0_ |= 0x00000080;
          onChanged();
          return this;
        }

        private int enabledProtocols_ ;
        /**
         * <pre>
         *
         * Flags for enabling/disabling network protocols
         * </pre>
         *
         * <code>uint32 enabled_protocols = 10;</code>
         * @return The enabledProtocols.
         */
        @java.lang.Override
        public int getEnabledProtocols() {
          return enabledProtocols_;
        }
        /**
         * <pre>
         *
         * Flags for enabling/disabling network protocols
         * </pre>
         *
         * <code>uint32 enabled_protocols = 10;</code>
         * @param value The enabledProtocols to set.
         * @return This builder for chaining.
         */
        public Builder setEnabledProtocols(int value) {

          enabledProtocols_ = value;
          bitField0_ |= 0x00000100;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Flags for enabling/disabling network protocols
         * </pre>
         *
         * <code>uint32 enabled_protocols = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnabledProtocols() {
          bitField0_ = (bitField0_ & ~0x00000100);
          enabledProtocols_ = 0;
          onChanged();
          return this;
        }

        private boolean ipv6Enabled_ ;
        /**
         * <pre>
         *
         * Enable/Disable ipv6 support
         * </pre>
         *
         * <code>bool ipv6_enabled = 11;</code>
         * @return The ipv6Enabled.
         */
        @java.lang.Override
        public boolean getIpv6Enabled() {
          return ipv6Enabled_;
        }
        /**
         * <pre>
         *
         * Enable/Disable ipv6 support
         * </pre>
         *
         * <code>bool ipv6_enabled = 11;</code>
         * @param value The ipv6Enabled to set.
         * @return This builder for chaining.
         */
        public Builder setIpv6Enabled(boolean value) {

          ipv6Enabled_ = value;
          bitField0_ |= 0x00000200;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Enable/Disable ipv6 support
         * </pre>
         *
         * <code>bool ipv6_enabled = 11;</code>
         * @return This builder for chaining.
         */
        public Builder clearIpv6Enabled() {
          bitField0_ = (bitField0_ & ~0x00000200);
          ipv6Enabled_ = false;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.NetworkConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.NetworkConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.NetworkConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.NetworkConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.NetworkConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<NetworkConfig>
          PARSER = new com.google.protobuf.AbstractParser<NetworkConfig>() {
        @java.lang.Override
        public NetworkConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<NetworkConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<NetworkConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface DisplayConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.DisplayConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       *
       * Number of seconds the screen stays on after pressing the user button or receiving a message
       * 0 for default of one minute MAXUINT for always on
       * </pre>
       *
       * <code>uint32 screen_on_secs = 1;</code>
       * @return The screenOnSecs.
       */
      int getScreenOnSecs();

      /**
       * <pre>
       *
       * Deprecated in 2.7.4: Unused
       * How the GPS coordinates are formatted on the OLED screen.
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
       *     See meshtastic/config.proto;l=662
       * @return The enum numeric value on the wire for gpsFormat.
       */
      @java.lang.Deprecated int getGpsFormatValue();
      /**
       * <pre>
       *
       * Deprecated in 2.7.4: Unused
       * How the GPS coordinates are formatted on the OLED screen.
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
       *     See meshtastic/config.proto;l=662
       * @return The gpsFormat.
       */
      @java.lang.Deprecated com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat getGpsFormat();

      /**
       * <pre>
       *
       * Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
       * Potentially useful for devices without user buttons.
       * </pre>
       *
       * <code>uint32 auto_screen_carousel_secs = 3;</code>
       * @return The autoScreenCarouselSecs.
       */
      int getAutoScreenCarouselSecs();

      /**
       * <pre>
       *
       * If this is set, the displayed compass will always point north. if unset, the old behaviour
       * (top of display is heading direction) is used.
       * </pre>
       *
       * <code>bool compass_north_top = 4 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DisplayConfig.compass_north_top is deprecated.
       *     See meshtastic/config.proto;l=674
       * @return The compassNorthTop.
       */
      @java.lang.Deprecated boolean getCompassNorthTop();

      /**
       * <pre>
       *
       * Flip screen vertically, for cases that mount the screen upside down
       * </pre>
       *
       * <code>bool flip_screen = 5;</code>
       * @return The flipScreen.
       */
      boolean getFlipScreen();

      /**
       * <pre>
       *
       * Perferred display units
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
       * @return The enum numeric value on the wire for units.
       */
      int getUnitsValue();
      /**
       * <pre>
       *
       * Perferred display units
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
       * @return The units.
       */
      com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits getUnits();

      /**
       * <pre>
       *
       * Override auto-detect in screen
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
       * @return The enum numeric value on the wire for oled.
       */
      int getOledValue();
      /**
       * <pre>
       *
       * Override auto-detect in screen
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
       * @return The oled.
       */
      com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType getOled();

      /**
       * <pre>
       *
       * Display Mode
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
       * @return The enum numeric value on the wire for displaymode.
       */
      int getDisplaymodeValue();
      /**
       * <pre>
       *
       * Display Mode
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
       * @return The displaymode.
       */
      com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode getDisplaymode();

      /**
       * <pre>
       *
       * Print first line in pseudo-bold? FALSE is original style, TRUE is bold
       * </pre>
       *
       * <code>bool heading_bold = 9;</code>
       * @return The headingBold.
       */
      boolean getHeadingBold();

      /**
       * <pre>
       *
       * Should we wake the screen up on accelerometer detected motion or tap
       * </pre>
       *
       * <code>bool wake_on_tap_or_motion = 10;</code>
       * @return The wakeOnTapOrMotion.
       */
      boolean getWakeOnTapOrMotion();

      /**
       * <pre>
       *
       * Indicates how to rotate or invert the compass output to accurate display on the display.
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
       * @return The enum numeric value on the wire for compassOrientation.
       */
      int getCompassOrientationValue();
      /**
       * <pre>
       *
       * Indicates how to rotate or invert the compass output to accurate display on the display.
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
       * @return The compassOrientation.
       */
      com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation getCompassOrientation();

      /**
       * <pre>
       *
       * If false (default), the device will display the time in 24-hour format on screen.
       * If true, the device will display the time in 12-hour format on screen.
       * </pre>
       *
       * <code>bool use_12h_clock = 12;</code>
       * @return The use12hClock.
       */
      boolean getUse12HClock();

      /**
       * <pre>
       *
       * If false (default), the device will use short names for various display screens.
       * If true, node names will show in long format
       * </pre>
       *
       * <code>bool use_long_node_name = 13;</code>
       * @return The useLongNodeName.
       */
      boolean getUseLongNodeName();
    }
    /**
     * <pre>
     *
     * Display Config
     * </pre>
     *
     * Protobuf type {@code meshtastic.Config.DisplayConfig}
     */
    public static final class DisplayConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.DisplayConfig)
        DisplayConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use DisplayConfig.newBuilder() to construct.
      private DisplayConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private DisplayConfig() {
        gpsFormat_ = 0;
        units_ = 0;
        oled_ = 0;
        displaymode_ = 0;
        compassOrientation_ = 0;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new DisplayConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DisplayConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DisplayConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.class, com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.Builder.class);
      }

      /**
       * <pre>
       *
       * Deprecated in 2.7.4: Unused
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat}
       */
      public enum DeprecatedGpsCoordinateFormat
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNUSED = 0;</code>
         */
        UNUSED(0),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNUSED = 0;</code>
         */
        public static final int UNUSED_VALUE = 0;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static DeprecatedGpsCoordinateFormat valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static DeprecatedGpsCoordinateFormat forNumber(int value) {
          switch (value) {
            case 0: return UNUSED;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<DeprecatedGpsCoordinateFormat>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            DeprecatedGpsCoordinateFormat> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<DeprecatedGpsCoordinateFormat>() {
                public DeprecatedGpsCoordinateFormat findValueByNumber(int number) {
                  return DeprecatedGpsCoordinateFormat.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDescriptor().getEnumTypes().get(0);
        }

        private static final DeprecatedGpsCoordinateFormat[] VALUES = values();

        public static DeprecatedGpsCoordinateFormat valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private DeprecatedGpsCoordinateFormat(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat)
      }

      /**
       * <pre>
       *
       * Unit display preference
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.DisplayConfig.DisplayUnits}
       */
      public enum DisplayUnits
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Metric (Default)
         * </pre>
         *
         * <code>METRIC = 0;</code>
         */
        METRIC(0),
        /**
         * <pre>
         *
         * Imperial
         * </pre>
         *
         * <code>IMPERIAL = 1;</code>
         */
        IMPERIAL(1),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Metric (Default)
         * </pre>
         *
         * <code>METRIC = 0;</code>
         */
        public static final int METRIC_VALUE = 0;
        /**
         * <pre>
         *
         * Imperial
         * </pre>
         *
         * <code>IMPERIAL = 1;</code>
         */
        public static final int IMPERIAL_VALUE = 1;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static DisplayUnits valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static DisplayUnits forNumber(int value) {
          switch (value) {
            case 0: return METRIC;
            case 1: return IMPERIAL;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<DisplayUnits>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            DisplayUnits> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<DisplayUnits>() {
                public DisplayUnits findValueByNumber(int number) {
                  return DisplayUnits.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDescriptor().getEnumTypes().get(1);
        }

        private static final DisplayUnits[] VALUES = values();

        public static DisplayUnits valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private DisplayUnits(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.DisplayConfig.DisplayUnits)
      }

      /**
       * <pre>
       *
       * Override OLED outo detect with this if it fails.
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.DisplayConfig.OledType}
       */
      public enum OledType
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Default / Autodetect
         * </pre>
         *
         * <code>OLED_AUTO = 0;</code>
         */
        OLED_AUTO(0),
        /**
         * <pre>
         *
         * Default / Autodetect
         * </pre>
         *
         * <code>OLED_SSD1306 = 1;</code>
         */
        OLED_SSD1306(1),
        /**
         * <pre>
         *
         * Default / Autodetect
         * </pre>
         *
         * <code>OLED_SH1106 = 2;</code>
         */
        OLED_SH1106(2),
        /**
         * <pre>
         *
         * Can not be auto detected but set by proto. Used for 128x64 screens
         * </pre>
         *
         * <code>OLED_SH1107 = 3;</code>
         */
        OLED_SH1107(3),
        /**
         * <pre>
         *
         * Can not be auto detected but set by proto. Used for 128x128 screens
         * </pre>
         *
         * <code>OLED_SH1107_128_128 = 4;</code>
         */
        OLED_SH1107_128_128(4),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Default / Autodetect
         * </pre>
         *
         * <code>OLED_AUTO = 0;</code>
         */
        public static final int OLED_AUTO_VALUE = 0;
        /**
         * <pre>
         *
         * Default / Autodetect
         * </pre>
         *
         * <code>OLED_SSD1306 = 1;</code>
         */
        public static final int OLED_SSD1306_VALUE = 1;
        /**
         * <pre>
         *
         * Default / Autodetect
         * </pre>
         *
         * <code>OLED_SH1106 = 2;</code>
         */
        public static final int OLED_SH1106_VALUE = 2;
        /**
         * <pre>
         *
         * Can not be auto detected but set by proto. Used for 128x64 screens
         * </pre>
         *
         * <code>OLED_SH1107 = 3;</code>
         */
        public static final int OLED_SH1107_VALUE = 3;
        /**
         * <pre>
         *
         * Can not be auto detected but set by proto. Used for 128x128 screens
         * </pre>
         *
         * <code>OLED_SH1107_128_128 = 4;</code>
         */
        public static final int OLED_SH1107_128_128_VALUE = 4;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static OledType valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static OledType forNumber(int value) {
          switch (value) {
            case 0: return OLED_AUTO;
            case 1: return OLED_SSD1306;
            case 2: return OLED_SH1106;
            case 3: return OLED_SH1107;
            case 4: return OLED_SH1107_128_128;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<OledType>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            OledType> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<OledType>() {
                public OledType findValueByNumber(int number) {
                  return OledType.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDescriptor().getEnumTypes().get(2);
        }

        private static final OledType[] VALUES = values();

        public static OledType valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private OledType(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.DisplayConfig.OledType)
      }

      /**
       * Protobuf enum {@code meshtastic.Config.DisplayConfig.DisplayMode}
       */
      public enum DisplayMode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Default. The old style for the 128x64 OLED screen
         * </pre>
         *
         * <code>DEFAULT = 0;</code>
         */
        DEFAULT(0),
        /**
         * <pre>
         *
         * Rearrange display elements to cater for bicolor OLED displays
         * </pre>
         *
         * <code>TWOCOLOR = 1;</code>
         */
        TWOCOLOR(1),
        /**
         * <pre>
         *
         * Same as TwoColor, but with inverted top bar. Not so good for Epaper displays
         * </pre>
         *
         * <code>INVERTED = 2;</code>
         */
        INVERTED(2),
        /**
         * <pre>
         *
         * TFT Full Color Displays (not implemented yet)
         * </pre>
         *
         * <code>COLOR = 3;</code>
         */
        COLOR(3),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Default. The old style for the 128x64 OLED screen
         * </pre>
         *
         * <code>DEFAULT = 0;</code>
         */
        public static final int DEFAULT_VALUE = 0;
        /**
         * <pre>
         *
         * Rearrange display elements to cater for bicolor OLED displays
         * </pre>
         *
         * <code>TWOCOLOR = 1;</code>
         */
        public static final int TWOCOLOR_VALUE = 1;
        /**
         * <pre>
         *
         * Same as TwoColor, but with inverted top bar. Not so good for Epaper displays
         * </pre>
         *
         * <code>INVERTED = 2;</code>
         */
        public static final int INVERTED_VALUE = 2;
        /**
         * <pre>
         *
         * TFT Full Color Displays (not implemented yet)
         * </pre>
         *
         * <code>COLOR = 3;</code>
         */
        public static final int COLOR_VALUE = 3;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static DisplayMode valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static DisplayMode forNumber(int value) {
          switch (value) {
            case 0: return DEFAULT;
            case 1: return TWOCOLOR;
            case 2: return INVERTED;
            case 3: return COLOR;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<DisplayMode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            DisplayMode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<DisplayMode>() {
                public DisplayMode findValueByNumber(int number) {
                  return DisplayMode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDescriptor().getEnumTypes().get(3);
        }

        private static final DisplayMode[] VALUES = values();

        public static DisplayMode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private DisplayMode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.DisplayConfig.DisplayMode)
      }

      /**
       * Protobuf enum {@code meshtastic.Config.DisplayConfig.CompassOrientation}
       */
      public enum CompassOrientation
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * The compass and the display are in the same orientation.
         * </pre>
         *
         * <code>DEGREES_0 = 0;</code>
         */
        DEGREES_0(0),
        /**
         * <pre>
         *
         * Rotate the compass by 90 degrees.
         * </pre>
         *
         * <code>DEGREES_90 = 1;</code>
         */
        DEGREES_90(1),
        /**
         * <pre>
         *
         * Rotate the compass by 180 degrees.
         * </pre>
         *
         * <code>DEGREES_180 = 2;</code>
         */
        DEGREES_180(2),
        /**
         * <pre>
         *
         * Rotate the compass by 270 degrees.
         * </pre>
         *
         * <code>DEGREES_270 = 3;</code>
         */
        DEGREES_270(3),
        /**
         * <pre>
         *
         * Don't rotate the compass, but invert the result.
         * </pre>
         *
         * <code>DEGREES_0_INVERTED = 4;</code>
         */
        DEGREES_0_INVERTED(4),
        /**
         * <pre>
         *
         * Rotate the compass by 90 degrees and invert.
         * </pre>
         *
         * <code>DEGREES_90_INVERTED = 5;</code>
         */
        DEGREES_90_INVERTED(5),
        /**
         * <pre>
         *
         * Rotate the compass by 180 degrees and invert.
         * </pre>
         *
         * <code>DEGREES_180_INVERTED = 6;</code>
         */
        DEGREES_180_INVERTED(6),
        /**
         * <pre>
         *
         * Rotate the compass by 270 degrees and invert.
         * </pre>
         *
         * <code>DEGREES_270_INVERTED = 7;</code>
         */
        DEGREES_270_INVERTED(7),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * The compass and the display are in the same orientation.
         * </pre>
         *
         * <code>DEGREES_0 = 0;</code>
         */
        public static final int DEGREES_0_VALUE = 0;
        /**
         * <pre>
         *
         * Rotate the compass by 90 degrees.
         * </pre>
         *
         * <code>DEGREES_90 = 1;</code>
         */
        public static final int DEGREES_90_VALUE = 1;
        /**
         * <pre>
         *
         * Rotate the compass by 180 degrees.
         * </pre>
         *
         * <code>DEGREES_180 = 2;</code>
         */
        public static final int DEGREES_180_VALUE = 2;
        /**
         * <pre>
         *
         * Rotate the compass by 270 degrees.
         * </pre>
         *
         * <code>DEGREES_270 = 3;</code>
         */
        public static final int DEGREES_270_VALUE = 3;
        /**
         * <pre>
         *
         * Don't rotate the compass, but invert the result.
         * </pre>
         *
         * <code>DEGREES_0_INVERTED = 4;</code>
         */
        public static final int DEGREES_0_INVERTED_VALUE = 4;
        /**
         * <pre>
         *
         * Rotate the compass by 90 degrees and invert.
         * </pre>
         *
         * <code>DEGREES_90_INVERTED = 5;</code>
         */
        public static final int DEGREES_90_INVERTED_VALUE = 5;
        /**
         * <pre>
         *
         * Rotate the compass by 180 degrees and invert.
         * </pre>
         *
         * <code>DEGREES_180_INVERTED = 6;</code>
         */
        public static final int DEGREES_180_INVERTED_VALUE = 6;
        /**
         * <pre>
         *
         * Rotate the compass by 270 degrees and invert.
         * </pre>
         *
         * <code>DEGREES_270_INVERTED = 7;</code>
         */
        public static final int DEGREES_270_INVERTED_VALUE = 7;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static CompassOrientation valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static CompassOrientation forNumber(int value) {
          switch (value) {
            case 0: return DEGREES_0;
            case 1: return DEGREES_90;
            case 2: return DEGREES_180;
            case 3: return DEGREES_270;
            case 4: return DEGREES_0_INVERTED;
            case 5: return DEGREES_90_INVERTED;
            case 6: return DEGREES_180_INVERTED;
            case 7: return DEGREES_270_INVERTED;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<CompassOrientation>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            CompassOrientation> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<CompassOrientation>() {
                public CompassOrientation findValueByNumber(int number) {
                  return CompassOrientation.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDescriptor().getEnumTypes().get(4);
        }

        private static final CompassOrientation[] VALUES = values();

        public static CompassOrientation valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private CompassOrientation(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.DisplayConfig.CompassOrientation)
      }

      public static final int SCREEN_ON_SECS_FIELD_NUMBER = 1;
      private int screenOnSecs_ = 0;
      /**
       * <pre>
       *
       * Number of seconds the screen stays on after pressing the user button or receiving a message
       * 0 for default of one minute MAXUINT for always on
       * </pre>
       *
       * <code>uint32 screen_on_secs = 1;</code>
       * @return The screenOnSecs.
       */
      @java.lang.Override
      public int getScreenOnSecs() {
        return screenOnSecs_;
      }

      public static final int GPS_FORMAT_FIELD_NUMBER = 2;
      private int gpsFormat_ = 0;
      /**
       * <pre>
       *
       * Deprecated in 2.7.4: Unused
       * How the GPS coordinates are formatted on the OLED screen.
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
       *     See meshtastic/config.proto;l=662
       * @return The enum numeric value on the wire for gpsFormat.
       */
      @java.lang.Override @java.lang.Deprecated public int getGpsFormatValue() {
        return gpsFormat_;
      }
      /**
       * <pre>
       *
       * Deprecated in 2.7.4: Unused
       * How the GPS coordinates are formatted on the OLED screen.
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
       *     See meshtastic/config.proto;l=662
       * @return The gpsFormat.
       */
      @java.lang.Override @java.lang.Deprecated public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat getGpsFormat() {
        com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat.forNumber(gpsFormat_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat.UNRECOGNIZED : result;
      }

      public static final int AUTO_SCREEN_CAROUSEL_SECS_FIELD_NUMBER = 3;
      private int autoScreenCarouselSecs_ = 0;
      /**
       * <pre>
       *
       * Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
       * Potentially useful for devices without user buttons.
       * </pre>
       *
       * <code>uint32 auto_screen_carousel_secs = 3;</code>
       * @return The autoScreenCarouselSecs.
       */
      @java.lang.Override
      public int getAutoScreenCarouselSecs() {
        return autoScreenCarouselSecs_;
      }

      public static final int COMPASS_NORTH_TOP_FIELD_NUMBER = 4;
      private boolean compassNorthTop_ = false;
      /**
       * <pre>
       *
       * If this is set, the displayed compass will always point north. if unset, the old behaviour
       * (top of display is heading direction) is used.
       * </pre>
       *
       * <code>bool compass_north_top = 4 [deprecated = true];</code>
       * @deprecated meshtastic.Config.DisplayConfig.compass_north_top is deprecated.
       *     See meshtastic/config.proto;l=674
       * @return The compassNorthTop.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getCompassNorthTop() {
        return compassNorthTop_;
      }

      public static final int FLIP_SCREEN_FIELD_NUMBER = 5;
      private boolean flipScreen_ = false;
      /**
       * <pre>
       *
       * Flip screen vertically, for cases that mount the screen upside down
       * </pre>
       *
       * <code>bool flip_screen = 5;</code>
       * @return The flipScreen.
       */
      @java.lang.Override
      public boolean getFlipScreen() {
        return flipScreen_;
      }

      public static final int UNITS_FIELD_NUMBER = 6;
      private int units_ = 0;
      /**
       * <pre>
       *
       * Perferred display units
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
       * @return The enum numeric value on the wire for units.
       */
      @java.lang.Override public int getUnitsValue() {
        return units_;
      }
      /**
       * <pre>
       *
       * Perferred display units
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
       * @return The units.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits getUnits() {
        com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits.forNumber(units_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits.UNRECOGNIZED : result;
      }

      public static final int OLED_FIELD_NUMBER = 7;
      private int oled_ = 0;
      /**
       * <pre>
       *
       * Override auto-detect in screen
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
       * @return The enum numeric value on the wire for oled.
       */
      @java.lang.Override public int getOledValue() {
        return oled_;
      }
      /**
       * <pre>
       *
       * Override auto-detect in screen
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
       * @return The oled.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType getOled() {
        com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType.forNumber(oled_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType.UNRECOGNIZED : result;
      }

      public static final int DISPLAYMODE_FIELD_NUMBER = 8;
      private int displaymode_ = 0;
      /**
       * <pre>
       *
       * Display Mode
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
       * @return The enum numeric value on the wire for displaymode.
       */
      @java.lang.Override public int getDisplaymodeValue() {
        return displaymode_;
      }
      /**
       * <pre>
       *
       * Display Mode
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
       * @return The displaymode.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode getDisplaymode() {
        com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode.forNumber(displaymode_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode.UNRECOGNIZED : result;
      }

      public static final int HEADING_BOLD_FIELD_NUMBER = 9;
      private boolean headingBold_ = false;
      /**
       * <pre>
       *
       * Print first line in pseudo-bold? FALSE is original style, TRUE is bold
       * </pre>
       *
       * <code>bool heading_bold = 9;</code>
       * @return The headingBold.
       */
      @java.lang.Override
      public boolean getHeadingBold() {
        return headingBold_;
      }

      public static final int WAKE_ON_TAP_OR_MOTION_FIELD_NUMBER = 10;
      private boolean wakeOnTapOrMotion_ = false;
      /**
       * <pre>
       *
       * Should we wake the screen up on accelerometer detected motion or tap
       * </pre>
       *
       * <code>bool wake_on_tap_or_motion = 10;</code>
       * @return The wakeOnTapOrMotion.
       */
      @java.lang.Override
      public boolean getWakeOnTapOrMotion() {
        return wakeOnTapOrMotion_;
      }

      public static final int COMPASS_ORIENTATION_FIELD_NUMBER = 11;
      private int compassOrientation_ = 0;
      /**
       * <pre>
       *
       * Indicates how to rotate or invert the compass output to accurate display on the display.
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
       * @return The enum numeric value on the wire for compassOrientation.
       */
      @java.lang.Override public int getCompassOrientationValue() {
        return compassOrientation_;
      }
      /**
       * <pre>
       *
       * Indicates how to rotate or invert the compass output to accurate display on the display.
       * </pre>
       *
       * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
       * @return The compassOrientation.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation getCompassOrientation() {
        com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation.forNumber(compassOrientation_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation.UNRECOGNIZED : result;
      }

      public static final int USE_12H_CLOCK_FIELD_NUMBER = 12;
      private boolean use12HClock_ = false;
      /**
       * <pre>
       *
       * If false (default), the device will display the time in 24-hour format on screen.
       * If true, the device will display the time in 12-hour format on screen.
       * </pre>
       *
       * <code>bool use_12h_clock = 12;</code>
       * @return The use12hClock.
       */
      @java.lang.Override
      public boolean getUse12HClock() {
        return use12HClock_;
      }

      public static final int USE_LONG_NODE_NAME_FIELD_NUMBER = 13;
      private boolean useLongNodeName_ = false;
      /**
       * <pre>
       *
       * If false (default), the device will use short names for various display screens.
       * If true, node names will show in long format
       * </pre>
       *
       * <code>bool use_long_node_name = 13;</code>
       * @return The useLongNodeName.
       */
      @java.lang.Override
      public boolean getUseLongNodeName() {
        return useLongNodeName_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (screenOnSecs_ != 0) {
          output.writeUInt32(1, screenOnSecs_);
        }
        if (gpsFormat_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat.UNUSED.getNumber()) {
          output.writeEnum(2, gpsFormat_);
        }
        if (autoScreenCarouselSecs_ != 0) {
          output.writeUInt32(3, autoScreenCarouselSecs_);
        }
        if (compassNorthTop_ != false) {
          output.writeBool(4, compassNorthTop_);
        }
        if (flipScreen_ != false) {
          output.writeBool(5, flipScreen_);
        }
        if (units_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits.METRIC.getNumber()) {
          output.writeEnum(6, units_);
        }
        if (oled_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType.OLED_AUTO.getNumber()) {
          output.writeEnum(7, oled_);
        }
        if (displaymode_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode.DEFAULT.getNumber()) {
          output.writeEnum(8, displaymode_);
        }
        if (headingBold_ != false) {
          output.writeBool(9, headingBold_);
        }
        if (wakeOnTapOrMotion_ != false) {
          output.writeBool(10, wakeOnTapOrMotion_);
        }
        if (compassOrientation_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation.DEGREES_0.getNumber()) {
          output.writeEnum(11, compassOrientation_);
        }
        if (use12HClock_ != false) {
          output.writeBool(12, use12HClock_);
        }
        if (useLongNodeName_ != false) {
          output.writeBool(13, useLongNodeName_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (screenOnSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, screenOnSecs_);
        }
        if (gpsFormat_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat.UNUSED.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(2, gpsFormat_);
        }
        if (autoScreenCarouselSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(3, autoScreenCarouselSecs_);
        }
        if (compassNorthTop_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(4, compassNorthTop_);
        }
        if (flipScreen_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(5, flipScreen_);
        }
        if (units_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits.METRIC.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(6, units_);
        }
        if (oled_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType.OLED_AUTO.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(7, oled_);
        }
        if (displaymode_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode.DEFAULT.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(8, displaymode_);
        }
        if (headingBold_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(9, headingBold_);
        }
        if (wakeOnTapOrMotion_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(10, wakeOnTapOrMotion_);
        }
        if (compassOrientation_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation.DEGREES_0.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(11, compassOrientation_);
        }
        if (use12HClock_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(12, use12HClock_);
        }
        if (useLongNodeName_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(13, useLongNodeName_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.DisplayConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.DisplayConfig other = (com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) obj;

        if (getScreenOnSecs()
            != other.getScreenOnSecs()) return false;
        if (gpsFormat_ != other.gpsFormat_) return false;
        if (getAutoScreenCarouselSecs()
            != other.getAutoScreenCarouselSecs()) return false;
        if (getCompassNorthTop()
            != other.getCompassNorthTop()) return false;
        if (getFlipScreen()
            != other.getFlipScreen()) return false;
        if (units_ != other.units_) return false;
        if (oled_ != other.oled_) return false;
        if (displaymode_ != other.displaymode_) return false;
        if (getHeadingBold()
            != other.getHeadingBold()) return false;
        if (getWakeOnTapOrMotion()
            != other.getWakeOnTapOrMotion()) return false;
        if (compassOrientation_ != other.compassOrientation_) return false;
        if (getUse12HClock()
            != other.getUse12HClock()) return false;
        if (getUseLongNodeName()
            != other.getUseLongNodeName()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + SCREEN_ON_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getScreenOnSecs();
        hash = (37 * hash) + GPS_FORMAT_FIELD_NUMBER;
        hash = (53 * hash) + gpsFormat_;
        hash = (37 * hash) + AUTO_SCREEN_CAROUSEL_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getAutoScreenCarouselSecs();
        hash = (37 * hash) + COMPASS_NORTH_TOP_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getCompassNorthTop());
        hash = (37 * hash) + FLIP_SCREEN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getFlipScreen());
        hash = (37 * hash) + UNITS_FIELD_NUMBER;
        hash = (53 * hash) + units_;
        hash = (37 * hash) + OLED_FIELD_NUMBER;
        hash = (53 * hash) + oled_;
        hash = (37 * hash) + DISPLAYMODE_FIELD_NUMBER;
        hash = (53 * hash) + displaymode_;
        hash = (37 * hash) + HEADING_BOLD_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getHeadingBold());
        hash = (37 * hash) + WAKE_ON_TAP_OR_MOTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getWakeOnTapOrMotion());
        hash = (37 * hash) + COMPASS_ORIENTATION_FIELD_NUMBER;
        hash = (53 * hash) + compassOrientation_;
        hash = (37 * hash) + USE_12H_CLOCK_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUse12HClock());
        hash = (37 * hash) + USE_LONG_NODE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseLongNodeName());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       *
       * Display Config
       * </pre>
       *
       * Protobuf type {@code meshtastic.Config.DisplayConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.DisplayConfig)
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DisplayConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DisplayConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.class, com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          screenOnSecs_ = 0;
          gpsFormat_ = 0;
          autoScreenCarouselSecs_ = 0;
          compassNorthTop_ = false;
          flipScreen_ = false;
          units_ = 0;
          oled_ = 0;
          displaymode_ = 0;
          headingBold_ = false;
          wakeOnTapOrMotion_ = false;
          compassOrientation_ = 0;
          use12HClock_ = false;
          useLongNodeName_ = false;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_DisplayConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig result = new com.geeksville.mesh.ConfigProtos.Config.DisplayConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.screenOnSecs_ = screenOnSecs_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.gpsFormat_ = gpsFormat_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.autoScreenCarouselSecs_ = autoScreenCarouselSecs_;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.compassNorthTop_ = compassNorthTop_;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.flipScreen_ = flipScreen_;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.units_ = units_;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.oled_ = oled_;
          }
          if (((from_bitField0_ & 0x00000080) != 0)) {
            result.displaymode_ = displaymode_;
          }
          if (((from_bitField0_ & 0x00000100) != 0)) {
            result.headingBold_ = headingBold_;
          }
          if (((from_bitField0_ & 0x00000200) != 0)) {
            result.wakeOnTapOrMotion_ = wakeOnTapOrMotion_;
          }
          if (((from_bitField0_ & 0x00000400) != 0)) {
            result.compassOrientation_ = compassOrientation_;
          }
          if (((from_bitField0_ & 0x00000800) != 0)) {
            result.use12HClock_ = use12HClock_;
          }
          if (((from_bitField0_ & 0x00001000) != 0)) {
            result.useLongNodeName_ = useLongNodeName_;
          }
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.DisplayConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance()) return this;
          if (other.getScreenOnSecs() != 0) {
            setScreenOnSecs(other.getScreenOnSecs());
          }
          if (other.gpsFormat_ != 0) {
            setGpsFormatValue(other.getGpsFormatValue());
          }
          if (other.getAutoScreenCarouselSecs() != 0) {
            setAutoScreenCarouselSecs(other.getAutoScreenCarouselSecs());
          }
          if (other.getCompassNorthTop() != false) {
            setCompassNorthTop(other.getCompassNorthTop());
          }
          if (other.getFlipScreen() != false) {
            setFlipScreen(other.getFlipScreen());
          }
          if (other.units_ != 0) {
            setUnitsValue(other.getUnitsValue());
          }
          if (other.oled_ != 0) {
            setOledValue(other.getOledValue());
          }
          if (other.displaymode_ != 0) {
            setDisplaymodeValue(other.getDisplaymodeValue());
          }
          if (other.getHeadingBold() != false) {
            setHeadingBold(other.getHeadingBold());
          }
          if (other.getWakeOnTapOrMotion() != false) {
            setWakeOnTapOrMotion(other.getWakeOnTapOrMotion());
          }
          if (other.compassOrientation_ != 0) {
            setCompassOrientationValue(other.getCompassOrientationValue());
          }
          if (other.getUse12HClock() != false) {
            setUse12HClock(other.getUse12HClock());
          }
          if (other.getUseLongNodeName() != false) {
            setUseLongNodeName(other.getUseLongNodeName());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  screenOnSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  gpsFormat_ = input.readEnum();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 24: {
                  autoScreenCarouselSecs_ = input.readUInt32();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 24
                case 32: {
                  compassNorthTop_ = input.readBool();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
                case 40: {
                  flipScreen_ = input.readBool();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 40
                case 48: {
                  units_ = input.readEnum();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 48
                case 56: {
                  oled_ = input.readEnum();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 56
                case 64: {
                  displaymode_ = input.readEnum();
                  bitField0_ |= 0x00000080;
                  break;
                } // case 64
                case 72: {
                  headingBold_ = input.readBool();
                  bitField0_ |= 0x00000100;
                  break;
                } // case 72
                case 80: {
                  wakeOnTapOrMotion_ = input.readBool();
                  bitField0_ |= 0x00000200;
                  break;
                } // case 80
                case 88: {
                  compassOrientation_ = input.readEnum();
                  bitField0_ |= 0x00000400;
                  break;
                } // case 88
                case 96: {
                  use12HClock_ = input.readBool();
                  bitField0_ |= 0x00000800;
                  break;
                } // case 96
                case 104: {
                  useLongNodeName_ = input.readBool();
                  bitField0_ |= 0x00001000;
                  break;
                } // case 104
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int screenOnSecs_ ;
        /**
         * <pre>
         *
         * Number of seconds the screen stays on after pressing the user button or receiving a message
         * 0 for default of one minute MAXUINT for always on
         * </pre>
         *
         * <code>uint32 screen_on_secs = 1;</code>
         * @return The screenOnSecs.
         */
        @java.lang.Override
        public int getScreenOnSecs() {
          return screenOnSecs_;
        }
        /**
         * <pre>
         *
         * Number of seconds the screen stays on after pressing the user button or receiving a message
         * 0 for default of one minute MAXUINT for always on
         * </pre>
         *
         * <code>uint32 screen_on_secs = 1;</code>
         * @param value The screenOnSecs to set.
         * @return This builder for chaining.
         */
        public Builder setScreenOnSecs(int value) {

          screenOnSecs_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Number of seconds the screen stays on after pressing the user button or receiving a message
         * 0 for default of one minute MAXUINT for always on
         * </pre>
         *
         * <code>uint32 screen_on_secs = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearScreenOnSecs() {
          bitField0_ = (bitField0_ & ~0x00000001);
          screenOnSecs_ = 0;
          onChanged();
          return this;
        }

        private int gpsFormat_ = 0;
        /**
         * <pre>
         *
         * Deprecated in 2.7.4: Unused
         * How the GPS coordinates are formatted on the OLED screen.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
         *     See meshtastic/config.proto;l=662
         * @return The enum numeric value on the wire for gpsFormat.
         */
        @java.lang.Override @java.lang.Deprecated public int getGpsFormatValue() {
          return gpsFormat_;
        }
        /**
         * <pre>
         *
         * Deprecated in 2.7.4: Unused
         * How the GPS coordinates are formatted on the OLED screen.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
         *     See meshtastic/config.proto;l=662
         * @param value The enum numeric value on the wire for gpsFormat to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setGpsFormatValue(int value) {
          gpsFormat_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Deprecated in 2.7.4: Unused
         * How the GPS coordinates are formatted on the OLED screen.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
         *     See meshtastic/config.proto;l=662
         * @return The gpsFormat.
         */
        @java.lang.Override
        @java.lang.Deprecated public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat getGpsFormat() {
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat.forNumber(gpsFormat_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Deprecated in 2.7.4: Unused
         * How the GPS coordinates are formatted on the OLED screen.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
         *     See meshtastic/config.proto;l=662
         * @param value The gpsFormat to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setGpsFormat(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DeprecatedGpsCoordinateFormat value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000002;
          gpsFormat_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Deprecated in 2.7.4: Unused
         * How the GPS coordinates are formatted on the OLED screen.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat gps_format = 2 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DisplayConfig.gps_format is deprecated.
         *     See meshtastic/config.proto;l=662
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder clearGpsFormat() {
          bitField0_ = (bitField0_ & ~0x00000002);
          gpsFormat_ = 0;
          onChanged();
          return this;
        }

        private int autoScreenCarouselSecs_ ;
        /**
         * <pre>
         *
         * Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
         * Potentially useful for devices without user buttons.
         * </pre>
         *
         * <code>uint32 auto_screen_carousel_secs = 3;</code>
         * @return The autoScreenCarouselSecs.
         */
        @java.lang.Override
        public int getAutoScreenCarouselSecs() {
          return autoScreenCarouselSecs_;
        }
        /**
         * <pre>
         *
         * Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
         * Potentially useful for devices without user buttons.
         * </pre>
         *
         * <code>uint32 auto_screen_carousel_secs = 3;</code>
         * @param value The autoScreenCarouselSecs to set.
         * @return This builder for chaining.
         */
        public Builder setAutoScreenCarouselSecs(int value) {

          autoScreenCarouselSecs_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
         * Potentially useful for devices without user buttons.
         * </pre>
         *
         * <code>uint32 auto_screen_carousel_secs = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearAutoScreenCarouselSecs() {
          bitField0_ = (bitField0_ & ~0x00000004);
          autoScreenCarouselSecs_ = 0;
          onChanged();
          return this;
        }

        private boolean compassNorthTop_ ;
        /**
         * <pre>
         *
         * If this is set, the displayed compass will always point north. if unset, the old behaviour
         * (top of display is heading direction) is used.
         * </pre>
         *
         * <code>bool compass_north_top = 4 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DisplayConfig.compass_north_top is deprecated.
         *     See meshtastic/config.proto;l=674
         * @return The compassNorthTop.
         */
        @java.lang.Override
        @java.lang.Deprecated public boolean getCompassNorthTop() {
          return compassNorthTop_;
        }
        /**
         * <pre>
         *
         * If this is set, the displayed compass will always point north. if unset, the old behaviour
         * (top of display is heading direction) is used.
         * </pre>
         *
         * <code>bool compass_north_top = 4 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DisplayConfig.compass_north_top is deprecated.
         *     See meshtastic/config.proto;l=674
         * @param value The compassNorthTop to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setCompassNorthTop(boolean value) {

          compassNorthTop_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If this is set, the displayed compass will always point north. if unset, the old behaviour
         * (top of display is heading direction) is used.
         * </pre>
         *
         * <code>bool compass_north_top = 4 [deprecated = true];</code>
         * @deprecated meshtastic.Config.DisplayConfig.compass_north_top is deprecated.
         *     See meshtastic/config.proto;l=674
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder clearCompassNorthTop() {
          bitField0_ = (bitField0_ & ~0x00000008);
          compassNorthTop_ = false;
          onChanged();
          return this;
        }

        private boolean flipScreen_ ;
        /**
         * <pre>
         *
         * Flip screen vertically, for cases that mount the screen upside down
         * </pre>
         *
         * <code>bool flip_screen = 5;</code>
         * @return The flipScreen.
         */
        @java.lang.Override
        public boolean getFlipScreen() {
          return flipScreen_;
        }
        /**
         * <pre>
         *
         * Flip screen vertically, for cases that mount the screen upside down
         * </pre>
         *
         * <code>bool flip_screen = 5;</code>
         * @param value The flipScreen to set.
         * @return This builder for chaining.
         */
        public Builder setFlipScreen(boolean value) {

          flipScreen_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Flip screen vertically, for cases that mount the screen upside down
         * </pre>
         *
         * <code>bool flip_screen = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearFlipScreen() {
          bitField0_ = (bitField0_ & ~0x00000010);
          flipScreen_ = false;
          onChanged();
          return this;
        }

        private int units_ = 0;
        /**
         * <pre>
         *
         * Perferred display units
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
         * @return The enum numeric value on the wire for units.
         */
        @java.lang.Override public int getUnitsValue() {
          return units_;
        }
        /**
         * <pre>
         *
         * Perferred display units
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
         * @param value The enum numeric value on the wire for units to set.
         * @return This builder for chaining.
         */
        public Builder setUnitsValue(int value) {
          units_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Perferred display units
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
         * @return The units.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits getUnits() {
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits.forNumber(units_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Perferred display units
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
         * @param value The units to set.
         * @return This builder for chaining.
         */
        public Builder setUnits(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayUnits value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000020;
          units_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Perferred display units
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayUnits units = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearUnits() {
          bitField0_ = (bitField0_ & ~0x00000020);
          units_ = 0;
          onChanged();
          return this;
        }

        private int oled_ = 0;
        /**
         * <pre>
         *
         * Override auto-detect in screen
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
         * @return The enum numeric value on the wire for oled.
         */
        @java.lang.Override public int getOledValue() {
          return oled_;
        }
        /**
         * <pre>
         *
         * Override auto-detect in screen
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
         * @param value The enum numeric value on the wire for oled to set.
         * @return This builder for chaining.
         */
        public Builder setOledValue(int value) {
          oled_ = value;
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Override auto-detect in screen
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
         * @return The oled.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType getOled() {
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType.forNumber(oled_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Override auto-detect in screen
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
         * @param value The oled to set.
         * @return This builder for chaining.
         */
        public Builder setOled(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.OledType value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000040;
          oled_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Override auto-detect in screen
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.OledType oled = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearOled() {
          bitField0_ = (bitField0_ & ~0x00000040);
          oled_ = 0;
          onChanged();
          return this;
        }

        private int displaymode_ = 0;
        /**
         * <pre>
         *
         * Display Mode
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
         * @return The enum numeric value on the wire for displaymode.
         */
        @java.lang.Override public int getDisplaymodeValue() {
          return displaymode_;
        }
        /**
         * <pre>
         *
         * Display Mode
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
         * @param value The enum numeric value on the wire for displaymode to set.
         * @return This builder for chaining.
         */
        public Builder setDisplaymodeValue(int value) {
          displaymode_ = value;
          bitField0_ |= 0x00000080;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Display Mode
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
         * @return The displaymode.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode getDisplaymode() {
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode.forNumber(displaymode_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Display Mode
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
         * @param value The displaymode to set.
         * @return This builder for chaining.
         */
        public Builder setDisplaymode(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.DisplayMode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000080;
          displaymode_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Display Mode
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearDisplaymode() {
          bitField0_ = (bitField0_ & ~0x00000080);
          displaymode_ = 0;
          onChanged();
          return this;
        }

        private boolean headingBold_ ;
        /**
         * <pre>
         *
         * Print first line in pseudo-bold? FALSE is original style, TRUE is bold
         * </pre>
         *
         * <code>bool heading_bold = 9;</code>
         * @return The headingBold.
         */
        @java.lang.Override
        public boolean getHeadingBold() {
          return headingBold_;
        }
        /**
         * <pre>
         *
         * Print first line in pseudo-bold? FALSE is original style, TRUE is bold
         * </pre>
         *
         * <code>bool heading_bold = 9;</code>
         * @param value The headingBold to set.
         * @return This builder for chaining.
         */
        public Builder setHeadingBold(boolean value) {

          headingBold_ = value;
          bitField0_ |= 0x00000100;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Print first line in pseudo-bold? FALSE is original style, TRUE is bold
         * </pre>
         *
         * <code>bool heading_bold = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearHeadingBold() {
          bitField0_ = (bitField0_ & ~0x00000100);
          headingBold_ = false;
          onChanged();
          return this;
        }

        private boolean wakeOnTapOrMotion_ ;
        /**
         * <pre>
         *
         * Should we wake the screen up on accelerometer detected motion or tap
         * </pre>
         *
         * <code>bool wake_on_tap_or_motion = 10;</code>
         * @return The wakeOnTapOrMotion.
         */
        @java.lang.Override
        public boolean getWakeOnTapOrMotion() {
          return wakeOnTapOrMotion_;
        }
        /**
         * <pre>
         *
         * Should we wake the screen up on accelerometer detected motion or tap
         * </pre>
         *
         * <code>bool wake_on_tap_or_motion = 10;</code>
         * @param value The wakeOnTapOrMotion to set.
         * @return This builder for chaining.
         */
        public Builder setWakeOnTapOrMotion(boolean value) {

          wakeOnTapOrMotion_ = value;
          bitField0_ |= 0x00000200;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Should we wake the screen up on accelerometer detected motion or tap
         * </pre>
         *
         * <code>bool wake_on_tap_or_motion = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearWakeOnTapOrMotion() {
          bitField0_ = (bitField0_ & ~0x00000200);
          wakeOnTapOrMotion_ = false;
          onChanged();
          return this;
        }

        private int compassOrientation_ = 0;
        /**
         * <pre>
         *
         * Indicates how to rotate or invert the compass output to accurate display on the display.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
         * @return The enum numeric value on the wire for compassOrientation.
         */
        @java.lang.Override public int getCompassOrientationValue() {
          return compassOrientation_;
        }
        /**
         * <pre>
         *
         * Indicates how to rotate or invert the compass output to accurate display on the display.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
         * @param value The enum numeric value on the wire for compassOrientation to set.
         * @return This builder for chaining.
         */
        public Builder setCompassOrientationValue(int value) {
          compassOrientation_ = value;
          bitField0_ |= 0x00000400;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Indicates how to rotate or invert the compass output to accurate display on the display.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
         * @return The compassOrientation.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation getCompassOrientation() {
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation result = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation.forNumber(compassOrientation_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Indicates how to rotate or invert the compass output to accurate display on the display.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
         * @param value The compassOrientation to set.
         * @return This builder for chaining.
         */
        public Builder setCompassOrientation(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.CompassOrientation value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000400;
          compassOrientation_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Indicates how to rotate or invert the compass output to accurate display on the display.
         * </pre>
         *
         * <code>.meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;</code>
         * @return This builder for chaining.
         */
        public Builder clearCompassOrientation() {
          bitField0_ = (bitField0_ & ~0x00000400);
          compassOrientation_ = 0;
          onChanged();
          return this;
        }

        private boolean use12HClock_ ;
        /**
         * <pre>
         *
         * If false (default), the device will display the time in 24-hour format on screen.
         * If true, the device will display the time in 12-hour format on screen.
         * </pre>
         *
         * <code>bool use_12h_clock = 12;</code>
         * @return The use12hClock.
         */
        @java.lang.Override
        public boolean getUse12HClock() {
          return use12HClock_;
        }
        /**
         * <pre>
         *
         * If false (default), the device will display the time in 24-hour format on screen.
         * If true, the device will display the time in 12-hour format on screen.
         * </pre>
         *
         * <code>bool use_12h_clock = 12;</code>
         * @param value The use12hClock to set.
         * @return This builder for chaining.
         */
        public Builder setUse12HClock(boolean value) {

          use12HClock_ = value;
          bitField0_ |= 0x00000800;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If false (default), the device will display the time in 24-hour format on screen.
         * If true, the device will display the time in 12-hour format on screen.
         * </pre>
         *
         * <code>bool use_12h_clock = 12;</code>
         * @return This builder for chaining.
         */
        public Builder clearUse12HClock() {
          bitField0_ = (bitField0_ & ~0x00000800);
          use12HClock_ = false;
          onChanged();
          return this;
        }

        private boolean useLongNodeName_ ;
        /**
         * <pre>
         *
         * If false (default), the device will use short names for various display screens.
         * If true, node names will show in long format
         * </pre>
         *
         * <code>bool use_long_node_name = 13;</code>
         * @return The useLongNodeName.
         */
        @java.lang.Override
        public boolean getUseLongNodeName() {
          return useLongNodeName_;
        }
        /**
         * <pre>
         *
         * If false (default), the device will use short names for various display screens.
         * If true, node names will show in long format
         * </pre>
         *
         * <code>bool use_long_node_name = 13;</code>
         * @param value The useLongNodeName to set.
         * @return This builder for chaining.
         */
        public Builder setUseLongNodeName(boolean value) {

          useLongNodeName_ = value;
          bitField0_ |= 0x00001000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If false (default), the device will use short names for various display screens.
         * If true, node names will show in long format
         * </pre>
         *
         * <code>bool use_long_node_name = 13;</code>
         * @return This builder for chaining.
         */
        public Builder clearUseLongNodeName() {
          bitField0_ = (bitField0_ & ~0x00001000);
          useLongNodeName_ = false;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.DisplayConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.DisplayConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.DisplayConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.DisplayConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.DisplayConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<DisplayConfig>
          PARSER = new com.google.protobuf.AbstractParser<DisplayConfig>() {
        @java.lang.Override
        public DisplayConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<DisplayConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<DisplayConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface LoRaConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.LoRaConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       *
       * When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
       * will be taked from their respective manually defined fields
       * </pre>
       *
       * <code>bool use_preset = 1;</code>
       * @return The usePreset.
       */
      boolean getUsePreset();

      /**
       * <pre>
       *
       * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
       * As a heuristic: If bandwidth is specified, do not use modem_config.
       * Because protobufs take ZERO space when the value is zero this works out nicely.
       * This value is replaced by bandwidth/spread_factor/coding_rate.
       * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
       * </pre>
       *
       * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
       * @return The enum numeric value on the wire for modemPreset.
       */
      int getModemPresetValue();
      /**
       * <pre>
       *
       * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
       * As a heuristic: If bandwidth is specified, do not use modem_config.
       * Because protobufs take ZERO space when the value is zero this works out nicely.
       * This value is replaced by bandwidth/spread_factor/coding_rate.
       * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
       * </pre>
       *
       * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
       * @return The modemPreset.
       */
      com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset getModemPreset();

      /**
       * <pre>
       *
       * Bandwidth in MHz
       * Certain bandwidth numbers are 'special' and will be converted to the
       * appropriate floating point value: 31 -&gt; 31.25MHz
       * </pre>
       *
       * <code>uint32 bandwidth = 3;</code>
       * @return The bandwidth.
       */
      int getBandwidth();

      /**
       * <pre>
       *
       * A number from 7 to 12.
       * Indicates number of chirps per symbol as 1&lt;&lt;spread_factor.
       * </pre>
       *
       * <code>uint32 spread_factor = 4;</code>
       * @return The spreadFactor.
       */
      int getSpreadFactor();

      /**
       * <pre>
       *
       * The denominator of the coding rate.
       * ie for 4/5, the value is 5. 4/8 the value is 8.
       * </pre>
       *
       * <code>uint32 coding_rate = 5;</code>
       * @return The codingRate.
       */
      int getCodingRate();

      /**
       * <pre>
       *
       * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
       * A frequency offset that is added to to the calculated band center frequency.
       * Used to correct for crystal calibration errors.
       * </pre>
       *
       * <code>float frequency_offset = 6;</code>
       * @return The frequencyOffset.
       */
      float getFrequencyOffset();

      /**
       * <pre>
       *
       * The region code for the radio (US, CN, EU433, etc...)
       * </pre>
       *
       * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
       * @return The enum numeric value on the wire for region.
       */
      int getRegionValue();
      /**
       * <pre>
       *
       * The region code for the radio (US, CN, EU433, etc...)
       * </pre>
       *
       * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
       * @return The region.
       */
      com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode getRegion();

      /**
       * <pre>
       *
       * Maximum number of hops. This can't be greater than 7.
       * Default of 3
       * Attempting to set a value &gt; 7 results in the default
       * </pre>
       *
       * <code>uint32 hop_limit = 8;</code>
       * @return The hopLimit.
       */
      int getHopLimit();

      /**
       * <pre>
       *
       * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
       * Defaults to false
       * </pre>
       *
       * <code>bool tx_enabled = 9;</code>
       * @return The txEnabled.
       */
      boolean getTxEnabled();

      /**
       * <pre>
       *
       * If zero, then use default max legal continuous power (ie. something that won't
       * burn out the radio hardware)
       * In most cases you should use zero here.
       * Units are in dBm.
       * </pre>
       *
       * <code>int32 tx_power = 10;</code>
       * @return The txPower.
       */
      int getTxPower();

      /**
       * <pre>
       *
       * This controls the actual hardware frequency the radio transmits on.
       * Most users should never need to be exposed to this field/concept.
       * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
       * If ZERO then the rule is "use the old channel name hash based
       * algorithm to derive the channel number")
       * If using the hash algorithm the channel number will be: hash(channel_name) %
       * NUM_CHANNELS (Where num channels depends on the regulatory region).
       * </pre>
       *
       * <code>uint32 channel_num = 11;</code>
       * @return The channelNum.
       */
      int getChannelNum();

      /**
       * <pre>
       *
       * If true, duty cycle limits will be exceeded and thus you're possibly not following
       * the local regulations if you're not a HAM.
       * Has no effect if the duty cycle of the used region is 100%.
       * </pre>
       *
       * <code>bool override_duty_cycle = 12;</code>
       * @return The overrideDutyCycle.
       */
      boolean getOverrideDutyCycle();

      /**
       * <pre>
       *
       * If true, sets RX boosted gain mode on SX126X based radios
       * </pre>
       *
       * <code>bool sx126x_rx_boosted_gain = 13;</code>
       * @return The sx126xRxBoostedGain.
       */
      boolean getSx126XRxBoostedGain();

      /**
       * <pre>
       *
       * This parameter is for advanced users and licensed HAM radio operators.
       * Ignore Channel Calculation and use this frequency instead. The frequency_offset
       * will still be applied. This will allow you to use out-of-band frequencies.
       * Please respect your local laws and regulations. If you are a HAM, make sure you
       * enable HAM mode and turn off encryption.
       * </pre>
       *
       * <code>float override_frequency = 14;</code>
       * @return The overrideFrequency.
       */
      float getOverrideFrequency();

      /**
       * <pre>
       *
       * If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
       * </pre>
       *
       * <code>bool pa_fan_disabled = 15;</code>
       * @return The paFanDisabled.
       */
      boolean getPaFanDisabled();

      /**
       * <pre>
       *
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @return A list containing the ignoreIncoming.
       */
      java.util.List<java.lang.Integer> getIgnoreIncomingList();
      /**
       * <pre>
       *
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @return The count of ignoreIncoming.
       */
      int getIgnoreIncomingCount();
      /**
       * <pre>
       *
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @param index The index of the element to return.
       * @return The ignoreIncoming at the given index.
       */
      int getIgnoreIncoming(int index);

      /**
       * <pre>
       *
       * If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
       * </pre>
       *
       * <code>bool ignore_mqtt = 104;</code>
       * @return The ignoreMqtt.
       */
      boolean getIgnoreMqtt();

      /**
       * <pre>
       *
       * Sets the ok_to_mqtt bit on outgoing packets
       * </pre>
       *
       * <code>bool config_ok_to_mqtt = 105;</code>
       * @return The configOkToMqtt.
       */
      boolean getConfigOkToMqtt();
    }
    /**
     * <pre>
     *
     * Lora Config
     * </pre>
     *
     * Protobuf type {@code meshtastic.Config.LoRaConfig}
     */
    public static final class LoRaConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.LoRaConfig)
        LoRaConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use LoRaConfig.newBuilder() to construct.
      private LoRaConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private LoRaConfig() {
        modemPreset_ = 0;
        region_ = 0;
        ignoreIncoming_ = emptyIntList();
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new LoRaConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_LoRaConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_LoRaConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.class, com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.Builder.class);
      }

      /**
       * Protobuf enum {@code meshtastic.Config.LoRaConfig.RegionCode}
       */
      public enum RegionCode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Region is not set
         * </pre>
         *
         * <code>UNSET = 0;</code>
         */
        UNSET(0),
        /**
         * <pre>
         *
         * United States
         * </pre>
         *
         * <code>US = 1;</code>
         */
        US(1),
        /**
         * <pre>
         *
         * European Union 433mhz
         * </pre>
         *
         * <code>EU_433 = 2;</code>
         */
        EU_433(2),
        /**
         * <pre>
         *
         * European Union 868mhz
         * </pre>
         *
         * <code>EU_868 = 3;</code>
         */
        EU_868(3),
        /**
         * <pre>
         *
         * China
         * </pre>
         *
         * <code>CN = 4;</code>
         */
        CN(4),
        /**
         * <pre>
         *
         * Japan
         * </pre>
         *
         * <code>JP = 5;</code>
         */
        JP(5),
        /**
         * <pre>
         *
         * Australia / New Zealand
         * </pre>
         *
         * <code>ANZ = 6;</code>
         */
        ANZ(6),
        /**
         * <pre>
         *
         * Korea
         * </pre>
         *
         * <code>KR = 7;</code>
         */
        KR(7),
        /**
         * <pre>
         *
         * Taiwan
         * </pre>
         *
         * <code>TW = 8;</code>
         */
        TW(8),
        /**
         * <pre>
         *
         * Russia
         * </pre>
         *
         * <code>RU = 9;</code>
         */
        RU(9),
        /**
         * <pre>
         *
         * India
         * </pre>
         *
         * <code>IN = 10;</code>
         */
        IN(10),
        /**
         * <pre>
         *
         * New Zealand 865mhz
         * </pre>
         *
         * <code>NZ_865 = 11;</code>
         */
        NZ_865(11),
        /**
         * <pre>
         *
         * Thailand
         * </pre>
         *
         * <code>TH = 12;</code>
         */
        TH(12),
        /**
         * <pre>
         *
         * WLAN Band
         * </pre>
         *
         * <code>LORA_24 = 13;</code>
         */
        LORA_24(13),
        /**
         * <pre>
         *
         * Ukraine 433mhz
         * </pre>
         *
         * <code>UA_433 = 14;</code>
         */
        UA_433(14),
        /**
         * <pre>
         *
         * Ukraine 868mhz
         * </pre>
         *
         * <code>UA_868 = 15;</code>
         */
        UA_868(15),
        /**
         * <pre>
         *
         * Malaysia 433mhz
         * </pre>
         *
         * <code>MY_433 = 16;</code>
         */
        MY_433(16),
        /**
         * <pre>
         *
         * Malaysia 919mhz
         * </pre>
         *
         * <code>MY_919 = 17;</code>
         */
        MY_919(17),
        /**
         * <pre>
         *
         * Singapore 923mhz
         * </pre>
         *
         * <code>SG_923 = 18;</code>
         */
        SG_923(18),
        /**
         * <pre>
         *
         * Philippines 433mhz
         * </pre>
         *
         * <code>PH_433 = 19;</code>
         */
        PH_433(19),
        /**
         * <pre>
         *
         * Philippines 868mhz
         * </pre>
         *
         * <code>PH_868 = 20;</code>
         */
        PH_868(20),
        /**
         * <pre>
         *
         * Philippines 915mhz
         * </pre>
         *
         * <code>PH_915 = 21;</code>
         */
        PH_915(21),
        /**
         * <pre>
         *
         * Australia / New Zealand 433MHz
         * </pre>
         *
         * <code>ANZ_433 = 22;</code>
         */
        ANZ_433(22),
        /**
         * <pre>
         *
         * Kazakhstan 433MHz
         * </pre>
         *
         * <code>KZ_433 = 23;</code>
         */
        KZ_433(23),
        /**
         * <pre>
         *
         * Kazakhstan 863MHz
         * </pre>
         *
         * <code>KZ_863 = 24;</code>
         */
        KZ_863(24),
        /**
         * <pre>
         *
         * Nepal 865MHz
         * </pre>
         *
         * <code>NP_865 = 25;</code>
         */
        NP_865(25),
        /**
         * <pre>
         *
         * Brazil 902MHz
         * </pre>
         *
         * <code>BR_902 = 26;</code>
         */
        BR_902(26),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Region is not set
         * </pre>
         *
         * <code>UNSET = 0;</code>
         */
        public static final int UNSET_VALUE = 0;
        /**
         * <pre>
         *
         * United States
         * </pre>
         *
         * <code>US = 1;</code>
         */
        public static final int US_VALUE = 1;
        /**
         * <pre>
         *
         * European Union 433mhz
         * </pre>
         *
         * <code>EU_433 = 2;</code>
         */
        public static final int EU_433_VALUE = 2;
        /**
         * <pre>
         *
         * European Union 868mhz
         * </pre>
         *
         * <code>EU_868 = 3;</code>
         */
        public static final int EU_868_VALUE = 3;
        /**
         * <pre>
         *
         * China
         * </pre>
         *
         * <code>CN = 4;</code>
         */
        public static final int CN_VALUE = 4;
        /**
         * <pre>
         *
         * Japan
         * </pre>
         *
         * <code>JP = 5;</code>
         */
        public static final int JP_VALUE = 5;
        /**
         * <pre>
         *
         * Australia / New Zealand
         * </pre>
         *
         * <code>ANZ = 6;</code>
         */
        public static final int ANZ_VALUE = 6;
        /**
         * <pre>
         *
         * Korea
         * </pre>
         *
         * <code>KR = 7;</code>
         */
        public static final int KR_VALUE = 7;
        /**
         * <pre>
         *
         * Taiwan
         * </pre>
         *
         * <code>TW = 8;</code>
         */
        public static final int TW_VALUE = 8;
        /**
         * <pre>
         *
         * Russia
         * </pre>
         *
         * <code>RU = 9;</code>
         */
        public static final int RU_VALUE = 9;
        /**
         * <pre>
         *
         * India
         * </pre>
         *
         * <code>IN = 10;</code>
         */
        public static final int IN_VALUE = 10;
        /**
         * <pre>
         *
         * New Zealand 865mhz
         * </pre>
         *
         * <code>NZ_865 = 11;</code>
         */
        public static final int NZ_865_VALUE = 11;
        /**
         * <pre>
         *
         * Thailand
         * </pre>
         *
         * <code>TH = 12;</code>
         */
        public static final int TH_VALUE = 12;
        /**
         * <pre>
         *
         * WLAN Band
         * </pre>
         *
         * <code>LORA_24 = 13;</code>
         */
        public static final int LORA_24_VALUE = 13;
        /**
         * <pre>
         *
         * Ukraine 433mhz
         * </pre>
         *
         * <code>UA_433 = 14;</code>
         */
        public static final int UA_433_VALUE = 14;
        /**
         * <pre>
         *
         * Ukraine 868mhz
         * </pre>
         *
         * <code>UA_868 = 15;</code>
         */
        public static final int UA_868_VALUE = 15;
        /**
         * <pre>
         *
         * Malaysia 433mhz
         * </pre>
         *
         * <code>MY_433 = 16;</code>
         */
        public static final int MY_433_VALUE = 16;
        /**
         * <pre>
         *
         * Malaysia 919mhz
         * </pre>
         *
         * <code>MY_919 = 17;</code>
         */
        public static final int MY_919_VALUE = 17;
        /**
         * <pre>
         *
         * Singapore 923mhz
         * </pre>
         *
         * <code>SG_923 = 18;</code>
         */
        public static final int SG_923_VALUE = 18;
        /**
         * <pre>
         *
         * Philippines 433mhz
         * </pre>
         *
         * <code>PH_433 = 19;</code>
         */
        public static final int PH_433_VALUE = 19;
        /**
         * <pre>
         *
         * Philippines 868mhz
         * </pre>
         *
         * <code>PH_868 = 20;</code>
         */
        public static final int PH_868_VALUE = 20;
        /**
         * <pre>
         *
         * Philippines 915mhz
         * </pre>
         *
         * <code>PH_915 = 21;</code>
         */
        public static final int PH_915_VALUE = 21;
        /**
         * <pre>
         *
         * Australia / New Zealand 433MHz
         * </pre>
         *
         * <code>ANZ_433 = 22;</code>
         */
        public static final int ANZ_433_VALUE = 22;
        /**
         * <pre>
         *
         * Kazakhstan 433MHz
         * </pre>
         *
         * <code>KZ_433 = 23;</code>
         */
        public static final int KZ_433_VALUE = 23;
        /**
         * <pre>
         *
         * Kazakhstan 863MHz
         * </pre>
         *
         * <code>KZ_863 = 24;</code>
         */
        public static final int KZ_863_VALUE = 24;
        /**
         * <pre>
         *
         * Nepal 865MHz
         * </pre>
         *
         * <code>NP_865 = 25;</code>
         */
        public static final int NP_865_VALUE = 25;
        /**
         * <pre>
         *
         * Brazil 902MHz
         * </pre>
         *
         * <code>BR_902 = 26;</code>
         */
        public static final int BR_902_VALUE = 26;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static RegionCode valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static RegionCode forNumber(int value) {
          switch (value) {
            case 0: return UNSET;
            case 1: return US;
            case 2: return EU_433;
            case 3: return EU_868;
            case 4: return CN;
            case 5: return JP;
            case 6: return ANZ;
            case 7: return KR;
            case 8: return TW;
            case 9: return RU;
            case 10: return IN;
            case 11: return NZ_865;
            case 12: return TH;
            case 13: return LORA_24;
            case 14: return UA_433;
            case 15: return UA_868;
            case 16: return MY_433;
            case 17: return MY_919;
            case 18: return SG_923;
            case 19: return PH_433;
            case 20: return PH_868;
            case 21: return PH_915;
            case 22: return ANZ_433;
            case 23: return KZ_433;
            case 24: return KZ_863;
            case 25: return NP_865;
            case 26: return BR_902;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<RegionCode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            RegionCode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<RegionCode>() {
                public RegionCode findValueByNumber(int number) {
                  return RegionCode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDescriptor().getEnumTypes().get(0);
        }

        private static final RegionCode[] VALUES = values();

        public static RegionCode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private RegionCode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.LoRaConfig.RegionCode)
      }

      /**
       * <pre>
       *
       * Standard predefined channel settings
       * Note: these mappings must match ModemPreset Choice in the device code.
       * </pre>
       *
       * Protobuf enum {@code meshtastic.Config.LoRaConfig.ModemPreset}
       */
      public enum ModemPreset
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Long Range - Fast
         * </pre>
         *
         * <code>LONG_FAST = 0;</code>
         */
        LONG_FAST(0),
        /**
         * <pre>
         *
         * Long Range - Slow
         * </pre>
         *
         * <code>LONG_SLOW = 1;</code>
         */
        LONG_SLOW(1),
        /**
         * <pre>
         *
         * Very Long Range - Slow
         * Deprecated in 2.5: Works only with txco and is unusably slow
         * </pre>
         *
         * <code>VERY_LONG_SLOW = 2 [deprecated = true];</code>
         */
        @java.lang.Deprecated
        VERY_LONG_SLOW(2),
        /**
         * <pre>
         *
         * Medium Range - Slow
         * </pre>
         *
         * <code>MEDIUM_SLOW = 3;</code>
         */
        MEDIUM_SLOW(3),
        /**
         * <pre>
         *
         * Medium Range - Fast
         * </pre>
         *
         * <code>MEDIUM_FAST = 4;</code>
         */
        MEDIUM_FAST(4),
        /**
         * <pre>
         *
         * Short Range - Slow
         * </pre>
         *
         * <code>SHORT_SLOW = 5;</code>
         */
        SHORT_SLOW(5),
        /**
         * <pre>
         *
         * Short Range - Fast
         * </pre>
         *
         * <code>SHORT_FAST = 6;</code>
         */
        SHORT_FAST(6),
        /**
         * <pre>
         *
         * Long Range - Moderately Fast
         * </pre>
         *
         * <code>LONG_MODERATE = 7;</code>
         */
        LONG_MODERATE(7),
        /**
         * <pre>
         *
         * Short Range - Turbo
         * This is the fastest preset and the only one with 500kHz bandwidth.
         * It is not legal to use in all regions due to this wider bandwidth.
         * </pre>
         *
         * <code>SHORT_TURBO = 8;</code>
         */
        SHORT_TURBO(8),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Long Range - Fast
         * </pre>
         *
         * <code>LONG_FAST = 0;</code>
         */
        public static final int LONG_FAST_VALUE = 0;
        /**
         * <pre>
         *
         * Long Range - Slow
         * </pre>
         *
         * <code>LONG_SLOW = 1;</code>
         */
        public static final int LONG_SLOW_VALUE = 1;
        /**
         * <pre>
         *
         * Very Long Range - Slow
         * Deprecated in 2.5: Works only with txco and is unusably slow
         * </pre>
         *
         * <code>VERY_LONG_SLOW = 2 [deprecated = true];</code>
         */
        @java.lang.Deprecated public static final int VERY_LONG_SLOW_VALUE = 2;
        /**
         * <pre>
         *
         * Medium Range - Slow
         * </pre>
         *
         * <code>MEDIUM_SLOW = 3;</code>
         */
        public static final int MEDIUM_SLOW_VALUE = 3;
        /**
         * <pre>
         *
         * Medium Range - Fast
         * </pre>
         *
         * <code>MEDIUM_FAST = 4;</code>
         */
        public static final int MEDIUM_FAST_VALUE = 4;
        /**
         * <pre>
         *
         * Short Range - Slow
         * </pre>
         *
         * <code>SHORT_SLOW = 5;</code>
         */
        public static final int SHORT_SLOW_VALUE = 5;
        /**
         * <pre>
         *
         * Short Range - Fast
         * </pre>
         *
         * <code>SHORT_FAST = 6;</code>
         */
        public static final int SHORT_FAST_VALUE = 6;
        /**
         * <pre>
         *
         * Long Range - Moderately Fast
         * </pre>
         *
         * <code>LONG_MODERATE = 7;</code>
         */
        public static final int LONG_MODERATE_VALUE = 7;
        /**
         * <pre>
         *
         * Short Range - Turbo
         * This is the fastest preset and the only one with 500kHz bandwidth.
         * It is not legal to use in all regions due to this wider bandwidth.
         * </pre>
         *
         * <code>SHORT_TURBO = 8;</code>
         */
        public static final int SHORT_TURBO_VALUE = 8;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static ModemPreset valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static ModemPreset forNumber(int value) {
          switch (value) {
            case 0: return LONG_FAST;
            case 1: return LONG_SLOW;
            case 2: return VERY_LONG_SLOW;
            case 3: return MEDIUM_SLOW;
            case 4: return MEDIUM_FAST;
            case 5: return SHORT_SLOW;
            case 6: return SHORT_FAST;
            case 7: return LONG_MODERATE;
            case 8: return SHORT_TURBO;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<ModemPreset>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            ModemPreset> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<ModemPreset>() {
                public ModemPreset findValueByNumber(int number) {
                  return ModemPreset.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDescriptor().getEnumTypes().get(1);
        }

        private static final ModemPreset[] VALUES = values();

        public static ModemPreset valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private ModemPreset(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.LoRaConfig.ModemPreset)
      }

      public static final int USE_PRESET_FIELD_NUMBER = 1;
      private boolean usePreset_ = false;
      /**
       * <pre>
       *
       * When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
       * will be taked from their respective manually defined fields
       * </pre>
       *
       * <code>bool use_preset = 1;</code>
       * @return The usePreset.
       */
      @java.lang.Override
      public boolean getUsePreset() {
        return usePreset_;
      }

      public static final int MODEM_PRESET_FIELD_NUMBER = 2;
      private int modemPreset_ = 0;
      /**
       * <pre>
       *
       * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
       * As a heuristic: If bandwidth is specified, do not use modem_config.
       * Because protobufs take ZERO space when the value is zero this works out nicely.
       * This value is replaced by bandwidth/spread_factor/coding_rate.
       * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
       * </pre>
       *
       * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
       * @return The enum numeric value on the wire for modemPreset.
       */
      @java.lang.Override public int getModemPresetValue() {
        return modemPreset_;
      }
      /**
       * <pre>
       *
       * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
       * As a heuristic: If bandwidth is specified, do not use modem_config.
       * Because protobufs take ZERO space when the value is zero this works out nicely.
       * This value is replaced by bandwidth/spread_factor/coding_rate.
       * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
       * </pre>
       *
       * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
       * @return The modemPreset.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset getModemPreset() {
        com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset result = com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset.forNumber(modemPreset_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset.UNRECOGNIZED : result;
      }

      public static final int BANDWIDTH_FIELD_NUMBER = 3;
      private int bandwidth_ = 0;
      /**
       * <pre>
       *
       * Bandwidth in MHz
       * Certain bandwidth numbers are 'special' and will be converted to the
       * appropriate floating point value: 31 -&gt; 31.25MHz
       * </pre>
       *
       * <code>uint32 bandwidth = 3;</code>
       * @return The bandwidth.
       */
      @java.lang.Override
      public int getBandwidth() {
        return bandwidth_;
      }

      public static final int SPREAD_FACTOR_FIELD_NUMBER = 4;
      private int spreadFactor_ = 0;
      /**
       * <pre>
       *
       * A number from 7 to 12.
       * Indicates number of chirps per symbol as 1&lt;&lt;spread_factor.
       * </pre>
       *
       * <code>uint32 spread_factor = 4;</code>
       * @return The spreadFactor.
       */
      @java.lang.Override
      public int getSpreadFactor() {
        return spreadFactor_;
      }

      public static final int CODING_RATE_FIELD_NUMBER = 5;
      private int codingRate_ = 0;
      /**
       * <pre>
       *
       * The denominator of the coding rate.
       * ie for 4/5, the value is 5. 4/8 the value is 8.
       * </pre>
       *
       * <code>uint32 coding_rate = 5;</code>
       * @return The codingRate.
       */
      @java.lang.Override
      public int getCodingRate() {
        return codingRate_;
      }

      public static final int FREQUENCY_OFFSET_FIELD_NUMBER = 6;
      private float frequencyOffset_ = 0F;
      /**
       * <pre>
       *
       * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
       * A frequency offset that is added to to the calculated band center frequency.
       * Used to correct for crystal calibration errors.
       * </pre>
       *
       * <code>float frequency_offset = 6;</code>
       * @return The frequencyOffset.
       */
      @java.lang.Override
      public float getFrequencyOffset() {
        return frequencyOffset_;
      }

      public static final int REGION_FIELD_NUMBER = 7;
      private int region_ = 0;
      /**
       * <pre>
       *
       * The region code for the radio (US, CN, EU433, etc...)
       * </pre>
       *
       * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
       * @return The enum numeric value on the wire for region.
       */
      @java.lang.Override public int getRegionValue() {
        return region_;
      }
      /**
       * <pre>
       *
       * The region code for the radio (US, CN, EU433, etc...)
       * </pre>
       *
       * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
       * @return The region.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode getRegion() {
        com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode result = com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode.forNumber(region_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode.UNRECOGNIZED : result;
      }

      public static final int HOP_LIMIT_FIELD_NUMBER = 8;
      private int hopLimit_ = 0;
      /**
       * <pre>
       *
       * Maximum number of hops. This can't be greater than 7.
       * Default of 3
       * Attempting to set a value &gt; 7 results in the default
       * </pre>
       *
       * <code>uint32 hop_limit = 8;</code>
       * @return The hopLimit.
       */
      @java.lang.Override
      public int getHopLimit() {
        return hopLimit_;
      }

      public static final int TX_ENABLED_FIELD_NUMBER = 9;
      private boolean txEnabled_ = false;
      /**
       * <pre>
       *
       * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
       * Defaults to false
       * </pre>
       *
       * <code>bool tx_enabled = 9;</code>
       * @return The txEnabled.
       */
      @java.lang.Override
      public boolean getTxEnabled() {
        return txEnabled_;
      }

      public static final int TX_POWER_FIELD_NUMBER = 10;
      private int txPower_ = 0;
      /**
       * <pre>
       *
       * If zero, then use default max legal continuous power (ie. something that won't
       * burn out the radio hardware)
       * In most cases you should use zero here.
       * Units are in dBm.
       * </pre>
       *
       * <code>int32 tx_power = 10;</code>
       * @return The txPower.
       */
      @java.lang.Override
      public int getTxPower() {
        return txPower_;
      }

      public static final int CHANNEL_NUM_FIELD_NUMBER = 11;
      private int channelNum_ = 0;
      /**
       * <pre>
       *
       * This controls the actual hardware frequency the radio transmits on.
       * Most users should never need to be exposed to this field/concept.
       * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
       * If ZERO then the rule is "use the old channel name hash based
       * algorithm to derive the channel number")
       * If using the hash algorithm the channel number will be: hash(channel_name) %
       * NUM_CHANNELS (Where num channels depends on the regulatory region).
       * </pre>
       *
       * <code>uint32 channel_num = 11;</code>
       * @return The channelNum.
       */
      @java.lang.Override
      public int getChannelNum() {
        return channelNum_;
      }

      public static final int OVERRIDE_DUTY_CYCLE_FIELD_NUMBER = 12;
      private boolean overrideDutyCycle_ = false;
      /**
       * <pre>
       *
       * If true, duty cycle limits will be exceeded and thus you're possibly not following
       * the local regulations if you're not a HAM.
       * Has no effect if the duty cycle of the used region is 100%.
       * </pre>
       *
       * <code>bool override_duty_cycle = 12;</code>
       * @return The overrideDutyCycle.
       */
      @java.lang.Override
      public boolean getOverrideDutyCycle() {
        return overrideDutyCycle_;
      }

      public static final int SX126X_RX_BOOSTED_GAIN_FIELD_NUMBER = 13;
      private boolean sx126XRxBoostedGain_ = false;
      /**
       * <pre>
       *
       * If true, sets RX boosted gain mode on SX126X based radios
       * </pre>
       *
       * <code>bool sx126x_rx_boosted_gain = 13;</code>
       * @return The sx126xRxBoostedGain.
       */
      @java.lang.Override
      public boolean getSx126XRxBoostedGain() {
        return sx126XRxBoostedGain_;
      }

      public static final int OVERRIDE_FREQUENCY_FIELD_NUMBER = 14;
      private float overrideFrequency_ = 0F;
      /**
       * <pre>
       *
       * This parameter is for advanced users and licensed HAM radio operators.
       * Ignore Channel Calculation and use this frequency instead. The frequency_offset
       * will still be applied. This will allow you to use out-of-band frequencies.
       * Please respect your local laws and regulations. If you are a HAM, make sure you
       * enable HAM mode and turn off encryption.
       * </pre>
       *
       * <code>float override_frequency = 14;</code>
       * @return The overrideFrequency.
       */
      @java.lang.Override
      public float getOverrideFrequency() {
        return overrideFrequency_;
      }

      public static final int PA_FAN_DISABLED_FIELD_NUMBER = 15;
      private boolean paFanDisabled_ = false;
      /**
       * <pre>
       *
       * If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
       * </pre>
       *
       * <code>bool pa_fan_disabled = 15;</code>
       * @return The paFanDisabled.
       */
      @java.lang.Override
      public boolean getPaFanDisabled() {
        return paFanDisabled_;
      }

      public static final int IGNORE_INCOMING_FIELD_NUMBER = 103;
      @SuppressWarnings("serial")
      private com.google.protobuf.Internal.IntList ignoreIncoming_ =
          emptyIntList();
      /**
       * <pre>
       *
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @return A list containing the ignoreIncoming.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getIgnoreIncomingList() {
        return ignoreIncoming_;
      }
      /**
       * <pre>
       *
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @return The count of ignoreIncoming.
       */
      public int getIgnoreIncomingCount() {
        return ignoreIncoming_.size();
      }
      /**
       * <pre>
       *
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @param index The index of the element to return.
       * @return The ignoreIncoming at the given index.
       */
      public int getIgnoreIncoming(int index) {
        return ignoreIncoming_.getInt(index);
      }
      private int ignoreIncomingMemoizedSerializedSize = -1;

      public static final int IGNORE_MQTT_FIELD_NUMBER = 104;
      private boolean ignoreMqtt_ = false;
      /**
       * <pre>
       *
       * If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
       * </pre>
       *
       * <code>bool ignore_mqtt = 104;</code>
       * @return The ignoreMqtt.
       */
      @java.lang.Override
      public boolean getIgnoreMqtt() {
        return ignoreMqtt_;
      }

      public static final int CONFIG_OK_TO_MQTT_FIELD_NUMBER = 105;
      private boolean configOkToMqtt_ = false;
      /**
       * <pre>
       *
       * Sets the ok_to_mqtt bit on outgoing packets
       * </pre>
       *
       * <code>bool config_ok_to_mqtt = 105;</code>
       * @return The configOkToMqtt.
       */
      @java.lang.Override
      public boolean getConfigOkToMqtt() {
        return configOkToMqtt_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getSerializedSize();
        if (usePreset_ != false) {
          output.writeBool(1, usePreset_);
        }
        if (modemPreset_ != com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset.LONG_FAST.getNumber()) {
          output.writeEnum(2, modemPreset_);
        }
        if (bandwidth_ != 0) {
          output.writeUInt32(3, bandwidth_);
        }
        if (spreadFactor_ != 0) {
          output.writeUInt32(4, spreadFactor_);
        }
        if (codingRate_ != 0) {
          output.writeUInt32(5, codingRate_);
        }
        if (java.lang.Float.floatToRawIntBits(frequencyOffset_) != 0) {
          output.writeFloat(6, frequencyOffset_);
        }
        if (region_ != com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode.UNSET.getNumber()) {
          output.writeEnum(7, region_);
        }
        if (hopLimit_ != 0) {
          output.writeUInt32(8, hopLimit_);
        }
        if (txEnabled_ != false) {
          output.writeBool(9, txEnabled_);
        }
        if (txPower_ != 0) {
          output.writeInt32(10, txPower_);
        }
        if (channelNum_ != 0) {
          output.writeUInt32(11, channelNum_);
        }
        if (overrideDutyCycle_ != false) {
          output.writeBool(12, overrideDutyCycle_);
        }
        if (sx126XRxBoostedGain_ != false) {
          output.writeBool(13, sx126XRxBoostedGain_);
        }
        if (java.lang.Float.floatToRawIntBits(overrideFrequency_) != 0) {
          output.writeFloat(14, overrideFrequency_);
        }
        if (paFanDisabled_ != false) {
          output.writeBool(15, paFanDisabled_);
        }
        if (getIgnoreIncomingList().size() > 0) {
          output.writeUInt32NoTag(826);
          output.writeUInt32NoTag(ignoreIncomingMemoizedSerializedSize);
        }
        for (int i = 0; i < ignoreIncoming_.size(); i++) {
          output.writeUInt32NoTag(ignoreIncoming_.getInt(i));
        }
        if (ignoreMqtt_ != false) {
          output.writeBool(104, ignoreMqtt_);
        }
        if (configOkToMqtt_ != false) {
          output.writeBool(105, configOkToMqtt_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (usePreset_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, usePreset_);
        }
        if (modemPreset_ != com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset.LONG_FAST.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(2, modemPreset_);
        }
        if (bandwidth_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(3, bandwidth_);
        }
        if (spreadFactor_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(4, spreadFactor_);
        }
        if (codingRate_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(5, codingRate_);
        }
        if (java.lang.Float.floatToRawIntBits(frequencyOffset_) != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(6, frequencyOffset_);
        }
        if (region_ != com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode.UNSET.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(7, region_);
        }
        if (hopLimit_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(8, hopLimit_);
        }
        if (txEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(9, txEnabled_);
        }
        if (txPower_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(10, txPower_);
        }
        if (channelNum_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(11, channelNum_);
        }
        if (overrideDutyCycle_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(12, overrideDutyCycle_);
        }
        if (sx126XRxBoostedGain_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(13, sx126XRxBoostedGain_);
        }
        if (java.lang.Float.floatToRawIntBits(overrideFrequency_) != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(14, overrideFrequency_);
        }
        if (paFanDisabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(15, paFanDisabled_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < ignoreIncoming_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeUInt32SizeNoTag(ignoreIncoming_.getInt(i));
          }
          size += dataSize;
          if (!getIgnoreIncomingList().isEmpty()) {
            size += 2;
            size += com.google.protobuf.CodedOutputStream
                .computeInt32SizeNoTag(dataSize);
          }
          ignoreIncomingMemoizedSerializedSize = dataSize;
        }
        if (ignoreMqtt_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(104, ignoreMqtt_);
        }
        if (configOkToMqtt_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(105, configOkToMqtt_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.LoRaConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.LoRaConfig other = (com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) obj;

        if (getUsePreset()
            != other.getUsePreset()) return false;
        if (modemPreset_ != other.modemPreset_) return false;
        if (getBandwidth()
            != other.getBandwidth()) return false;
        if (getSpreadFactor()
            != other.getSpreadFactor()) return false;
        if (getCodingRate()
            != other.getCodingRate()) return false;
        if (java.lang.Float.floatToIntBits(getFrequencyOffset())
            != java.lang.Float.floatToIntBits(
                other.getFrequencyOffset())) return false;
        if (region_ != other.region_) return false;
        if (getHopLimit()
            != other.getHopLimit()) return false;
        if (getTxEnabled()
            != other.getTxEnabled()) return false;
        if (getTxPower()
            != other.getTxPower()) return false;
        if (getChannelNum()
            != other.getChannelNum()) return false;
        if (getOverrideDutyCycle()
            != other.getOverrideDutyCycle()) return false;
        if (getSx126XRxBoostedGain()
            != other.getSx126XRxBoostedGain()) return false;
        if (java.lang.Float.floatToIntBits(getOverrideFrequency())
            != java.lang.Float.floatToIntBits(
                other.getOverrideFrequency())) return false;
        if (getPaFanDisabled()
            != other.getPaFanDisabled()) return false;
        if (!getIgnoreIncomingList()
            .equals(other.getIgnoreIncomingList())) return false;
        if (getIgnoreMqtt()
            != other.getIgnoreMqtt()) return false;
        if (getConfigOkToMqtt()
            != other.getConfigOkToMqtt()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + USE_PRESET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUsePreset());
        hash = (37 * hash) + MODEM_PRESET_FIELD_NUMBER;
        hash = (53 * hash) + modemPreset_;
        hash = (37 * hash) + BANDWIDTH_FIELD_NUMBER;
        hash = (53 * hash) + getBandwidth();
        hash = (37 * hash) + SPREAD_FACTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSpreadFactor();
        hash = (37 * hash) + CODING_RATE_FIELD_NUMBER;
        hash = (53 * hash) + getCodingRate();
        hash = (37 * hash) + FREQUENCY_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFrequencyOffset());
        hash = (37 * hash) + REGION_FIELD_NUMBER;
        hash = (53 * hash) + region_;
        hash = (37 * hash) + HOP_LIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getHopLimit();
        hash = (37 * hash) + TX_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getTxEnabled());
        hash = (37 * hash) + TX_POWER_FIELD_NUMBER;
        hash = (53 * hash) + getTxPower();
        hash = (37 * hash) + CHANNEL_NUM_FIELD_NUMBER;
        hash = (53 * hash) + getChannelNum();
        hash = (37 * hash) + OVERRIDE_DUTY_CYCLE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getOverrideDutyCycle());
        hash = (37 * hash) + SX126X_RX_BOOSTED_GAIN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSx126XRxBoostedGain());
        hash = (37 * hash) + OVERRIDE_FREQUENCY_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getOverrideFrequency());
        hash = (37 * hash) + PA_FAN_DISABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPaFanDisabled());
        if (getIgnoreIncomingCount() > 0) {
          hash = (37 * hash) + IGNORE_INCOMING_FIELD_NUMBER;
          hash = (53 * hash) + getIgnoreIncomingList().hashCode();
        }
        hash = (37 * hash) + IGNORE_MQTT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIgnoreMqtt());
        hash = (37 * hash) + CONFIG_OK_TO_MQTT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getConfigOkToMqtt());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.LoRaConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       *
       * Lora Config
       * </pre>
       *
       * Protobuf type {@code meshtastic.Config.LoRaConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.LoRaConfig)
          com.geeksville.mesh.ConfigProtos.Config.LoRaConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_LoRaConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_LoRaConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.class, com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          usePreset_ = false;
          modemPreset_ = 0;
          bandwidth_ = 0;
          spreadFactor_ = 0;
          codingRate_ = 0;
          frequencyOffset_ = 0F;
          region_ = 0;
          hopLimit_ = 0;
          txEnabled_ = false;
          txPower_ = 0;
          channelNum_ = 0;
          overrideDutyCycle_ = false;
          sx126XRxBoostedGain_ = false;
          overrideFrequency_ = 0F;
          paFanDisabled_ = false;
          ignoreIncoming_ = emptyIntList();
          ignoreMqtt_ = false;
          configOkToMqtt_ = false;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_LoRaConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.LoRaConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.LoRaConfig result = new com.geeksville.mesh.ConfigProtos.Config.LoRaConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.LoRaConfig result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.usePreset_ = usePreset_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.modemPreset_ = modemPreset_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.bandwidth_ = bandwidth_;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.spreadFactor_ = spreadFactor_;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.codingRate_ = codingRate_;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.frequencyOffset_ = frequencyOffset_;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.region_ = region_;
          }
          if (((from_bitField0_ & 0x00000080) != 0)) {
            result.hopLimit_ = hopLimit_;
          }
          if (((from_bitField0_ & 0x00000100) != 0)) {
            result.txEnabled_ = txEnabled_;
          }
          if (((from_bitField0_ & 0x00000200) != 0)) {
            result.txPower_ = txPower_;
          }
          if (((from_bitField0_ & 0x00000400) != 0)) {
            result.channelNum_ = channelNum_;
          }
          if (((from_bitField0_ & 0x00000800) != 0)) {
            result.overrideDutyCycle_ = overrideDutyCycle_;
          }
          if (((from_bitField0_ & 0x00001000) != 0)) {
            result.sx126XRxBoostedGain_ = sx126XRxBoostedGain_;
          }
          if (((from_bitField0_ & 0x00002000) != 0)) {
            result.overrideFrequency_ = overrideFrequency_;
          }
          if (((from_bitField0_ & 0x00004000) != 0)) {
            result.paFanDisabled_ = paFanDisabled_;
          }
          if (((from_bitField0_ & 0x00008000) != 0)) {
            ignoreIncoming_.makeImmutable();
            result.ignoreIncoming_ = ignoreIncoming_;
          }
          if (((from_bitField0_ & 0x00010000) != 0)) {
            result.ignoreMqtt_ = ignoreMqtt_;
          }
          if (((from_bitField0_ & 0x00020000) != 0)) {
            result.configOkToMqtt_ = configOkToMqtt_;
          }
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.LoRaConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.LoRaConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance()) return this;
          if (other.getUsePreset() != false) {
            setUsePreset(other.getUsePreset());
          }
          if (other.modemPreset_ != 0) {
            setModemPresetValue(other.getModemPresetValue());
          }
          if (other.getBandwidth() != 0) {
            setBandwidth(other.getBandwidth());
          }
          if (other.getSpreadFactor() != 0) {
            setSpreadFactor(other.getSpreadFactor());
          }
          if (other.getCodingRate() != 0) {
            setCodingRate(other.getCodingRate());
          }
          if (other.getFrequencyOffset() != 0F) {
            setFrequencyOffset(other.getFrequencyOffset());
          }
          if (other.region_ != 0) {
            setRegionValue(other.getRegionValue());
          }
          if (other.getHopLimit() != 0) {
            setHopLimit(other.getHopLimit());
          }
          if (other.getTxEnabled() != false) {
            setTxEnabled(other.getTxEnabled());
          }
          if (other.getTxPower() != 0) {
            setTxPower(other.getTxPower());
          }
          if (other.getChannelNum() != 0) {
            setChannelNum(other.getChannelNum());
          }
          if (other.getOverrideDutyCycle() != false) {
            setOverrideDutyCycle(other.getOverrideDutyCycle());
          }
          if (other.getSx126XRxBoostedGain() != false) {
            setSx126XRxBoostedGain(other.getSx126XRxBoostedGain());
          }
          if (other.getOverrideFrequency() != 0F) {
            setOverrideFrequency(other.getOverrideFrequency());
          }
          if (other.getPaFanDisabled() != false) {
            setPaFanDisabled(other.getPaFanDisabled());
          }
          if (!other.ignoreIncoming_.isEmpty()) {
            if (ignoreIncoming_.isEmpty()) {
              ignoreIncoming_ = other.ignoreIncoming_;
              ignoreIncoming_.makeImmutable();
              bitField0_ |= 0x00008000;
            } else {
              ensureIgnoreIncomingIsMutable();
              ignoreIncoming_.addAll(other.ignoreIncoming_);
            }
            onChanged();
          }
          if (other.getIgnoreMqtt() != false) {
            setIgnoreMqtt(other.getIgnoreMqtt());
          }
          if (other.getConfigOkToMqtt() != false) {
            setConfigOkToMqtt(other.getConfigOkToMqtt());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  usePreset_ = input.readBool();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  modemPreset_ = input.readEnum();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 24: {
                  bandwidth_ = input.readUInt32();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 24
                case 32: {
                  spreadFactor_ = input.readUInt32();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
                case 40: {
                  codingRate_ = input.readUInt32();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 40
                case 53: {
                  frequencyOffset_ = input.readFloat();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 53
                case 56: {
                  region_ = input.readEnum();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 56
                case 64: {
                  hopLimit_ = input.readUInt32();
                  bitField0_ |= 0x00000080;
                  break;
                } // case 64
                case 72: {
                  txEnabled_ = input.readBool();
                  bitField0_ |= 0x00000100;
                  break;
                } // case 72
                case 80: {
                  txPower_ = input.readInt32();
                  bitField0_ |= 0x00000200;
                  break;
                } // case 80
                case 88: {
                  channelNum_ = input.readUInt32();
                  bitField0_ |= 0x00000400;
                  break;
                } // case 88
                case 96: {
                  overrideDutyCycle_ = input.readBool();
                  bitField0_ |= 0x00000800;
                  break;
                } // case 96
                case 104: {
                  sx126XRxBoostedGain_ = input.readBool();
                  bitField0_ |= 0x00001000;
                  break;
                } // case 104
                case 117: {
                  overrideFrequency_ = input.readFloat();
                  bitField0_ |= 0x00002000;
                  break;
                } // case 117
                case 120: {
                  paFanDisabled_ = input.readBool();
                  bitField0_ |= 0x00004000;
                  break;
                } // case 120
                case 824: {
                  int v = input.readUInt32();
                  ensureIgnoreIncomingIsMutable();
                  ignoreIncoming_.addInt(v);
                  break;
                } // case 824
                case 826: {
                  int length = input.readRawVarint32();
                  int limit = input.pushLimit(length);
                  ensureIgnoreIncomingIsMutable();
                  while (input.getBytesUntilLimit() > 0) {
                    ignoreIncoming_.addInt(input.readUInt32());
                  }
                  input.popLimit(limit);
                  break;
                } // case 826
                case 832: {
                  ignoreMqtt_ = input.readBool();
                  bitField0_ |= 0x00010000;
                  break;
                } // case 832
                case 840: {
                  configOkToMqtt_ = input.readBool();
                  bitField0_ |= 0x00020000;
                  break;
                } // case 840
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private boolean usePreset_ ;
        /**
         * <pre>
         *
         * When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
         * will be taked from their respective manually defined fields
         * </pre>
         *
         * <code>bool use_preset = 1;</code>
         * @return The usePreset.
         */
        @java.lang.Override
        public boolean getUsePreset() {
          return usePreset_;
        }
        /**
         * <pre>
         *
         * When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
         * will be taked from their respective manually defined fields
         * </pre>
         *
         * <code>bool use_preset = 1;</code>
         * @param value The usePreset to set.
         * @return This builder for chaining.
         */
        public Builder setUsePreset(boolean value) {

          usePreset_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
         * will be taked from their respective manually defined fields
         * </pre>
         *
         * <code>bool use_preset = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearUsePreset() {
          bitField0_ = (bitField0_ & ~0x00000001);
          usePreset_ = false;
          onChanged();
          return this;
        }

        private int modemPreset_ = 0;
        /**
         * <pre>
         *
         * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
         * As a heuristic: If bandwidth is specified, do not use modem_config.
         * Because protobufs take ZERO space when the value is zero this works out nicely.
         * This value is replaced by bandwidth/spread_factor/coding_rate.
         * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
         * @return The enum numeric value on the wire for modemPreset.
         */
        @java.lang.Override public int getModemPresetValue() {
          return modemPreset_;
        }
        /**
         * <pre>
         *
         * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
         * As a heuristic: If bandwidth is specified, do not use modem_config.
         * Because protobufs take ZERO space when the value is zero this works out nicely.
         * This value is replaced by bandwidth/spread_factor/coding_rate.
         * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
         * @param value The enum numeric value on the wire for modemPreset to set.
         * @return This builder for chaining.
         */
        public Builder setModemPresetValue(int value) {
          modemPreset_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
         * As a heuristic: If bandwidth is specified, do not use modem_config.
         * Because protobufs take ZERO space when the value is zero this works out nicely.
         * This value is replaced by bandwidth/spread_factor/coding_rate.
         * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
         * @return The modemPreset.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset getModemPreset() {
          com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset result = com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset.forNumber(modemPreset_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
         * As a heuristic: If bandwidth is specified, do not use modem_config.
         * Because protobufs take ZERO space when the value is zero this works out nicely.
         * This value is replaced by bandwidth/spread_factor/coding_rate.
         * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
         * @param value The modemPreset to set.
         * @return This builder for chaining.
         */
        public Builder setModemPreset(com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.ModemPreset value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000002;
          modemPreset_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
         * As a heuristic: If bandwidth is specified, do not use modem_config.
         * Because protobufs take ZERO space when the value is zero this works out nicely.
         * This value is replaced by bandwidth/spread_factor/coding_rate.
         * If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearModemPreset() {
          bitField0_ = (bitField0_ & ~0x00000002);
          modemPreset_ = 0;
          onChanged();
          return this;
        }

        private int bandwidth_ ;
        /**
         * <pre>
         *
         * Bandwidth in MHz
         * Certain bandwidth numbers are 'special' and will be converted to the
         * appropriate floating point value: 31 -&gt; 31.25MHz
         * </pre>
         *
         * <code>uint32 bandwidth = 3;</code>
         * @return The bandwidth.
         */
        @java.lang.Override
        public int getBandwidth() {
          return bandwidth_;
        }
        /**
         * <pre>
         *
         * Bandwidth in MHz
         * Certain bandwidth numbers are 'special' and will be converted to the
         * appropriate floating point value: 31 -&gt; 31.25MHz
         * </pre>
         *
         * <code>uint32 bandwidth = 3;</code>
         * @param value The bandwidth to set.
         * @return This builder for chaining.
         */
        public Builder setBandwidth(int value) {

          bandwidth_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Bandwidth in MHz
         * Certain bandwidth numbers are 'special' and will be converted to the
         * appropriate floating point value: 31 -&gt; 31.25MHz
         * </pre>
         *
         * <code>uint32 bandwidth = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearBandwidth() {
          bitField0_ = (bitField0_ & ~0x00000004);
          bandwidth_ = 0;
          onChanged();
          return this;
        }

        private int spreadFactor_ ;
        /**
         * <pre>
         *
         * A number from 7 to 12.
         * Indicates number of chirps per symbol as 1&lt;&lt;spread_factor.
         * </pre>
         *
         * <code>uint32 spread_factor = 4;</code>
         * @return The spreadFactor.
         */
        @java.lang.Override
        public int getSpreadFactor() {
          return spreadFactor_;
        }
        /**
         * <pre>
         *
         * A number from 7 to 12.
         * Indicates number of chirps per symbol as 1&lt;&lt;spread_factor.
         * </pre>
         *
         * <code>uint32 spread_factor = 4;</code>
         * @param value The spreadFactor to set.
         * @return This builder for chaining.
         */
        public Builder setSpreadFactor(int value) {

          spreadFactor_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * A number from 7 to 12.
         * Indicates number of chirps per symbol as 1&lt;&lt;spread_factor.
         * </pre>
         *
         * <code>uint32 spread_factor = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearSpreadFactor() {
          bitField0_ = (bitField0_ & ~0x00000008);
          spreadFactor_ = 0;
          onChanged();
          return this;
        }

        private int codingRate_ ;
        /**
         * <pre>
         *
         * The denominator of the coding rate.
         * ie for 4/5, the value is 5. 4/8 the value is 8.
         * </pre>
         *
         * <code>uint32 coding_rate = 5;</code>
         * @return The codingRate.
         */
        @java.lang.Override
        public int getCodingRate() {
          return codingRate_;
        }
        /**
         * <pre>
         *
         * The denominator of the coding rate.
         * ie for 4/5, the value is 5. 4/8 the value is 8.
         * </pre>
         *
         * <code>uint32 coding_rate = 5;</code>
         * @param value The codingRate to set.
         * @return This builder for chaining.
         */
        public Builder setCodingRate(int value) {

          codingRate_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The denominator of the coding rate.
         * ie for 4/5, the value is 5. 4/8 the value is 8.
         * </pre>
         *
         * <code>uint32 coding_rate = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearCodingRate() {
          bitField0_ = (bitField0_ & ~0x00000010);
          codingRate_ = 0;
          onChanged();
          return this;
        }

        private float frequencyOffset_ ;
        /**
         * <pre>
         *
         * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
         * A frequency offset that is added to to the calculated band center frequency.
         * Used to correct for crystal calibration errors.
         * </pre>
         *
         * <code>float frequency_offset = 6;</code>
         * @return The frequencyOffset.
         */
        @java.lang.Override
        public float getFrequencyOffset() {
          return frequencyOffset_;
        }
        /**
         * <pre>
         *
         * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
         * A frequency offset that is added to to the calculated band center frequency.
         * Used to correct for crystal calibration errors.
         * </pre>
         *
         * <code>float frequency_offset = 6;</code>
         * @param value The frequencyOffset to set.
         * @return This builder for chaining.
         */
        public Builder setFrequencyOffset(float value) {

          frequencyOffset_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
         * A frequency offset that is added to to the calculated band center frequency.
         * Used to correct for crystal calibration errors.
         * </pre>
         *
         * <code>float frequency_offset = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearFrequencyOffset() {
          bitField0_ = (bitField0_ & ~0x00000020);
          frequencyOffset_ = 0F;
          onChanged();
          return this;
        }

        private int region_ = 0;
        /**
         * <pre>
         *
         * The region code for the radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
         * @return The enum numeric value on the wire for region.
         */
        @java.lang.Override public int getRegionValue() {
          return region_;
        }
        /**
         * <pre>
         *
         * The region code for the radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
         * @param value The enum numeric value on the wire for region to set.
         * @return This builder for chaining.
         */
        public Builder setRegionValue(int value) {
          region_ = value;
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The region code for the radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
         * @return The region.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode getRegion() {
          com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode result = com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode.forNumber(region_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * The region code for the radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
         * @param value The region to set.
         * @return This builder for chaining.
         */
        public Builder setRegion(com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.RegionCode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000040;
          region_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The region code for the radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.meshtastic.Config.LoRaConfig.RegionCode region = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearRegion() {
          bitField0_ = (bitField0_ & ~0x00000040);
          region_ = 0;
          onChanged();
          return this;
        }

        private int hopLimit_ ;
        /**
         * <pre>
         *
         * Maximum number of hops. This can't be greater than 7.
         * Default of 3
         * Attempting to set a value &gt; 7 results in the default
         * </pre>
         *
         * <code>uint32 hop_limit = 8;</code>
         * @return The hopLimit.
         */
        @java.lang.Override
        public int getHopLimit() {
          return hopLimit_;
        }
        /**
         * <pre>
         *
         * Maximum number of hops. This can't be greater than 7.
         * Default of 3
         * Attempting to set a value &gt; 7 results in the default
         * </pre>
         *
         * <code>uint32 hop_limit = 8;</code>
         * @param value The hopLimit to set.
         * @return This builder for chaining.
         */
        public Builder setHopLimit(int value) {

          hopLimit_ = value;
          bitField0_ |= 0x00000080;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Maximum number of hops. This can't be greater than 7.
         * Default of 3
         * Attempting to set a value &gt; 7 results in the default
         * </pre>
         *
         * <code>uint32 hop_limit = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearHopLimit() {
          bitField0_ = (bitField0_ & ~0x00000080);
          hopLimit_ = 0;
          onChanged();
          return this;
        }

        private boolean txEnabled_ ;
        /**
         * <pre>
         *
         * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
         * Defaults to false
         * </pre>
         *
         * <code>bool tx_enabled = 9;</code>
         * @return The txEnabled.
         */
        @java.lang.Override
        public boolean getTxEnabled() {
          return txEnabled_;
        }
        /**
         * <pre>
         *
         * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
         * Defaults to false
         * </pre>
         *
         * <code>bool tx_enabled = 9;</code>
         * @param value The txEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setTxEnabled(boolean value) {

          txEnabled_ = value;
          bitField0_ |= 0x00000100;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
         * Defaults to false
         * </pre>
         *
         * <code>bool tx_enabled = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearTxEnabled() {
          bitField0_ = (bitField0_ & ~0x00000100);
          txEnabled_ = false;
          onChanged();
          return this;
        }

        private int txPower_ ;
        /**
         * <pre>
         *
         * If zero, then use default max legal continuous power (ie. something that won't
         * burn out the radio hardware)
         * In most cases you should use zero here.
         * Units are in dBm.
         * </pre>
         *
         * <code>int32 tx_power = 10;</code>
         * @return The txPower.
         */
        @java.lang.Override
        public int getTxPower() {
          return txPower_;
        }
        /**
         * <pre>
         *
         * If zero, then use default max legal continuous power (ie. something that won't
         * burn out the radio hardware)
         * In most cases you should use zero here.
         * Units are in dBm.
         * </pre>
         *
         * <code>int32 tx_power = 10;</code>
         * @param value The txPower to set.
         * @return This builder for chaining.
         */
        public Builder setTxPower(int value) {

          txPower_ = value;
          bitField0_ |= 0x00000200;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If zero, then use default max legal continuous power (ie. something that won't
         * burn out the radio hardware)
         * In most cases you should use zero here.
         * Units are in dBm.
         * </pre>
         *
         * <code>int32 tx_power = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearTxPower() {
          bitField0_ = (bitField0_ & ~0x00000200);
          txPower_ = 0;
          onChanged();
          return this;
        }

        private int channelNum_ ;
        /**
         * <pre>
         *
         * This controls the actual hardware frequency the radio transmits on.
         * Most users should never need to be exposed to this field/concept.
         * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
         * If ZERO then the rule is "use the old channel name hash based
         * algorithm to derive the channel number")
         * If using the hash algorithm the channel number will be: hash(channel_name) %
         * NUM_CHANNELS (Where num channels depends on the regulatory region).
         * </pre>
         *
         * <code>uint32 channel_num = 11;</code>
         * @return The channelNum.
         */
        @java.lang.Override
        public int getChannelNum() {
          return channelNum_;
        }
        /**
         * <pre>
         *
         * This controls the actual hardware frequency the radio transmits on.
         * Most users should never need to be exposed to this field/concept.
         * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
         * If ZERO then the rule is "use the old channel name hash based
         * algorithm to derive the channel number")
         * If using the hash algorithm the channel number will be: hash(channel_name) %
         * NUM_CHANNELS (Where num channels depends on the regulatory region).
         * </pre>
         *
         * <code>uint32 channel_num = 11;</code>
         * @param value The channelNum to set.
         * @return This builder for chaining.
         */
        public Builder setChannelNum(int value) {

          channelNum_ = value;
          bitField0_ |= 0x00000400;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * This controls the actual hardware frequency the radio transmits on.
         * Most users should never need to be exposed to this field/concept.
         * A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
         * If ZERO then the rule is "use the old channel name hash based
         * algorithm to derive the channel number")
         * If using the hash algorithm the channel number will be: hash(channel_name) %
         * NUM_CHANNELS (Where num channels depends on the regulatory region).
         * </pre>
         *
         * <code>uint32 channel_num = 11;</code>
         * @return This builder for chaining.
         */
        public Builder clearChannelNum() {
          bitField0_ = (bitField0_ & ~0x00000400);
          channelNum_ = 0;
          onChanged();
          return this;
        }

        private boolean overrideDutyCycle_ ;
        /**
         * <pre>
         *
         * If true, duty cycle limits will be exceeded and thus you're possibly not following
         * the local regulations if you're not a HAM.
         * Has no effect if the duty cycle of the used region is 100%.
         * </pre>
         *
         * <code>bool override_duty_cycle = 12;</code>
         * @return The overrideDutyCycle.
         */
        @java.lang.Override
        public boolean getOverrideDutyCycle() {
          return overrideDutyCycle_;
        }
        /**
         * <pre>
         *
         * If true, duty cycle limits will be exceeded and thus you're possibly not following
         * the local regulations if you're not a HAM.
         * Has no effect if the duty cycle of the used region is 100%.
         * </pre>
         *
         * <code>bool override_duty_cycle = 12;</code>
         * @param value The overrideDutyCycle to set.
         * @return This builder for chaining.
         */
        public Builder setOverrideDutyCycle(boolean value) {

          overrideDutyCycle_ = value;
          bitField0_ |= 0x00000800;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If true, duty cycle limits will be exceeded and thus you're possibly not following
         * the local regulations if you're not a HAM.
         * Has no effect if the duty cycle of the used region is 100%.
         * </pre>
         *
         * <code>bool override_duty_cycle = 12;</code>
         * @return This builder for chaining.
         */
        public Builder clearOverrideDutyCycle() {
          bitField0_ = (bitField0_ & ~0x00000800);
          overrideDutyCycle_ = false;
          onChanged();
          return this;
        }

        private boolean sx126XRxBoostedGain_ ;
        /**
         * <pre>
         *
         * If true, sets RX boosted gain mode on SX126X based radios
         * </pre>
         *
         * <code>bool sx126x_rx_boosted_gain = 13;</code>
         * @return The sx126xRxBoostedGain.
         */
        @java.lang.Override
        public boolean getSx126XRxBoostedGain() {
          return sx126XRxBoostedGain_;
        }
        /**
         * <pre>
         *
         * If true, sets RX boosted gain mode on SX126X based radios
         * </pre>
         *
         * <code>bool sx126x_rx_boosted_gain = 13;</code>
         * @param value The sx126xRxBoostedGain to set.
         * @return This builder for chaining.
         */
        public Builder setSx126XRxBoostedGain(boolean value) {

          sx126XRxBoostedGain_ = value;
          bitField0_ |= 0x00001000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If true, sets RX boosted gain mode on SX126X based radios
         * </pre>
         *
         * <code>bool sx126x_rx_boosted_gain = 13;</code>
         * @return This builder for chaining.
         */
        public Builder clearSx126XRxBoostedGain() {
          bitField0_ = (bitField0_ & ~0x00001000);
          sx126XRxBoostedGain_ = false;
          onChanged();
          return this;
        }

        private float overrideFrequency_ ;
        /**
         * <pre>
         *
         * This parameter is for advanced users and licensed HAM radio operators.
         * Ignore Channel Calculation and use this frequency instead. The frequency_offset
         * will still be applied. This will allow you to use out-of-band frequencies.
         * Please respect your local laws and regulations. If you are a HAM, make sure you
         * enable HAM mode and turn off encryption.
         * </pre>
         *
         * <code>float override_frequency = 14;</code>
         * @return The overrideFrequency.
         */
        @java.lang.Override
        public float getOverrideFrequency() {
          return overrideFrequency_;
        }
        /**
         * <pre>
         *
         * This parameter is for advanced users and licensed HAM radio operators.
         * Ignore Channel Calculation and use this frequency instead. The frequency_offset
         * will still be applied. This will allow you to use out-of-band frequencies.
         * Please respect your local laws and regulations. If you are a HAM, make sure you
         * enable HAM mode and turn off encryption.
         * </pre>
         *
         * <code>float override_frequency = 14;</code>
         * @param value The overrideFrequency to set.
         * @return This builder for chaining.
         */
        public Builder setOverrideFrequency(float value) {

          overrideFrequency_ = value;
          bitField0_ |= 0x00002000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * This parameter is for advanced users and licensed HAM radio operators.
         * Ignore Channel Calculation and use this frequency instead. The frequency_offset
         * will still be applied. This will allow you to use out-of-band frequencies.
         * Please respect your local laws and regulations. If you are a HAM, make sure you
         * enable HAM mode and turn off encryption.
         * </pre>
         *
         * <code>float override_frequency = 14;</code>
         * @return This builder for chaining.
         */
        public Builder clearOverrideFrequency() {
          bitField0_ = (bitField0_ & ~0x00002000);
          overrideFrequency_ = 0F;
          onChanged();
          return this;
        }

        private boolean paFanDisabled_ ;
        /**
         * <pre>
         *
         * If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
         * </pre>
         *
         * <code>bool pa_fan_disabled = 15;</code>
         * @return The paFanDisabled.
         */
        @java.lang.Override
        public boolean getPaFanDisabled() {
          return paFanDisabled_;
        }
        /**
         * <pre>
         *
         * If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
         * </pre>
         *
         * <code>bool pa_fan_disabled = 15;</code>
         * @param value The paFanDisabled to set.
         * @return This builder for chaining.
         */
        public Builder setPaFanDisabled(boolean value) {

          paFanDisabled_ = value;
          bitField0_ |= 0x00004000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
         * </pre>
         *
         * <code>bool pa_fan_disabled = 15;</code>
         * @return This builder for chaining.
         */
        public Builder clearPaFanDisabled() {
          bitField0_ = (bitField0_ & ~0x00004000);
          paFanDisabled_ = false;
          onChanged();
          return this;
        }

        private com.google.protobuf.Internal.IntList ignoreIncoming_ = emptyIntList();
        private void ensureIgnoreIncomingIsMutable() {
          if (!ignoreIncoming_.isModifiable()) {
            ignoreIncoming_ = makeMutableCopy(ignoreIncoming_);
          }
          bitField0_ |= 0x00008000;
        }
        /**
         * <pre>
         *
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @return A list containing the ignoreIncoming.
         */
        public java.util.List<java.lang.Integer>
            getIgnoreIncomingList() {
          ignoreIncoming_.makeImmutable();
          return ignoreIncoming_;
        }
        /**
         * <pre>
         *
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @return The count of ignoreIncoming.
         */
        public int getIgnoreIncomingCount() {
          return ignoreIncoming_.size();
        }
        /**
         * <pre>
         *
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @param index The index of the element to return.
         * @return The ignoreIncoming at the given index.
         */
        public int getIgnoreIncoming(int index) {
          return ignoreIncoming_.getInt(index);
        }
        /**
         * <pre>
         *
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @param index The index to set the value at.
         * @param value The ignoreIncoming to set.
         * @return This builder for chaining.
         */
        public Builder setIgnoreIncoming(
            int index, int value) {

          ensureIgnoreIncomingIsMutable();
          ignoreIncoming_.setInt(index, value);
          bitField0_ |= 0x00008000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @param value The ignoreIncoming to add.
         * @return This builder for chaining.
         */
        public Builder addIgnoreIncoming(int value) {

          ensureIgnoreIncomingIsMutable();
          ignoreIncoming_.addInt(value);
          bitField0_ |= 0x00008000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @param values The ignoreIncoming to add.
         * @return This builder for chaining.
         */
        public Builder addAllIgnoreIncoming(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          ensureIgnoreIncomingIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, ignoreIncoming_);
          bitField0_ |= 0x00008000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send dropped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @return This builder for chaining.
         */
        public Builder clearIgnoreIncoming() {
          ignoreIncoming_ = emptyIntList();
          bitField0_ = (bitField0_ & ~0x00008000);
          onChanged();
          return this;
        }

        private boolean ignoreMqtt_ ;
        /**
         * <pre>
         *
         * If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
         * </pre>
         *
         * <code>bool ignore_mqtt = 104;</code>
         * @return The ignoreMqtt.
         */
        @java.lang.Override
        public boolean getIgnoreMqtt() {
          return ignoreMqtt_;
        }
        /**
         * <pre>
         *
         * If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
         * </pre>
         *
         * <code>bool ignore_mqtt = 104;</code>
         * @param value The ignoreMqtt to set.
         * @return This builder for chaining.
         */
        public Builder setIgnoreMqtt(boolean value) {

          ignoreMqtt_ = value;
          bitField0_ |= 0x00010000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
         * </pre>
         *
         * <code>bool ignore_mqtt = 104;</code>
         * @return This builder for chaining.
         */
        public Builder clearIgnoreMqtt() {
          bitField0_ = (bitField0_ & ~0x00010000);
          ignoreMqtt_ = false;
          onChanged();
          return this;
        }

        private boolean configOkToMqtt_ ;
        /**
         * <pre>
         *
         * Sets the ok_to_mqtt bit on outgoing packets
         * </pre>
         *
         * <code>bool config_ok_to_mqtt = 105;</code>
         * @return The configOkToMqtt.
         */
        @java.lang.Override
        public boolean getConfigOkToMqtt() {
          return configOkToMqtt_;
        }
        /**
         * <pre>
         *
         * Sets the ok_to_mqtt bit on outgoing packets
         * </pre>
         *
         * <code>bool config_ok_to_mqtt = 105;</code>
         * @param value The configOkToMqtt to set.
         * @return This builder for chaining.
         */
        public Builder setConfigOkToMqtt(boolean value) {

          configOkToMqtt_ = value;
          bitField0_ |= 0x00020000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Sets the ok_to_mqtt bit on outgoing packets
         * </pre>
         *
         * <code>bool config_ok_to_mqtt = 105;</code>
         * @return This builder for chaining.
         */
        public Builder clearConfigOkToMqtt() {
          bitField0_ = (bitField0_ & ~0x00020000);
          configOkToMqtt_ = false;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.LoRaConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.LoRaConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.LoRaConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.LoRaConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.LoRaConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<LoRaConfig>
          PARSER = new com.google.protobuf.AbstractParser<LoRaConfig>() {
        @java.lang.Override
        public LoRaConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<LoRaConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<LoRaConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface BluetoothConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.BluetoothConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       *
       * Enable Bluetooth on the device
       * </pre>
       *
       * <code>bool enabled = 1;</code>
       * @return The enabled.
       */
      boolean getEnabled();

      /**
       * <pre>
       *
       * Determines the pairing strategy for the device
       * </pre>
       *
       * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
       * @return The enum numeric value on the wire for mode.
       */
      int getModeValue();
      /**
       * <pre>
       *
       * Determines the pairing strategy for the device
       * </pre>
       *
       * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
       * @return The mode.
       */
      com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode getMode();

      /**
       * <pre>
       *
       * Specified PIN for PairingMode.FixedPin
       * </pre>
       *
       * <code>uint32 fixed_pin = 3;</code>
       * @return The fixedPin.
       */
      int getFixedPin();
    }
    /**
     * Protobuf type {@code meshtastic.Config.BluetoothConfig}
     */
    public static final class BluetoothConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.BluetoothConfig)
        BluetoothConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use BluetoothConfig.newBuilder() to construct.
      private BluetoothConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private BluetoothConfig() {
        mode_ = 0;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new BluetoothConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_BluetoothConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_BluetoothConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.class, com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.Builder.class);
      }

      /**
       * Protobuf enum {@code meshtastic.Config.BluetoothConfig.PairingMode}
       */
      public enum PairingMode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         *
         * Device generates a random PIN that will be shown on the screen of the device for pairing
         * </pre>
         *
         * <code>RANDOM_PIN = 0;</code>
         */
        RANDOM_PIN(0),
        /**
         * <pre>
         *
         * Device requires a specified fixed PIN for pairing
         * </pre>
         *
         * <code>FIXED_PIN = 1;</code>
         */
        FIXED_PIN(1),
        /**
         * <pre>
         *
         * Device requires no PIN for pairing
         * </pre>
         *
         * <code>NO_PIN = 2;</code>
         */
        NO_PIN(2),
        UNRECOGNIZED(-1),
        ;

        /**
         * <pre>
         *
         * Device generates a random PIN that will be shown on the screen of the device for pairing
         * </pre>
         *
         * <code>RANDOM_PIN = 0;</code>
         */
        public static final int RANDOM_PIN_VALUE = 0;
        /**
         * <pre>
         *
         * Device requires a specified fixed PIN for pairing
         * </pre>
         *
         * <code>FIXED_PIN = 1;</code>
         */
        public static final int FIXED_PIN_VALUE = 1;
        /**
         * <pre>
         *
         * Device requires no PIN for pairing
         * </pre>
         *
         * <code>NO_PIN = 2;</code>
         */
        public static final int NO_PIN_VALUE = 2;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static PairingMode valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static PairingMode forNumber(int value) {
          switch (value) {
            case 0: return RANDOM_PIN;
            case 1: return FIXED_PIN;
            case 2: return NO_PIN;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<PairingMode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            PairingMode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<PairingMode>() {
                public PairingMode findValueByNumber(int number) {
                  return PairingMode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDescriptor().getEnumTypes().get(0);
        }

        private static final PairingMode[] VALUES = values();

        public static PairingMode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private PairingMode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:meshtastic.Config.BluetoothConfig.PairingMode)
      }

      public static final int ENABLED_FIELD_NUMBER = 1;
      private boolean enabled_ = false;
      /**
       * <pre>
       *
       * Enable Bluetooth on the device
       * </pre>
       *
       * <code>bool enabled = 1;</code>
       * @return The enabled.
       */
      @java.lang.Override
      public boolean getEnabled() {
        return enabled_;
      }

      public static final int MODE_FIELD_NUMBER = 2;
      private int mode_ = 0;
      /**
       * <pre>
       *
       * Determines the pairing strategy for the device
       * </pre>
       *
       * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
       * @return The enum numeric value on the wire for mode.
       */
      @java.lang.Override public int getModeValue() {
        return mode_;
      }
      /**
       * <pre>
       *
       * Determines the pairing strategy for the device
       * </pre>
       *
       * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
       * @return The mode.
       */
      @java.lang.Override public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode getMode() {
        com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode result = com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode.forNumber(mode_);
        return result == null ? com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode.UNRECOGNIZED : result;
      }

      public static final int FIXED_PIN_FIELD_NUMBER = 3;
      private int fixedPin_ = 0;
      /**
       * <pre>
       *
       * Specified PIN for PairingMode.FixedPin
       * </pre>
       *
       * <code>uint32 fixed_pin = 3;</code>
       * @return The fixedPin.
       */
      @java.lang.Override
      public int getFixedPin() {
        return fixedPin_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (enabled_ != false) {
          output.writeBool(1, enabled_);
        }
        if (mode_ != com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode.RANDOM_PIN.getNumber()) {
          output.writeEnum(2, mode_);
        }
        if (fixedPin_ != 0) {
          output.writeUInt32(3, fixedPin_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (enabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, enabled_);
        }
        if (mode_ != com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode.RANDOM_PIN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(2, mode_);
        }
        if (fixedPin_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(3, fixedPin_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig other = (com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) obj;

        if (getEnabled()
            != other.getEnabled()) return false;
        if (mode_ != other.mode_) return false;
        if (getFixedPin()
            != other.getFixedPin()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEnabled());
        hash = (37 * hash) + MODE_FIELD_NUMBER;
        hash = (53 * hash) + mode_;
        hash = (37 * hash) + FIXED_PIN_FIELD_NUMBER;
        hash = (53 * hash) + getFixedPin();
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code meshtastic.Config.BluetoothConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.BluetoothConfig)
          com.geeksville.mesh.ConfigProtos.Config.BluetoothConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_BluetoothConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_BluetoothConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.class, com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          enabled_ = false;
          mode_ = 0;
          fixedPin_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_BluetoothConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig result = new com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.enabled_ = enabled_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.mode_ = mode_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.fixedPin_ = fixedPin_;
          }
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance()) return this;
          if (other.getEnabled() != false) {
            setEnabled(other.getEnabled());
          }
          if (other.mode_ != 0) {
            setModeValue(other.getModeValue());
          }
          if (other.getFixedPin() != 0) {
            setFixedPin(other.getFixedPin());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  enabled_ = input.readBool();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  mode_ = input.readEnum();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 24: {
                  fixedPin_ = input.readUInt32();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 24
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private boolean enabled_ ;
        /**
         * <pre>
         *
         * Enable Bluetooth on the device
         * </pre>
         *
         * <code>bool enabled = 1;</code>
         * @return The enabled.
         */
        @java.lang.Override
        public boolean getEnabled() {
          return enabled_;
        }
        /**
         * <pre>
         *
         * Enable Bluetooth on the device
         * </pre>
         *
         * <code>bool enabled = 1;</code>
         * @param value The enabled to set.
         * @return This builder for chaining.
         */
        public Builder setEnabled(boolean value) {

          enabled_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Enable Bluetooth on the device
         * </pre>
         *
         * <code>bool enabled = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnabled() {
          bitField0_ = (bitField0_ & ~0x00000001);
          enabled_ = false;
          onChanged();
          return this;
        }

        private int mode_ = 0;
        /**
         * <pre>
         *
         * Determines the pairing strategy for the device
         * </pre>
         *
         * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
         * @return The enum numeric value on the wire for mode.
         */
        @java.lang.Override public int getModeValue() {
          return mode_;
        }
        /**
         * <pre>
         *
         * Determines the pairing strategy for the device
         * </pre>
         *
         * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
         * @param value The enum numeric value on the wire for mode to set.
         * @return This builder for chaining.
         */
        public Builder setModeValue(int value) {
          mode_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Determines the pairing strategy for the device
         * </pre>
         *
         * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
         * @return The mode.
         */
        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode getMode() {
          com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode result = com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode.forNumber(mode_);
          return result == null ? com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         *
         * Determines the pairing strategy for the device
         * </pre>
         *
         * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
         * @param value The mode to set.
         * @return This builder for chaining.
         */
        public Builder setMode(com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.PairingMode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000002;
          mode_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Determines the pairing strategy for the device
         * </pre>
         *
         * <code>.meshtastic.Config.BluetoothConfig.PairingMode mode = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearMode() {
          bitField0_ = (bitField0_ & ~0x00000002);
          mode_ = 0;
          onChanged();
          return this;
        }

        private int fixedPin_ ;
        /**
         * <pre>
         *
         * Specified PIN for PairingMode.FixedPin
         * </pre>
         *
         * <code>uint32 fixed_pin = 3;</code>
         * @return The fixedPin.
         */
        @java.lang.Override
        public int getFixedPin() {
          return fixedPin_;
        }
        /**
         * <pre>
         *
         * Specified PIN for PairingMode.FixedPin
         * </pre>
         *
         * <code>uint32 fixed_pin = 3;</code>
         * @param value The fixedPin to set.
         * @return This builder for chaining.
         */
        public Builder setFixedPin(int value) {

          fixedPin_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Specified PIN for PairingMode.FixedPin
         * </pre>
         *
         * <code>uint32 fixed_pin = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearFixedPin() {
          bitField0_ = (bitField0_ & ~0x00000004);
          fixedPin_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.BluetoothConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.BluetoothConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<BluetoothConfig>
          PARSER = new com.google.protobuf.AbstractParser<BluetoothConfig>() {
        @java.lang.Override
        public BluetoothConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<BluetoothConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<BluetoothConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface SecurityConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.SecurityConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       *
       * The public key of the user's device.
       * Sent out to other nodes on the mesh to allow them to compute a shared secret key.
       * </pre>
       *
       * <code>bytes public_key = 1;</code>
       * @return The publicKey.
       */
      com.google.protobuf.ByteString getPublicKey();

      /**
       * <pre>
       *
       * The private key of the device.
       * Used to create a shared key with a remote device.
       * </pre>
       *
       * <code>bytes private_key = 2;</code>
       * @return The privateKey.
       */
      com.google.protobuf.ByteString getPrivateKey();

      /**
       * <pre>
       *
       * The public key authorized to send admin messages to this node.
       * </pre>
       *
       * <code>repeated bytes admin_key = 3;</code>
       * @return A list containing the adminKey.
       */
      java.util.List<com.google.protobuf.ByteString> getAdminKeyList();
      /**
       * <pre>
       *
       * The public key authorized to send admin messages to this node.
       * </pre>
       *
       * <code>repeated bytes admin_key = 3;</code>
       * @return The count of adminKey.
       */
      int getAdminKeyCount();
      /**
       * <pre>
       *
       * The public key authorized to send admin messages to this node.
       * </pre>
       *
       * <code>repeated bytes admin_key = 3;</code>
       * @param index The index of the element to return.
       * @return The adminKey at the given index.
       */
      com.google.protobuf.ByteString getAdminKey(int index);

      /**
       * <pre>
       *
       * If true, device is considered to be "managed" by a mesh administrator via admin messages
       * Device is managed by a mesh administrator.
       * </pre>
       *
       * <code>bool is_managed = 4;</code>
       * @return The isManaged.
       */
      boolean getIsManaged();

      /**
       * <pre>
       *
       * Serial Console over the Stream API."
       * </pre>
       *
       * <code>bool serial_enabled = 5;</code>
       * @return The serialEnabled.
       */
      boolean getSerialEnabled();

      /**
       * <pre>
       *
       * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
       * Output live debug logging over serial or bluetooth is set to true.
       * </pre>
       *
       * <code>bool debug_log_api_enabled = 6;</code>
       * @return The debugLogApiEnabled.
       */
      boolean getDebugLogApiEnabled();

      /**
       * <pre>
       *
       * Allow incoming device control over the insecure legacy admin channel.
       * </pre>
       *
       * <code>bool admin_channel_enabled = 8;</code>
       * @return The adminChannelEnabled.
       */
      boolean getAdminChannelEnabled();
    }
    /**
     * Protobuf type {@code meshtastic.Config.SecurityConfig}
     */
    public static final class SecurityConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.SecurityConfig)
        SecurityConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use SecurityConfig.newBuilder() to construct.
      private SecurityConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private SecurityConfig() {
        publicKey_ = com.google.protobuf.ByteString.EMPTY;
        privateKey_ = com.google.protobuf.ByteString.EMPTY;
        adminKey_ = emptyList(com.google.protobuf.ByteString.class);
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new SecurityConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SecurityConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SecurityConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.class, com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.Builder.class);
      }

      public static final int PUBLIC_KEY_FIELD_NUMBER = 1;
      private com.google.protobuf.ByteString publicKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       * The public key of the user's device.
       * Sent out to other nodes on the mesh to allow them to compute a shared secret key.
       * </pre>
       *
       * <code>bytes public_key = 1;</code>
       * @return The publicKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPublicKey() {
        return publicKey_;
      }

      public static final int PRIVATE_KEY_FIELD_NUMBER = 2;
      private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       *
       * The private key of the device.
       * Used to create a shared key with a remote device.
       * </pre>
       *
       * <code>bytes private_key = 2;</code>
       * @return The privateKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPrivateKey() {
        return privateKey_;
      }

      public static final int ADMIN_KEY_FIELD_NUMBER = 3;
      @SuppressWarnings("serial")
      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> adminKey_ =
          emptyList(com.google.protobuf.ByteString.class);
      /**
       * <pre>
       *
       * The public key authorized to send admin messages to this node.
       * </pre>
       *
       * <code>repeated bytes admin_key = 3;</code>
       * @return A list containing the adminKey.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.ByteString>
          getAdminKeyList() {
        return adminKey_;
      }
      /**
       * <pre>
       *
       * The public key authorized to send admin messages to this node.
       * </pre>
       *
       * <code>repeated bytes admin_key = 3;</code>
       * @return The count of adminKey.
       */
      public int getAdminKeyCount() {
        return adminKey_.size();
      }
      /**
       * <pre>
       *
       * The public key authorized to send admin messages to this node.
       * </pre>
       *
       * <code>repeated bytes admin_key = 3;</code>
       * @param index The index of the element to return.
       * @return The adminKey at the given index.
       */
      public com.google.protobuf.ByteString getAdminKey(int index) {
        return adminKey_.get(index);
      }

      public static final int IS_MANAGED_FIELD_NUMBER = 4;
      private boolean isManaged_ = false;
      /**
       * <pre>
       *
       * If true, device is considered to be "managed" by a mesh administrator via admin messages
       * Device is managed by a mesh administrator.
       * </pre>
       *
       * <code>bool is_managed = 4;</code>
       * @return The isManaged.
       */
      @java.lang.Override
      public boolean getIsManaged() {
        return isManaged_;
      }

      public static final int SERIAL_ENABLED_FIELD_NUMBER = 5;
      private boolean serialEnabled_ = false;
      /**
       * <pre>
       *
       * Serial Console over the Stream API."
       * </pre>
       *
       * <code>bool serial_enabled = 5;</code>
       * @return The serialEnabled.
       */
      @java.lang.Override
      public boolean getSerialEnabled() {
        return serialEnabled_;
      }

      public static final int DEBUG_LOG_API_ENABLED_FIELD_NUMBER = 6;
      private boolean debugLogApiEnabled_ = false;
      /**
       * <pre>
       *
       * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
       * Output live debug logging over serial or bluetooth is set to true.
       * </pre>
       *
       * <code>bool debug_log_api_enabled = 6;</code>
       * @return The debugLogApiEnabled.
       */
      @java.lang.Override
      public boolean getDebugLogApiEnabled() {
        return debugLogApiEnabled_;
      }

      public static final int ADMIN_CHANNEL_ENABLED_FIELD_NUMBER = 8;
      private boolean adminChannelEnabled_ = false;
      /**
       * <pre>
       *
       * Allow incoming device control over the insecure legacy admin channel.
       * </pre>
       *
       * <code>bool admin_channel_enabled = 8;</code>
       * @return The adminChannelEnabled.
       */
      @java.lang.Override
      public boolean getAdminChannelEnabled() {
        return adminChannelEnabled_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!publicKey_.isEmpty()) {
          output.writeBytes(1, publicKey_);
        }
        if (!privateKey_.isEmpty()) {
          output.writeBytes(2, privateKey_);
        }
        for (int i = 0; i < adminKey_.size(); i++) {
          output.writeBytes(3, adminKey_.get(i));
        }
        if (isManaged_ != false) {
          output.writeBool(4, isManaged_);
        }
        if (serialEnabled_ != false) {
          output.writeBool(5, serialEnabled_);
        }
        if (debugLogApiEnabled_ != false) {
          output.writeBool(6, debugLogApiEnabled_);
        }
        if (adminChannelEnabled_ != false) {
          output.writeBool(8, adminChannelEnabled_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!publicKey_.isEmpty()) {
          size += com.google.protobuf.CodedOutputStream
            .computeBytesSize(1, publicKey_);
        }
        if (!privateKey_.isEmpty()) {
          size += com.google.protobuf.CodedOutputStream
            .computeBytesSize(2, privateKey_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < adminKey_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeBytesSizeNoTag(adminKey_.get(i));
          }
          size += dataSize;
          size += 1 * getAdminKeyList().size();
        }
        if (isManaged_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(4, isManaged_);
        }
        if (serialEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(5, serialEnabled_);
        }
        if (debugLogApiEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(6, debugLogApiEnabled_);
        }
        if (adminChannelEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(8, adminChannelEnabled_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.SecurityConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.SecurityConfig other = (com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) obj;

        if (!getPublicKey()
            .equals(other.getPublicKey())) return false;
        if (!getPrivateKey()
            .equals(other.getPrivateKey())) return false;
        if (!getAdminKeyList()
            .equals(other.getAdminKeyList())) return false;
        if (getIsManaged()
            != other.getIsManaged()) return false;
        if (getSerialEnabled()
            != other.getSerialEnabled()) return false;
        if (getDebugLogApiEnabled()
            != other.getDebugLogApiEnabled()) return false;
        if (getAdminChannelEnabled()
            != other.getAdminChannelEnabled()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + PUBLIC_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getPublicKey().hashCode();
        hash = (37 * hash) + PRIVATE_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getPrivateKey().hashCode();
        if (getAdminKeyCount() > 0) {
          hash = (37 * hash) + ADMIN_KEY_FIELD_NUMBER;
          hash = (53 * hash) + getAdminKeyList().hashCode();
        }
        hash = (37 * hash) + IS_MANAGED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsManaged());
        hash = (37 * hash) + SERIAL_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSerialEnabled());
        hash = (37 * hash) + DEBUG_LOG_API_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getDebugLogApiEnabled());
        hash = (37 * hash) + ADMIN_CHANNEL_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAdminChannelEnabled());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.SecurityConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code meshtastic.Config.SecurityConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.SecurityConfig)
          com.geeksville.mesh.ConfigProtos.Config.SecurityConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SecurityConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SecurityConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.class, com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          publicKey_ = com.google.protobuf.ByteString.EMPTY;
          privateKey_ = com.google.protobuf.ByteString.EMPTY;
          adminKey_ = emptyList(com.google.protobuf.ByteString.class);
          isManaged_ = false;
          serialEnabled_ = false;
          debugLogApiEnabled_ = false;
          adminChannelEnabled_ = false;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SecurityConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.SecurityConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.SecurityConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.SecurityConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.SecurityConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.SecurityConfig result = new com.geeksville.mesh.ConfigProtos.Config.SecurityConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config.SecurityConfig result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.publicKey_ = publicKey_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.privateKey_ = privateKey_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            adminKey_.makeImmutable();
            result.adminKey_ = adminKey_;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.isManaged_ = isManaged_;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.serialEnabled_ = serialEnabled_;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.debugLogApiEnabled_ = debugLogApiEnabled_;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.adminChannelEnabled_ = adminChannelEnabled_;
          }
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.SecurityConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.SecurityConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance()) return this;
          if (other.getPublicKey() != com.google.protobuf.ByteString.EMPTY) {
            setPublicKey(other.getPublicKey());
          }
          if (other.getPrivateKey() != com.google.protobuf.ByteString.EMPTY) {
            setPrivateKey(other.getPrivateKey());
          }
          if (!other.adminKey_.isEmpty()) {
            if (adminKey_.isEmpty()) {
              adminKey_ = other.adminKey_;
              adminKey_.makeImmutable();
              bitField0_ |= 0x00000004;
            } else {
              ensureAdminKeyIsMutable();
              adminKey_.addAll(other.adminKey_);
            }
            onChanged();
          }
          if (other.getIsManaged() != false) {
            setIsManaged(other.getIsManaged());
          }
          if (other.getSerialEnabled() != false) {
            setSerialEnabled(other.getSerialEnabled());
          }
          if (other.getDebugLogApiEnabled() != false) {
            setDebugLogApiEnabled(other.getDebugLogApiEnabled());
          }
          if (other.getAdminChannelEnabled() != false) {
            setAdminChannelEnabled(other.getAdminChannelEnabled());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  publicKey_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 18: {
                  privateKey_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                case 26: {
                  com.google.protobuf.ByteString v = input.readBytes();
                  ensureAdminKeyIsMutable();
                  adminKey_.add(v);
                  break;
                } // case 26
                case 32: {
                  isManaged_ = input.readBool();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
                case 40: {
                  serialEnabled_ = input.readBool();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 40
                case 48: {
                  debugLogApiEnabled_ = input.readBool();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 48
                case 64: {
                  adminChannelEnabled_ = input.readBool();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 64
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private com.google.protobuf.ByteString publicKey_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <pre>
         *
         * The public key of the user's device.
         * Sent out to other nodes on the mesh to allow them to compute a shared secret key.
         * </pre>
         *
         * <code>bytes public_key = 1;</code>
         * @return The publicKey.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getPublicKey() {
          return publicKey_;
        }
        /**
         * <pre>
         *
         * The public key of the user's device.
         * Sent out to other nodes on the mesh to allow them to compute a shared secret key.
         * </pre>
         *
         * <code>bytes public_key = 1;</code>
         * @param value The publicKey to set.
         * @return This builder for chaining.
         */
        public Builder setPublicKey(com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          publicKey_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The public key of the user's device.
         * Sent out to other nodes on the mesh to allow them to compute a shared secret key.
         * </pre>
         *
         * <code>bytes public_key = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearPublicKey() {
          bitField0_ = (bitField0_ & ~0x00000001);
          publicKey_ = getDefaultInstance().getPublicKey();
          onChanged();
          return this;
        }

        private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <pre>
         *
         * The private key of the device.
         * Used to create a shared key with a remote device.
         * </pre>
         *
         * <code>bytes private_key = 2;</code>
         * @return The privateKey.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getPrivateKey() {
          return privateKey_;
        }
        /**
         * <pre>
         *
         * The private key of the device.
         * Used to create a shared key with a remote device.
         * </pre>
         *
         * <code>bytes private_key = 2;</code>
         * @param value The privateKey to set.
         * @return This builder for chaining.
         */
        public Builder setPrivateKey(com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          privateKey_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The private key of the device.
         * Used to create a shared key with a remote device.
         * </pre>
         *
         * <code>bytes private_key = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearPrivateKey() {
          bitField0_ = (bitField0_ & ~0x00000002);
          privateKey_ = getDefaultInstance().getPrivateKey();
          onChanged();
          return this;
        }

        private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> adminKey_ = emptyList(com.google.protobuf.ByteString.class);
        private void ensureAdminKeyIsMutable() {
          if (!adminKey_.isModifiable()) {
            adminKey_ = makeMutableCopy(adminKey_);
          }
          bitField0_ |= 0x00000004;
        }
        /**
         * <pre>
         *
         * The public key authorized to send admin messages to this node.
         * </pre>
         *
         * <code>repeated bytes admin_key = 3;</code>
         * @return A list containing the adminKey.
         */
        public java.util.List<com.google.protobuf.ByteString>
            getAdminKeyList() {
          adminKey_.makeImmutable();
          return adminKey_;
        }
        /**
         * <pre>
         *
         * The public key authorized to send admin messages to this node.
         * </pre>
         *
         * <code>repeated bytes admin_key = 3;</code>
         * @return The count of adminKey.
         */
        public int getAdminKeyCount() {
          return adminKey_.size();
        }
        /**
         * <pre>
         *
         * The public key authorized to send admin messages to this node.
         * </pre>
         *
         * <code>repeated bytes admin_key = 3;</code>
         * @param index The index of the element to return.
         * @return The adminKey at the given index.
         */
        public com.google.protobuf.ByteString getAdminKey(int index) {
          return adminKey_.get(index);
        }
        /**
         * <pre>
         *
         * The public key authorized to send admin messages to this node.
         * </pre>
         *
         * <code>repeated bytes admin_key = 3;</code>
         * @param index The index to set the value at.
         * @param value The adminKey to set.
         * @return This builder for chaining.
         */
        public Builder setAdminKey(
            int index, com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          ensureAdminKeyIsMutable();
          adminKey_.set(index, value);
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The public key authorized to send admin messages to this node.
         * </pre>
         *
         * <code>repeated bytes admin_key = 3;</code>
         * @param value The adminKey to add.
         * @return This builder for chaining.
         */
        public Builder addAdminKey(com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          ensureAdminKeyIsMutable();
          adminKey_.add(value);
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The public key authorized to send admin messages to this node.
         * </pre>
         *
         * <code>repeated bytes admin_key = 3;</code>
         * @param values The adminKey to add.
         * @return This builder for chaining.
         */
        public Builder addAllAdminKey(
            java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
          ensureAdminKeyIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, adminKey_);
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * The public key authorized to send admin messages to this node.
         * </pre>
         *
         * <code>repeated bytes admin_key = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearAdminKey() {
          adminKey_ = emptyList(com.google.protobuf.ByteString.class);
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }

        private boolean isManaged_ ;
        /**
         * <pre>
         *
         * If true, device is considered to be "managed" by a mesh administrator via admin messages
         * Device is managed by a mesh administrator.
         * </pre>
         *
         * <code>bool is_managed = 4;</code>
         * @return The isManaged.
         */
        @java.lang.Override
        public boolean getIsManaged() {
          return isManaged_;
        }
        /**
         * <pre>
         *
         * If true, device is considered to be "managed" by a mesh administrator via admin messages
         * Device is managed by a mesh administrator.
         * </pre>
         *
         * <code>bool is_managed = 4;</code>
         * @param value The isManaged to set.
         * @return This builder for chaining.
         */
        public Builder setIsManaged(boolean value) {

          isManaged_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * If true, device is considered to be "managed" by a mesh administrator via admin messages
         * Device is managed by a mesh administrator.
         * </pre>
         *
         * <code>bool is_managed = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearIsManaged() {
          bitField0_ = (bitField0_ & ~0x00000008);
          isManaged_ = false;
          onChanged();
          return this;
        }

        private boolean serialEnabled_ ;
        /**
         * <pre>
         *
         * Serial Console over the Stream API."
         * </pre>
         *
         * <code>bool serial_enabled = 5;</code>
         * @return The serialEnabled.
         */
        @java.lang.Override
        public boolean getSerialEnabled() {
          return serialEnabled_;
        }
        /**
         * <pre>
         *
         * Serial Console over the Stream API."
         * </pre>
         *
         * <code>bool serial_enabled = 5;</code>
         * @param value The serialEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setSerialEnabled(boolean value) {

          serialEnabled_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Serial Console over the Stream API."
         * </pre>
         *
         * <code>bool serial_enabled = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearSerialEnabled() {
          bitField0_ = (bitField0_ & ~0x00000010);
          serialEnabled_ = false;
          onChanged();
          return this;
        }

        private boolean debugLogApiEnabled_ ;
        /**
         * <pre>
         *
         * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
         * Output live debug logging over serial or bluetooth is set to true.
         * </pre>
         *
         * <code>bool debug_log_api_enabled = 6;</code>
         * @return The debugLogApiEnabled.
         */
        @java.lang.Override
        public boolean getDebugLogApiEnabled() {
          return debugLogApiEnabled_;
        }
        /**
         * <pre>
         *
         * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
         * Output live debug logging over serial or bluetooth is set to true.
         * </pre>
         *
         * <code>bool debug_log_api_enabled = 6;</code>
         * @param value The debugLogApiEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setDebugLogApiEnabled(boolean value) {

          debugLogApiEnabled_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
         * Output live debug logging over serial or bluetooth is set to true.
         * </pre>
         *
         * <code>bool debug_log_api_enabled = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearDebugLogApiEnabled() {
          bitField0_ = (bitField0_ & ~0x00000020);
          debugLogApiEnabled_ = false;
          onChanged();
          return this;
        }

        private boolean adminChannelEnabled_ ;
        /**
         * <pre>
         *
         * Allow incoming device control over the insecure legacy admin channel.
         * </pre>
         *
         * <code>bool admin_channel_enabled = 8;</code>
         * @return The adminChannelEnabled.
         */
        @java.lang.Override
        public boolean getAdminChannelEnabled() {
          return adminChannelEnabled_;
        }
        /**
         * <pre>
         *
         * Allow incoming device control over the insecure legacy admin channel.
         * </pre>
         *
         * <code>bool admin_channel_enabled = 8;</code>
         * @param value The adminChannelEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setAdminChannelEnabled(boolean value) {

          adminChannelEnabled_ = value;
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *
         * Allow incoming device control over the insecure legacy admin channel.
         * </pre>
         *
         * <code>bool admin_channel_enabled = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearAdminChannelEnabled() {
          bitField0_ = (bitField0_ & ~0x00000040);
          adminChannelEnabled_ = false;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.SecurityConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.SecurityConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.SecurityConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.SecurityConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.SecurityConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<SecurityConfig>
          PARSER = new com.google.protobuf.AbstractParser<SecurityConfig>() {
        @java.lang.Override
        public SecurityConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<SecurityConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<SecurityConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.SecurityConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface SessionkeyConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:meshtastic.Config.SessionkeyConfig)
        com.google.protobuf.MessageOrBuilder {
    }
    /**
     * <pre>
     *
     * Blank config request, strictly for getting the session key
     * </pre>
     *
     * Protobuf type {@code meshtastic.Config.SessionkeyConfig}
     */
    public static final class SessionkeyConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:meshtastic.Config.SessionkeyConfig)
        SessionkeyConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use SessionkeyConfig.newBuilder() to construct.
      private SessionkeyConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private SessionkeyConfig() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new SessionkeyConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SessionkeyConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SessionkeyConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.class, com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.Builder.class);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig other = (com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) obj;

        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       *
       * Blank config request, strictly for getting the session key
       * </pre>
       *
       * Protobuf type {@code meshtastic.Config.SessionkeyConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:meshtastic.Config.SessionkeyConfig)
          com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SessionkeyConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SessionkeyConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.class, com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.Builder.class);
        }

        // Construct using com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_SessionkeyConfig_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig getDefaultInstanceForType() {
          return com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig build() {
          com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig buildPartial() {
          com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig result = new com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig(this);
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) {
            return mergeFrom((com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig other) {
          if (other == com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance()) return this;
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:meshtastic.Config.SessionkeyConfig)
      }

      // @@protoc_insertion_point(class_scope:meshtastic.Config.SessionkeyConfig)
      private static final com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig();
      }

      public static com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<SessionkeyConfig>
          PARSER = new com.google.protobuf.AbstractParser<SessionkeyConfig>() {
        @java.lang.Override
        public SessionkeyConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<SessionkeyConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<SessionkeyConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int payloadVariantCase_ = 0;
    @SuppressWarnings("serial")
    private java.lang.Object payloadVariant_;
    public enum PayloadVariantCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      DEVICE(1),
      POSITION(2),
      POWER(3),
      NETWORK(4),
      DISPLAY(5),
      LORA(6),
      BLUETOOTH(7),
      SECURITY(8),
      SESSIONKEY(9),
      DEVICE_UI(10),
      PAYLOADVARIANT_NOT_SET(0);
      private final int value;
      private PayloadVariantCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PayloadVariantCase valueOf(int value) {
        return forNumber(value);
      }

      public static PayloadVariantCase forNumber(int value) {
        switch (value) {
          case 1: return DEVICE;
          case 2: return POSITION;
          case 3: return POWER;
          case 4: return NETWORK;
          case 5: return DISPLAY;
          case 6: return LORA;
          case 7: return BLUETOOTH;
          case 8: return SECURITY;
          case 9: return SESSIONKEY;
          case 10: return DEVICE_UI;
          case 0: return PAYLOADVARIANT_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public PayloadVariantCase
    getPayloadVariantCase() {
      return PayloadVariantCase.forNumber(
          payloadVariantCase_);
    }

    public static final int DEVICE_FIELD_NUMBER = 1;
    /**
     * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
     * @return Whether the device field is set.
     */
    @java.lang.Override
    public boolean hasDevice() {
      return payloadVariantCase_ == 1;
    }
    /**
     * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
     * @return The device.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig getDevice() {
      if (payloadVariantCase_ == 1) {
         return (com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.DeviceConfigOrBuilder getDeviceOrBuilder() {
      if (payloadVariantCase_ == 1) {
         return (com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance();
    }

    public static final int POSITION_FIELD_NUMBER = 2;
    /**
     * <code>.meshtastic.Config.PositionConfig position = 2;</code>
     * @return Whether the position field is set.
     */
    @java.lang.Override
    public boolean hasPosition() {
      return payloadVariantCase_ == 2;
    }
    /**
     * <code>.meshtastic.Config.PositionConfig position = 2;</code>
     * @return The position.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.PositionConfig getPosition() {
      if (payloadVariantCase_ == 2) {
         return (com.geeksville.mesh.ConfigProtos.Config.PositionConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.PositionConfig position = 2;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.PositionConfigOrBuilder getPositionOrBuilder() {
      if (payloadVariantCase_ == 2) {
         return (com.geeksville.mesh.ConfigProtos.Config.PositionConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance();
    }

    public static final int POWER_FIELD_NUMBER = 3;
    /**
     * <code>.meshtastic.Config.PowerConfig power = 3;</code>
     * @return Whether the power field is set.
     */
    @java.lang.Override
    public boolean hasPower() {
      return payloadVariantCase_ == 3;
    }
    /**
     * <code>.meshtastic.Config.PowerConfig power = 3;</code>
     * @return The power.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.PowerConfig getPower() {
      if (payloadVariantCase_ == 3) {
         return (com.geeksville.mesh.ConfigProtos.Config.PowerConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.PowerConfig power = 3;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.PowerConfigOrBuilder getPowerOrBuilder() {
      if (payloadVariantCase_ == 3) {
         return (com.geeksville.mesh.ConfigProtos.Config.PowerConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance();
    }

    public static final int NETWORK_FIELD_NUMBER = 4;
    /**
     * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
     * @return Whether the network field is set.
     */
    @java.lang.Override
    public boolean hasNetwork() {
      return payloadVariantCase_ == 4;
    }
    /**
     * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
     * @return The network.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig getNetwork() {
      if (payloadVariantCase_ == 4) {
         return (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.NetworkConfigOrBuilder getNetworkOrBuilder() {
      if (payloadVariantCase_ == 4) {
         return (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance();
    }

    public static final int DISPLAY_FIELD_NUMBER = 5;
    /**
     * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
     * @return Whether the display field is set.
     */
    @java.lang.Override
    public boolean hasDisplay() {
      return payloadVariantCase_ == 5;
    }
    /**
     * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
     * @return The display.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig getDisplay() {
      if (payloadVariantCase_ == 5) {
         return (com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.DisplayConfigOrBuilder getDisplayOrBuilder() {
      if (payloadVariantCase_ == 5) {
         return (com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance();
    }

    public static final int LORA_FIELD_NUMBER = 6;
    /**
     * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
     * @return Whether the lora field is set.
     */
    @java.lang.Override
    public boolean hasLora() {
      return payloadVariantCase_ == 6;
    }
    /**
     * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
     * @return The lora.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig getLora() {
      if (payloadVariantCase_ == 6) {
         return (com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.LoRaConfigOrBuilder getLoraOrBuilder() {
      if (payloadVariantCase_ == 6) {
         return (com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance();
    }

    public static final int BLUETOOTH_FIELD_NUMBER = 7;
    /**
     * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
     * @return Whether the bluetooth field is set.
     */
    @java.lang.Override
    public boolean hasBluetooth() {
      return payloadVariantCase_ == 7;
    }
    /**
     * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
     * @return The bluetooth.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig getBluetooth() {
      if (payloadVariantCase_ == 7) {
         return (com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfigOrBuilder getBluetoothOrBuilder() {
      if (payloadVariantCase_ == 7) {
         return (com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance();
    }

    public static final int SECURITY_FIELD_NUMBER = 8;
    /**
     * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
     * @return Whether the security field is set.
     */
    @java.lang.Override
    public boolean hasSecurity() {
      return payloadVariantCase_ == 8;
    }
    /**
     * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
     * @return The security.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.SecurityConfig getSecurity() {
      if (payloadVariantCase_ == 8) {
         return (com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.SecurityConfigOrBuilder getSecurityOrBuilder() {
      if (payloadVariantCase_ == 8) {
         return (com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance();
    }

    public static final int SESSIONKEY_FIELD_NUMBER = 9;
    /**
     * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
     * @return Whether the sessionkey field is set.
     */
    @java.lang.Override
    public boolean hasSessionkey() {
      return payloadVariantCase_ == 9;
    }
    /**
     * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
     * @return The sessionkey.
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig getSessionkey() {
      if (payloadVariantCase_ == 9) {
         return (com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfigOrBuilder getSessionkeyOrBuilder() {
      if (payloadVariantCase_ == 9) {
         return (com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) payloadVariant_;
      }
      return com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance();
    }

    public static final int DEVICE_UI_FIELD_NUMBER = 10;
    /**
     * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
     * @return Whether the deviceUi field is set.
     */
    @java.lang.Override
    public boolean hasDeviceUi() {
      return payloadVariantCase_ == 10;
    }
    /**
     * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
     * @return The deviceUi.
     */
    @java.lang.Override
    public com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig getDeviceUi() {
      if (payloadVariantCase_ == 10) {
         return (com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig) payloadVariant_;
      }
      return com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.getDefaultInstance();
    }
    /**
     * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.DeviceUIProtos.DeviceUIConfigOrBuilder getDeviceUiOrBuilder() {
      if (payloadVariantCase_ == 10) {
         return (com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig) payloadVariant_;
      }
      return com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (payloadVariantCase_ == 1) {
        output.writeMessage(1, (com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 2) {
        output.writeMessage(2, (com.geeksville.mesh.ConfigProtos.Config.PositionConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 3) {
        output.writeMessage(3, (com.geeksville.mesh.ConfigProtos.Config.PowerConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 4) {
        output.writeMessage(4, (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 5) {
        output.writeMessage(5, (com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 6) {
        output.writeMessage(6, (com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 7) {
        output.writeMessage(7, (com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 8) {
        output.writeMessage(8, (com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 9) {
        output.writeMessage(9, (com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 10) {
        output.writeMessage(10, (com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig) payloadVariant_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (payloadVariantCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (com.geeksville.mesh.ConfigProtos.Config.PositionConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, (com.geeksville.mesh.ConfigProtos.Config.PowerConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 4) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 5) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, (com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 6) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, (com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 7) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, (com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 8) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, (com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 9) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, (com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) payloadVariant_);
      }
      if (payloadVariantCase_ == 10) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, (com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig) payloadVariant_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.geeksville.mesh.ConfigProtos.Config)) {
        return super.equals(obj);
      }
      com.geeksville.mesh.ConfigProtos.Config other = (com.geeksville.mesh.ConfigProtos.Config) obj;

      if (!getPayloadVariantCase().equals(other.getPayloadVariantCase())) return false;
      switch (payloadVariantCase_) {
        case 1:
          if (!getDevice()
              .equals(other.getDevice())) return false;
          break;
        case 2:
          if (!getPosition()
              .equals(other.getPosition())) return false;
          break;
        case 3:
          if (!getPower()
              .equals(other.getPower())) return false;
          break;
        case 4:
          if (!getNetwork()
              .equals(other.getNetwork())) return false;
          break;
        case 5:
          if (!getDisplay()
              .equals(other.getDisplay())) return false;
          break;
        case 6:
          if (!getLora()
              .equals(other.getLora())) return false;
          break;
        case 7:
          if (!getBluetooth()
              .equals(other.getBluetooth())) return false;
          break;
        case 8:
          if (!getSecurity()
              .equals(other.getSecurity())) return false;
          break;
        case 9:
          if (!getSessionkey()
              .equals(other.getSessionkey())) return false;
          break;
        case 10:
          if (!getDeviceUi()
              .equals(other.getDeviceUi())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (payloadVariantCase_) {
        case 1:
          hash = (37 * hash) + DEVICE_FIELD_NUMBER;
          hash = (53 * hash) + getDevice().hashCode();
          break;
        case 2:
          hash = (37 * hash) + POSITION_FIELD_NUMBER;
          hash = (53 * hash) + getPosition().hashCode();
          break;
        case 3:
          hash = (37 * hash) + POWER_FIELD_NUMBER;
          hash = (53 * hash) + getPower().hashCode();
          break;
        case 4:
          hash = (37 * hash) + NETWORK_FIELD_NUMBER;
          hash = (53 * hash) + getNetwork().hashCode();
          break;
        case 5:
          hash = (37 * hash) + DISPLAY_FIELD_NUMBER;
          hash = (53 * hash) + getDisplay().hashCode();
          break;
        case 6:
          hash = (37 * hash) + LORA_FIELD_NUMBER;
          hash = (53 * hash) + getLora().hashCode();
          break;
        case 7:
          hash = (37 * hash) + BLUETOOTH_FIELD_NUMBER;
          hash = (53 * hash) + getBluetooth().hashCode();
          break;
        case 8:
          hash = (37 * hash) + SECURITY_FIELD_NUMBER;
          hash = (53 * hash) + getSecurity().hashCode();
          break;
        case 9:
          hash = (37 * hash) + SESSIONKEY_FIELD_NUMBER;
          hash = (53 * hash) + getSessionkey().hashCode();
          break;
        case 10:
          hash = (37 * hash) + DEVICE_UI_FIELD_NUMBER;
          hash = (53 * hash) + getDeviceUi().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.geeksville.mesh.ConfigProtos.Config parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.geeksville.mesh.ConfigProtos.Config parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.geeksville.mesh.ConfigProtos.Config parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.geeksville.mesh.ConfigProtos.Config prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code meshtastic.Config}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:meshtastic.Config)
        com.geeksville.mesh.ConfigProtos.ConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.ConfigProtos.Config.class, com.geeksville.mesh.ConfigProtos.Config.Builder.class);
      }

      // Construct using com.geeksville.mesh.ConfigProtos.Config.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (deviceBuilder_ != null) {
          deviceBuilder_.clear();
        }
        if (positionBuilder_ != null) {
          positionBuilder_.clear();
        }
        if (powerBuilder_ != null) {
          powerBuilder_.clear();
        }
        if (networkBuilder_ != null) {
          networkBuilder_.clear();
        }
        if (displayBuilder_ != null) {
          displayBuilder_.clear();
        }
        if (loraBuilder_ != null) {
          loraBuilder_.clear();
        }
        if (bluetoothBuilder_ != null) {
          bluetoothBuilder_.clear();
        }
        if (securityBuilder_ != null) {
          securityBuilder_.clear();
        }
        if (sessionkeyBuilder_ != null) {
          sessionkeyBuilder_.clear();
        }
        if (deviceUiBuilder_ != null) {
          deviceUiBuilder_.clear();
        }
        payloadVariantCase_ = 0;
        payloadVariant_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.geeksville.mesh.ConfigProtos.internal_static_meshtastic_Config_descriptor;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config getDefaultInstanceForType() {
        return com.geeksville.mesh.ConfigProtos.Config.getDefaultInstance();
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config build() {
        com.geeksville.mesh.ConfigProtos.Config result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config buildPartial() {
        com.geeksville.mesh.ConfigProtos.Config result = new com.geeksville.mesh.ConfigProtos.Config(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(com.geeksville.mesh.ConfigProtos.Config result) {
        int from_bitField0_ = bitField0_;
      }

      private void buildPartialOneofs(com.geeksville.mesh.ConfigProtos.Config result) {
        result.payloadVariantCase_ = payloadVariantCase_;
        result.payloadVariant_ = this.payloadVariant_;
        if (payloadVariantCase_ == 1 &&
            deviceBuilder_ != null) {
          result.payloadVariant_ = deviceBuilder_.build();
        }
        if (payloadVariantCase_ == 2 &&
            positionBuilder_ != null) {
          result.payloadVariant_ = positionBuilder_.build();
        }
        if (payloadVariantCase_ == 3 &&
            powerBuilder_ != null) {
          result.payloadVariant_ = powerBuilder_.build();
        }
        if (payloadVariantCase_ == 4 &&
            networkBuilder_ != null) {
          result.payloadVariant_ = networkBuilder_.build();
        }
        if (payloadVariantCase_ == 5 &&
            displayBuilder_ != null) {
          result.payloadVariant_ = displayBuilder_.build();
        }
        if (payloadVariantCase_ == 6 &&
            loraBuilder_ != null) {
          result.payloadVariant_ = loraBuilder_.build();
        }
        if (payloadVariantCase_ == 7 &&
            bluetoothBuilder_ != null) {
          result.payloadVariant_ = bluetoothBuilder_.build();
        }
        if (payloadVariantCase_ == 8 &&
            securityBuilder_ != null) {
          result.payloadVariant_ = securityBuilder_.build();
        }
        if (payloadVariantCase_ == 9 &&
            sessionkeyBuilder_ != null) {
          result.payloadVariant_ = sessionkeyBuilder_.build();
        }
        if (payloadVariantCase_ == 10 &&
            deviceUiBuilder_ != null) {
          result.payloadVariant_ = deviceUiBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.geeksville.mesh.ConfigProtos.Config) {
          return mergeFrom((com.geeksville.mesh.ConfigProtos.Config)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.geeksville.mesh.ConfigProtos.Config other) {
        if (other == com.geeksville.mesh.ConfigProtos.Config.getDefaultInstance()) return this;
        switch (other.getPayloadVariantCase()) {
          case DEVICE: {
            mergeDevice(other.getDevice());
            break;
          }
          case POSITION: {
            mergePosition(other.getPosition());
            break;
          }
          case POWER: {
            mergePower(other.getPower());
            break;
          }
          case NETWORK: {
            mergeNetwork(other.getNetwork());
            break;
          }
          case DISPLAY: {
            mergeDisplay(other.getDisplay());
            break;
          }
          case LORA: {
            mergeLora(other.getLora());
            break;
          }
          case BLUETOOTH: {
            mergeBluetooth(other.getBluetooth());
            break;
          }
          case SECURITY: {
            mergeSecurity(other.getSecurity());
            break;
          }
          case SESSIONKEY: {
            mergeSessionkey(other.getSessionkey());
            break;
          }
          case DEVICE_UI: {
            mergeDeviceUi(other.getDeviceUi());
            break;
          }
          case PAYLOADVARIANT_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getDeviceFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 1;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getPositionFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 2;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getPowerFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 3;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getNetworkFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 4;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getDisplayFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 5;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    getLoraFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 6;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getBluetoothFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 7;
                break;
              } // case 58
              case 66: {
                input.readMessage(
                    getSecurityFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 8;
                break;
              } // case 66
              case 74: {
                input.readMessage(
                    getSessionkeyFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 9;
                break;
              } // case 74
              case 82: {
                input.readMessage(
                    getDeviceUiFieldBuilder().getBuilder(),
                    extensionRegistry);
                payloadVariantCase_ = 10;
                break;
              } // case 82
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int payloadVariantCase_ = 0;
      private java.lang.Object payloadVariant_;
      public PayloadVariantCase
          getPayloadVariantCase() {
        return PayloadVariantCase.forNumber(
            payloadVariantCase_);
      }

      public Builder clearPayloadVariant() {
        payloadVariantCase_ = 0;
        payloadVariant_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfig, com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.DeviceConfigOrBuilder> deviceBuilder_;
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       * @return Whether the device field is set.
       */
      @java.lang.Override
      public boolean hasDevice() {
        return payloadVariantCase_ == 1;
      }
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       * @return The device.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig getDevice() {
        if (deviceBuilder_ == null) {
          if (payloadVariantCase_ == 1) {
            return (com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 1) {
            return deviceBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       */
      public Builder setDevice(com.geeksville.mesh.ConfigProtos.Config.DeviceConfig value) {
        if (deviceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          deviceBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 1;
        return this;
      }
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       */
      public Builder setDevice(
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Builder builderForValue) {
        if (deviceBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          deviceBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 1;
        return this;
      }
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       */
      public Builder mergeDevice(com.geeksville.mesh.ConfigProtos.Config.DeviceConfig value) {
        if (deviceBuilder_ == null) {
          if (payloadVariantCase_ == 1 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 1) {
            deviceBuilder_.mergeFrom(value);
          } else {
            deviceBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 1;
        return this;
      }
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       */
      public Builder clearDevice() {
        if (deviceBuilder_ == null) {
          if (payloadVariantCase_ == 1) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 1) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          deviceBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Builder getDeviceBuilder() {
        return getDeviceFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.DeviceConfigOrBuilder getDeviceOrBuilder() {
        if ((payloadVariantCase_ == 1) && (deviceBuilder_ != null)) {
          return deviceBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 1) {
            return (com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.DeviceConfig device = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.DeviceConfig, com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.DeviceConfigOrBuilder> 
          getDeviceFieldBuilder() {
        if (deviceBuilder_ == null) {
          if (!(payloadVariantCase_ == 1)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.getDefaultInstance();
          }
          deviceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.DeviceConfig, com.geeksville.mesh.ConfigProtos.Config.DeviceConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.DeviceConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.DeviceConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 1;
        onChanged();
        return deviceBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.PositionConfig, com.geeksville.mesh.ConfigProtos.Config.PositionConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.PositionConfigOrBuilder> positionBuilder_;
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       * @return Whether the position field is set.
       */
      @java.lang.Override
      public boolean hasPosition() {
        return payloadVariantCase_ == 2;
      }
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       * @return The position.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.PositionConfig getPosition() {
        if (positionBuilder_ == null) {
          if (payloadVariantCase_ == 2) {
            return (com.geeksville.mesh.ConfigProtos.Config.PositionConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 2) {
            return positionBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       */
      public Builder setPosition(com.geeksville.mesh.ConfigProtos.Config.PositionConfig value) {
        if (positionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          positionBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 2;
        return this;
      }
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       */
      public Builder setPosition(
          com.geeksville.mesh.ConfigProtos.Config.PositionConfig.Builder builderForValue) {
        if (positionBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          positionBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 2;
        return this;
      }
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       */
      public Builder mergePosition(com.geeksville.mesh.ConfigProtos.Config.PositionConfig value) {
        if (positionBuilder_ == null) {
          if (payloadVariantCase_ == 2 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.PositionConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.PositionConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 2) {
            positionBuilder_.mergeFrom(value);
          } else {
            positionBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 2;
        return this;
      }
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       */
      public Builder clearPosition() {
        if (positionBuilder_ == null) {
          if (payloadVariantCase_ == 2) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 2) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          positionBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.PositionConfig.Builder getPositionBuilder() {
        return getPositionFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.PositionConfigOrBuilder getPositionOrBuilder() {
        if ((payloadVariantCase_ == 2) && (positionBuilder_ != null)) {
          return positionBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 2) {
            return (com.geeksville.mesh.ConfigProtos.Config.PositionConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.PositionConfig position = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.PositionConfig, com.geeksville.mesh.ConfigProtos.Config.PositionConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.PositionConfigOrBuilder> 
          getPositionFieldBuilder() {
        if (positionBuilder_ == null) {
          if (!(payloadVariantCase_ == 2)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.PositionConfig.getDefaultInstance();
          }
          positionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.PositionConfig, com.geeksville.mesh.ConfigProtos.Config.PositionConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.PositionConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.PositionConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 2;
        onChanged();
        return positionBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.PowerConfig, com.geeksville.mesh.ConfigProtos.Config.PowerConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.PowerConfigOrBuilder> powerBuilder_;
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       * @return Whether the power field is set.
       */
      @java.lang.Override
      public boolean hasPower() {
        return payloadVariantCase_ == 3;
      }
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       * @return The power.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.PowerConfig getPower() {
        if (powerBuilder_ == null) {
          if (payloadVariantCase_ == 3) {
            return (com.geeksville.mesh.ConfigProtos.Config.PowerConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 3) {
            return powerBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       */
      public Builder setPower(com.geeksville.mesh.ConfigProtos.Config.PowerConfig value) {
        if (powerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          powerBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 3;
        return this;
      }
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       */
      public Builder setPower(
          com.geeksville.mesh.ConfigProtos.Config.PowerConfig.Builder builderForValue) {
        if (powerBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          powerBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 3;
        return this;
      }
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       */
      public Builder mergePower(com.geeksville.mesh.ConfigProtos.Config.PowerConfig value) {
        if (powerBuilder_ == null) {
          if (payloadVariantCase_ == 3 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.PowerConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.PowerConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 3) {
            powerBuilder_.mergeFrom(value);
          } else {
            powerBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 3;
        return this;
      }
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       */
      public Builder clearPower() {
        if (powerBuilder_ == null) {
          if (payloadVariantCase_ == 3) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 3) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          powerBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.PowerConfig.Builder getPowerBuilder() {
        return getPowerFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.PowerConfigOrBuilder getPowerOrBuilder() {
        if ((payloadVariantCase_ == 3) && (powerBuilder_ != null)) {
          return powerBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 3) {
            return (com.geeksville.mesh.ConfigProtos.Config.PowerConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.PowerConfig power = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.PowerConfig, com.geeksville.mesh.ConfigProtos.Config.PowerConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.PowerConfigOrBuilder> 
          getPowerFieldBuilder() {
        if (powerBuilder_ == null) {
          if (!(payloadVariantCase_ == 3)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.PowerConfig.getDefaultInstance();
          }
          powerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.PowerConfig, com.geeksville.mesh.ConfigProtos.Config.PowerConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.PowerConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.PowerConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 3;
        onChanged();
        return powerBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.NetworkConfig, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.NetworkConfigOrBuilder> networkBuilder_;
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       * @return Whether the network field is set.
       */
      @java.lang.Override
      public boolean hasNetwork() {
        return payloadVariantCase_ == 4;
      }
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       * @return The network.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig getNetwork() {
        if (networkBuilder_ == null) {
          if (payloadVariantCase_ == 4) {
            return (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 4) {
            return networkBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       */
      public Builder setNetwork(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig value) {
        if (networkBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          networkBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 4;
        return this;
      }
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       */
      public Builder setNetwork(
          com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.Builder builderForValue) {
        if (networkBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          networkBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 4;
        return this;
      }
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       */
      public Builder mergeNetwork(com.geeksville.mesh.ConfigProtos.Config.NetworkConfig value) {
        if (networkBuilder_ == null) {
          if (payloadVariantCase_ == 4 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 4) {
            networkBuilder_.mergeFrom(value);
          } else {
            networkBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 4;
        return this;
      }
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       */
      public Builder clearNetwork() {
        if (networkBuilder_ == null) {
          if (payloadVariantCase_ == 4) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 4) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          networkBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.Builder getNetworkBuilder() {
        return getNetworkFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.NetworkConfigOrBuilder getNetworkOrBuilder() {
        if ((payloadVariantCase_ == 4) && (networkBuilder_ != null)) {
          return networkBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 4) {
            return (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.NetworkConfig network = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.NetworkConfig, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.NetworkConfigOrBuilder> 
          getNetworkFieldBuilder() {
        if (networkBuilder_ == null) {
          if (!(payloadVariantCase_ == 4)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.getDefaultInstance();
          }
          networkBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.NetworkConfig, com.geeksville.mesh.ConfigProtos.Config.NetworkConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.NetworkConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.NetworkConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 4;
        onChanged();
        return networkBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig, com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.DisplayConfigOrBuilder> displayBuilder_;
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       * @return Whether the display field is set.
       */
      @java.lang.Override
      public boolean hasDisplay() {
        return payloadVariantCase_ == 5;
      }
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       * @return The display.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig getDisplay() {
        if (displayBuilder_ == null) {
          if (payloadVariantCase_ == 5) {
            return (com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 5) {
            return displayBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       */
      public Builder setDisplay(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig value) {
        if (displayBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          displayBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 5;
        return this;
      }
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       */
      public Builder setDisplay(
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.Builder builderForValue) {
        if (displayBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          displayBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 5;
        return this;
      }
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       */
      public Builder mergeDisplay(com.geeksville.mesh.ConfigProtos.Config.DisplayConfig value) {
        if (displayBuilder_ == null) {
          if (payloadVariantCase_ == 5 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 5) {
            displayBuilder_.mergeFrom(value);
          } else {
            displayBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 5;
        return this;
      }
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       */
      public Builder clearDisplay() {
        if (displayBuilder_ == null) {
          if (payloadVariantCase_ == 5) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 5) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          displayBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.Builder getDisplayBuilder() {
        return getDisplayFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.DisplayConfigOrBuilder getDisplayOrBuilder() {
        if ((payloadVariantCase_ == 5) && (displayBuilder_ != null)) {
          return displayBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 5) {
            return (com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.DisplayConfig display = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.DisplayConfig, com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.DisplayConfigOrBuilder> 
          getDisplayFieldBuilder() {
        if (displayBuilder_ == null) {
          if (!(payloadVariantCase_ == 5)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.getDefaultInstance();
          }
          displayBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.DisplayConfig, com.geeksville.mesh.ConfigProtos.Config.DisplayConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.DisplayConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.DisplayConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 5;
        onChanged();
        return displayBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.LoRaConfig, com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.LoRaConfigOrBuilder> loraBuilder_;
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       * @return Whether the lora field is set.
       */
      @java.lang.Override
      public boolean hasLora() {
        return payloadVariantCase_ == 6;
      }
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       * @return The lora.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig getLora() {
        if (loraBuilder_ == null) {
          if (payloadVariantCase_ == 6) {
            return (com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 6) {
            return loraBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       */
      public Builder setLora(com.geeksville.mesh.ConfigProtos.Config.LoRaConfig value) {
        if (loraBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          loraBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 6;
        return this;
      }
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       */
      public Builder setLora(
          com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.Builder builderForValue) {
        if (loraBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          loraBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 6;
        return this;
      }
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       */
      public Builder mergeLora(com.geeksville.mesh.ConfigProtos.Config.LoRaConfig value) {
        if (loraBuilder_ == null) {
          if (payloadVariantCase_ == 6 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 6) {
            loraBuilder_.mergeFrom(value);
          } else {
            loraBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 6;
        return this;
      }
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       */
      public Builder clearLora() {
        if (loraBuilder_ == null) {
          if (payloadVariantCase_ == 6) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 6) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          loraBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.Builder getLoraBuilder() {
        return getLoraFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.LoRaConfigOrBuilder getLoraOrBuilder() {
        if ((payloadVariantCase_ == 6) && (loraBuilder_ != null)) {
          return loraBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 6) {
            return (com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.LoRaConfig lora = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.LoRaConfig, com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.LoRaConfigOrBuilder> 
          getLoraFieldBuilder() {
        if (loraBuilder_ == null) {
          if (!(payloadVariantCase_ == 6)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.getDefaultInstance();
          }
          loraBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.LoRaConfig, com.geeksville.mesh.ConfigProtos.Config.LoRaConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.LoRaConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.LoRaConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 6;
        onChanged();
        return loraBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig, com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.BluetoothConfigOrBuilder> bluetoothBuilder_;
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       * @return Whether the bluetooth field is set.
       */
      @java.lang.Override
      public boolean hasBluetooth() {
        return payloadVariantCase_ == 7;
      }
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       * @return The bluetooth.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig getBluetooth() {
        if (bluetoothBuilder_ == null) {
          if (payloadVariantCase_ == 7) {
            return (com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 7) {
            return bluetoothBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       */
      public Builder setBluetooth(com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig value) {
        if (bluetoothBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          bluetoothBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 7;
        return this;
      }
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       */
      public Builder setBluetooth(
          com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.Builder builderForValue) {
        if (bluetoothBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          bluetoothBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 7;
        return this;
      }
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       */
      public Builder mergeBluetooth(com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig value) {
        if (bluetoothBuilder_ == null) {
          if (payloadVariantCase_ == 7 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 7) {
            bluetoothBuilder_.mergeFrom(value);
          } else {
            bluetoothBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 7;
        return this;
      }
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       */
      public Builder clearBluetooth() {
        if (bluetoothBuilder_ == null) {
          if (payloadVariantCase_ == 7) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 7) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          bluetoothBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.Builder getBluetoothBuilder() {
        return getBluetoothFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.BluetoothConfigOrBuilder getBluetoothOrBuilder() {
        if ((payloadVariantCase_ == 7) && (bluetoothBuilder_ != null)) {
          return bluetoothBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 7) {
            return (com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.BluetoothConfig bluetooth = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig, com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.BluetoothConfigOrBuilder> 
          getBluetoothFieldBuilder() {
        if (bluetoothBuilder_ == null) {
          if (!(payloadVariantCase_ == 7)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.getDefaultInstance();
          }
          bluetoothBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig, com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.BluetoothConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.BluetoothConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 7;
        onChanged();
        return bluetoothBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.SecurityConfig, com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.SecurityConfigOrBuilder> securityBuilder_;
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       * @return Whether the security field is set.
       */
      @java.lang.Override
      public boolean hasSecurity() {
        return payloadVariantCase_ == 8;
      }
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       * @return The security.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.SecurityConfig getSecurity() {
        if (securityBuilder_ == null) {
          if (payloadVariantCase_ == 8) {
            return (com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 8) {
            return securityBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       */
      public Builder setSecurity(com.geeksville.mesh.ConfigProtos.Config.SecurityConfig value) {
        if (securityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          securityBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 8;
        return this;
      }
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       */
      public Builder setSecurity(
          com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.Builder builderForValue) {
        if (securityBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          securityBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 8;
        return this;
      }
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       */
      public Builder mergeSecurity(com.geeksville.mesh.ConfigProtos.Config.SecurityConfig value) {
        if (securityBuilder_ == null) {
          if (payloadVariantCase_ == 8 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 8) {
            securityBuilder_.mergeFrom(value);
          } else {
            securityBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 8;
        return this;
      }
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       */
      public Builder clearSecurity() {
        if (securityBuilder_ == null) {
          if (payloadVariantCase_ == 8) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 8) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          securityBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.Builder getSecurityBuilder() {
        return getSecurityFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.SecurityConfigOrBuilder getSecurityOrBuilder() {
        if ((payloadVariantCase_ == 8) && (securityBuilder_ != null)) {
          return securityBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 8) {
            return (com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.SecurityConfig security = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.SecurityConfig, com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.SecurityConfigOrBuilder> 
          getSecurityFieldBuilder() {
        if (securityBuilder_ == null) {
          if (!(payloadVariantCase_ == 8)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.getDefaultInstance();
          }
          securityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.SecurityConfig, com.geeksville.mesh.ConfigProtos.Config.SecurityConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.SecurityConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.SecurityConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 8;
        onChanged();
        return securityBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig, com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfigOrBuilder> sessionkeyBuilder_;
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       * @return Whether the sessionkey field is set.
       */
      @java.lang.Override
      public boolean hasSessionkey() {
        return payloadVariantCase_ == 9;
      }
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       * @return The sessionkey.
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig getSessionkey() {
        if (sessionkeyBuilder_ == null) {
          if (payloadVariantCase_ == 9) {
            return (com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 9) {
            return sessionkeyBuilder_.getMessage();
          }
          return com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       */
      public Builder setSessionkey(com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig value) {
        if (sessionkeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          sessionkeyBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 9;
        return this;
      }
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       */
      public Builder setSessionkey(
          com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.Builder builderForValue) {
        if (sessionkeyBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          sessionkeyBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 9;
        return this;
      }
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       */
      public Builder mergeSessionkey(com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig value) {
        if (sessionkeyBuilder_ == null) {
          if (payloadVariantCase_ == 9 &&
              payloadVariant_ != com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.newBuilder((com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 9) {
            sessionkeyBuilder_.mergeFrom(value);
          } else {
            sessionkeyBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 9;
        return this;
      }
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       */
      public Builder clearSessionkey() {
        if (sessionkeyBuilder_ == null) {
          if (payloadVariantCase_ == 9) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 9) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          sessionkeyBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       */
      public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.Builder getSessionkeyBuilder() {
        return getSessionkeyFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfigOrBuilder getSessionkeyOrBuilder() {
        if ((payloadVariantCase_ == 9) && (sessionkeyBuilder_ != null)) {
          return sessionkeyBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 9) {
            return (com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) payloadVariant_;
          }
          return com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.Config.SessionkeyConfig sessionkey = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig, com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfigOrBuilder> 
          getSessionkeyFieldBuilder() {
        if (sessionkeyBuilder_ == null) {
          if (!(payloadVariantCase_ == 9)) {
            payloadVariant_ = com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.getDefaultInstance();
          }
          sessionkeyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig, com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig.Builder, com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfigOrBuilder>(
                  (com.geeksville.mesh.ConfigProtos.Config.SessionkeyConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 9;
        onChanged();
        return sessionkeyBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig, com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.Builder, com.geeksville.mesh.DeviceUIProtos.DeviceUIConfigOrBuilder> deviceUiBuilder_;
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       * @return Whether the deviceUi field is set.
       */
      @java.lang.Override
      public boolean hasDeviceUi() {
        return payloadVariantCase_ == 10;
      }
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       * @return The deviceUi.
       */
      @java.lang.Override
      public com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig getDeviceUi() {
        if (deviceUiBuilder_ == null) {
          if (payloadVariantCase_ == 10) {
            return (com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig) payloadVariant_;
          }
          return com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.getDefaultInstance();
        } else {
          if (payloadVariantCase_ == 10) {
            return deviceUiBuilder_.getMessage();
          }
          return com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       */
      public Builder setDeviceUi(com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig value) {
        if (deviceUiBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          payloadVariant_ = value;
          onChanged();
        } else {
          deviceUiBuilder_.setMessage(value);
        }
        payloadVariantCase_ = 10;
        return this;
      }
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       */
      public Builder setDeviceUi(
          com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.Builder builderForValue) {
        if (deviceUiBuilder_ == null) {
          payloadVariant_ = builderForValue.build();
          onChanged();
        } else {
          deviceUiBuilder_.setMessage(builderForValue.build());
        }
        payloadVariantCase_ = 10;
        return this;
      }
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       */
      public Builder mergeDeviceUi(com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig value) {
        if (deviceUiBuilder_ == null) {
          if (payloadVariantCase_ == 10 &&
              payloadVariant_ != com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.getDefaultInstance()) {
            payloadVariant_ = com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.newBuilder((com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig) payloadVariant_)
                .mergeFrom(value).buildPartial();
          } else {
            payloadVariant_ = value;
          }
          onChanged();
        } else {
          if (payloadVariantCase_ == 10) {
            deviceUiBuilder_.mergeFrom(value);
          } else {
            deviceUiBuilder_.setMessage(value);
          }
        }
        payloadVariantCase_ = 10;
        return this;
      }
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       */
      public Builder clearDeviceUi() {
        if (deviceUiBuilder_ == null) {
          if (payloadVariantCase_ == 10) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
            onChanged();
          }
        } else {
          if (payloadVariantCase_ == 10) {
            payloadVariantCase_ = 0;
            payloadVariant_ = null;
          }
          deviceUiBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       */
      public com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.Builder getDeviceUiBuilder() {
        return getDeviceUiFieldBuilder().getBuilder();
      }
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       */
      @java.lang.Override
      public com.geeksville.mesh.DeviceUIProtos.DeviceUIConfigOrBuilder getDeviceUiOrBuilder() {
        if ((payloadVariantCase_ == 10) && (deviceUiBuilder_ != null)) {
          return deviceUiBuilder_.getMessageOrBuilder();
        } else {
          if (payloadVariantCase_ == 10) {
            return (com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig) payloadVariant_;
          }
          return com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.meshtastic.DeviceUIConfig device_ui = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig, com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.Builder, com.geeksville.mesh.DeviceUIProtos.DeviceUIConfigOrBuilder> 
          getDeviceUiFieldBuilder() {
        if (deviceUiBuilder_ == null) {
          if (!(payloadVariantCase_ == 10)) {
            payloadVariant_ = com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.getDefaultInstance();
          }
          deviceUiBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig, com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig.Builder, com.geeksville.mesh.DeviceUIProtos.DeviceUIConfigOrBuilder>(
                  (com.geeksville.mesh.DeviceUIProtos.DeviceUIConfig) payloadVariant_,
                  getParentForChildren(),
                  isClean());
          payloadVariant_ = null;
        }
        payloadVariantCase_ = 10;
        onChanged();
        return deviceUiBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:meshtastic.Config)
    }

    // @@protoc_insertion_point(class_scope:meshtastic.Config)
    private static final com.geeksville.mesh.ConfigProtos.Config DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.geeksville.mesh.ConfigProtos.Config();
    }

    public static com.geeksville.mesh.ConfigProtos.Config getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Config>
        PARSER = new com.google.protobuf.AbstractParser<Config>() {
      @java.lang.Override
      public Config parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Config> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Config> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.geeksville.mesh.ConfigProtos.Config getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_DeviceConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_DeviceConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_PositionConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_PositionConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_PowerConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_PowerConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_NetworkConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_NetworkConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_NetworkConfig_IpV4Config_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_NetworkConfig_IpV4Config_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_DisplayConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_DisplayConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_LoRaConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_LoRaConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_BluetoothConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_BluetoothConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_SecurityConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_SecurityConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_meshtastic_Config_SessionkeyConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_meshtastic_Config_SessionkeyConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\027meshtastic/config.proto\022\nmeshtastic\032\032m" +
      "eshtastic/device_ui.proto\"\215)\n\006Config\0221\n\006" +
      "device\030\001 \001(\0132\037.meshtastic.Config.DeviceC" +
      "onfigH\000\0225\n\010position\030\002 \001(\0132!.meshtastic.C" +
      "onfig.PositionConfigH\000\022/\n\005power\030\003 \001(\0132\036." +
      "meshtastic.Config.PowerConfigH\000\0223\n\007netwo" +
      "rk\030\004 \001(\0132 .meshtastic.Config.NetworkConf" +
      "igH\000\0223\n\007display\030\005 \001(\0132 .meshtastic.Confi" +
      "g.DisplayConfigH\000\022-\n\004lora\030\006 \001(\0132\035.meshta" +
      "stic.Config.LoRaConfigH\000\0227\n\tbluetooth\030\007 " +
      "\001(\0132\".meshtastic.Config.BluetoothConfigH" +
      "\000\0225\n\010security\030\010 \001(\0132!.meshtastic.Config." +
      "SecurityConfigH\000\0229\n\nsessionkey\030\t \001(\0132#.m" +
      "eshtastic.Config.SessionkeyConfigH\000\022/\n\td" +
      "evice_ui\030\n \001(\0132\032.meshtastic.DeviceUIConf" +
      "igH\000\032\366\006\n\014DeviceConfig\0222\n\004role\030\001 \001(\0162$.me" +
      "shtastic.Config.DeviceConfig.Role\022\032\n\016ser" +
      "ial_enabled\030\002 \001(\010B\002\030\001\022\023\n\013button_gpio\030\004 \001" +
      "(\r\022\023\n\013buzzer_gpio\030\005 \001(\r\022I\n\020rebroadcast_m" +
      "ode\030\006 \001(\0162/.meshtastic.Config.DeviceConf" +
      "ig.RebroadcastMode\022 \n\030node_info_broadcas" +
      "t_secs\030\007 \001(\r\022\"\n\032double_tap_as_button_pre" +
      "ss\030\010 \001(\010\022\026\n\nis_managed\030\t \001(\010B\002\030\001\022\034\n\024disa" +
      "ble_triple_click\030\n \001(\010\022\r\n\005tzdef\030\013 \001(\t\022\036\n" +
      "\026led_heartbeat_disabled\030\014 \001(\010\022?\n\013buzzer_" +
      "mode\030\r \001(\0162*.meshtastic.Config.DeviceCon" +
      "fig.BuzzerMode\"\324\001\n\004Role\022\n\n\006CLIENT\020\000\022\017\n\013C" +
      "LIENT_MUTE\020\001\022\n\n\006ROUTER\020\002\022\025\n\rROUTER_CLIEN" +
      "T\020\003\032\002\010\001\022\020\n\010REPEATER\020\004\032\002\010\001\022\013\n\007TRACKER\020\005\022\n" +
      "\n\006SENSOR\020\006\022\007\n\003TAK\020\007\022\021\n\rCLIENT_HIDDEN\020\010\022\022" +
      "\n\016LOST_AND_FOUND\020\t\022\017\n\013TAK_TRACKER\020\n\022\017\n\013R" +
      "OUTER_LATE\020\013\022\017\n\013CLIENT_BASE\020\014\"s\n\017Rebroad" +
      "castMode\022\007\n\003ALL\020\000\022\025\n\021ALL_SKIP_DECODING\020\001" +
      "\022\016\n\nLOCAL_ONLY\020\002\022\016\n\nKNOWN_ONLY\020\003\022\010\n\004NONE" +
      "\020\004\022\026\n\022CORE_PORTNUMS_ONLY\020\005\"i\n\nBuzzerMode" +
      "\022\017\n\013ALL_ENABLED\020\000\022\014\n\010DISABLED\020\001\022\026\n\022NOTIF" +
      "ICATIONS_ONLY\020\002\022\017\n\013SYSTEM_ONLY\020\003\022\023\n\017DIRE" +
      "CT_MSG_ONLY\020\004\032\221\005\n\016PositionConfig\022\037\n\027posi" +
      "tion_broadcast_secs\030\001 \001(\r\022(\n position_br" +
      "oadcast_smart_enabled\030\002 \001(\010\022\026\n\016fixed_pos" +
      "ition\030\003 \001(\010\022\027\n\013gps_enabled\030\004 \001(\010B\002\030\001\022\033\n\023" +
      "gps_update_interval\030\005 \001(\r\022\034\n\020gps_attempt" +
      "_time\030\006 \001(\rB\002\030\001\022\026\n\016position_flags\030\007 \001(\r\022" +
      "\017\n\007rx_gpio\030\010 \001(\r\022\017\n\007tx_gpio\030\t \001(\r\022(\n bro" +
      "adcast_smart_minimum_distance\030\n \001(\r\022-\n%b" +
      "roadcast_smart_minimum_interval_secs\030\013 \001" +
      "(\r\022\023\n\013gps_en_gpio\030\014 \001(\r\022;\n\010gps_mode\030\r \001(" +
      "\0162).meshtastic.Config.PositionConfig.Gps" +
      "Mode\"\253\001\n\rPositionFlags\022\t\n\005UNSET\020\000\022\014\n\010ALT" +
      "ITUDE\020\001\022\020\n\014ALTITUDE_MSL\020\002\022\026\n\022GEOIDAL_SEP" +
      "ARATION\020\004\022\007\n\003DOP\020\010\022\t\n\005HVDOP\020\020\022\r\n\tSATINVI" +
      "EW\020 \022\n\n\006SEQ_NO\020@\022\016\n\tTIMESTAMP\020\200\001\022\014\n\007HEAD" +
      "ING\020\200\002\022\n\n\005SPEED\020\200\004\"5\n\007GpsMode\022\014\n\010DISABLE" +
      "D\020\000\022\013\n\007ENABLED\020\001\022\017\n\013NOT_PRESENT\020\002\032\204\002\n\013Po" +
      "werConfig\022\027\n\017is_power_saving\030\001 \001(\010\022&\n\036on" +
      "_battery_shutdown_after_secs\030\002 \001(\r\022\037\n\027ad" +
      "c_multiplier_override\030\003 \001(\002\022\033\n\023wait_blue" +
      "tooth_secs\030\004 \001(\r\022\020\n\010sds_secs\030\006 \001(\r\022\017\n\007ls" +
      "_secs\030\007 \001(\r\022\025\n\rmin_wake_secs\030\010 \001(\r\022\"\n\032de" +
      "vice_battery_ina_address\030\t \001(\r\022\030\n\020powerm" +
      "on_enables\030  \001(\004\032\345\003\n\rNetworkConfig\022\024\n\014wi" +
      "fi_enabled\030\001 \001(\010\022\021\n\twifi_ssid\030\003 \001(\t\022\020\n\010w" +
      "ifi_psk\030\004 \001(\t\022\022\n\nntp_server\030\005 \001(\t\022\023\n\013eth" +
      "_enabled\030\006 \001(\010\022B\n\014address_mode\030\007 \001(\0162,.m" +
      "eshtastic.Config.NetworkConfig.AddressMo" +
      "de\022@\n\013ipv4_config\030\010 \001(\0132+.meshtastic.Con" +
      "fig.NetworkConfig.IpV4Config\022\026\n\016rsyslog_" +
      "server\030\t \001(\t\022\031\n\021enabled_protocols\030\n \001(\r\022" +
      "\024\n\014ipv6_enabled\030\013 \001(\010\032F\n\nIpV4Config\022\n\n\002i" +
      "p\030\001 \001(\007\022\017\n\007gateway\030\002 \001(\007\022\016\n\006subnet\030\003 \001(\007" +
      "\022\013\n\003dns\030\004 \001(\007\"#\n\013AddressMode\022\010\n\004DHCP\020\000\022\n" +
      "\n\006STATIC\020\001\"4\n\rProtocolFlags\022\020\n\014NO_BROADC" +
      "AST\020\000\022\021\n\rUDP_BROADCAST\020\001\032\211\010\n\rDisplayConf" +
      "ig\022\026\n\016screen_on_secs\030\001 \001(\r\022V\n\ngps_format" +
      "\030\002 \001(\0162>.meshtastic.Config.DisplayConfig" +
      ".DeprecatedGpsCoordinateFormatB\002\030\001\022!\n\031au" +
      "to_screen_carousel_secs\030\003 \001(\r\022\035\n\021compass" +
      "_north_top\030\004 \001(\010B\002\030\001\022\023\n\013flip_screen\030\005 \001(" +
      "\010\022<\n\005units\030\006 \001(\0162-.meshtastic.Config.Dis" +
      "playConfig.DisplayUnits\0227\n\004oled\030\007 \001(\0162)." +
      "meshtastic.Config.DisplayConfig.OledType" +
      "\022A\n\013displaymode\030\010 \001(\0162,.meshtastic.Confi" +
      "g.DisplayConfig.DisplayMode\022\024\n\014heading_b" +
      "old\030\t \001(\010\022\035\n\025wake_on_tap_or_motion\030\n \001(\010" +
      "\022P\n\023compass_orientation\030\013 \001(\01623.meshtast" +
      "ic.Config.DisplayConfig.CompassOrientati" +
      "on\022\025\n\ruse_12h_clock\030\014 \001(\010\022\032\n\022use_long_no" +
      "de_name\030\r \001(\010\"+\n\035DeprecatedGpsCoordinate" +
      "Format\022\n\n\006UNUSED\020\000\"(\n\014DisplayUnits\022\n\n\006ME" +
      "TRIC\020\000\022\014\n\010IMPERIAL\020\001\"f\n\010OledType\022\r\n\tOLED" +
      "_AUTO\020\000\022\020\n\014OLED_SSD1306\020\001\022\017\n\013OLED_SH1106" +
      "\020\002\022\017\n\013OLED_SH1107\020\003\022\027\n\023OLED_SH1107_128_1" +
      "28\020\004\"A\n\013DisplayMode\022\013\n\007DEFAULT\020\000\022\014\n\010TWOC" +
      "OLOR\020\001\022\014\n\010INVERTED\020\002\022\t\n\005COLOR\020\003\"\272\001\n\022Comp" +
      "assOrientation\022\r\n\tDEGREES_0\020\000\022\016\n\nDEGREES" +
      "_90\020\001\022\017\n\013DEGREES_180\020\002\022\017\n\013DEGREES_270\020\003\022" +
      "\026\n\022DEGREES_0_INVERTED\020\004\022\027\n\023DEGREES_90_IN" +
      "VERTED\020\005\022\030\n\024DEGREES_180_INVERTED\020\006\022\030\n\024DE" +
      "GREES_270_INVERTED\020\007\032\332\007\n\nLoRaConfig\022\022\n\nu" +
      "se_preset\030\001 \001(\010\022?\n\014modem_preset\030\002 \001(\0162)." +
      "meshtastic.Config.LoRaConfig.ModemPreset" +
      "\022\021\n\tbandwidth\030\003 \001(\r\022\025\n\rspread_factor\030\004 \001" +
      "(\r\022\023\n\013coding_rate\030\005 \001(\r\022\030\n\020frequency_off" +
      "set\030\006 \001(\002\0228\n\006region\030\007 \001(\0162(.meshtastic.C" +
      "onfig.LoRaConfig.RegionCode\022\021\n\thop_limit" +
      "\030\010 \001(\r\022\022\n\ntx_enabled\030\t \001(\010\022\020\n\010tx_power\030\n" +
      " \001(\005\022\023\n\013channel_num\030\013 \001(\r\022\033\n\023override_du" +
      "ty_cycle\030\014 \001(\010\022\036\n\026sx126x_rx_boosted_gain" +
      "\030\r \001(\010\022\032\n\022override_frequency\030\016 \001(\002\022\027\n\017pa" +
      "_fan_disabled\030\017 \001(\010\022\027\n\017ignore_incoming\030g" +
      " \003(\r\022\023\n\013ignore_mqtt\030h \001(\010\022\031\n\021config_ok_t" +
      "o_mqtt\030i \001(\010\"\256\002\n\nRegionCode\022\t\n\005UNSET\020\000\022\006" +
      "\n\002US\020\001\022\n\n\006EU_433\020\002\022\n\n\006EU_868\020\003\022\006\n\002CN\020\004\022\006" +
      "\n\002JP\020\005\022\007\n\003ANZ\020\006\022\006\n\002KR\020\007\022\006\n\002TW\020\010\022\006\n\002RU\020\t\022" +
      "\006\n\002IN\020\n\022\n\n\006NZ_865\020\013\022\006\n\002TH\020\014\022\013\n\007LORA_24\020\r" +
      "\022\n\n\006UA_433\020\016\022\n\n\006UA_868\020\017\022\n\n\006MY_433\020\020\022\n\n\006" +
      "MY_919\020\021\022\n\n\006SG_923\020\022\022\n\n\006PH_433\020\023\022\n\n\006PH_8" +
      "68\020\024\022\n\n\006PH_915\020\025\022\013\n\007ANZ_433\020\026\022\n\n\006KZ_433\020" +
      "\027\022\n\n\006KZ_863\020\030\022\n\n\006NP_865\020\031\022\n\n\006BR_902\020\032\"\251\001" +
      "\n\013ModemPreset\022\r\n\tLONG_FAST\020\000\022\r\n\tLONG_SLO" +
      "W\020\001\022\026\n\016VERY_LONG_SLOW\020\002\032\002\010\001\022\017\n\013MEDIUM_SL" +
      "OW\020\003\022\017\n\013MEDIUM_FAST\020\004\022\016\n\nSHORT_SLOW\020\005\022\016\n" +
      "\nSHORT_FAST\020\006\022\021\n\rLONG_MODERATE\020\007\022\017\n\013SHOR" +
      "T_TURBO\020\010\032\255\001\n\017BluetoothConfig\022\017\n\007enabled" +
      "\030\001 \001(\010\022<\n\004mode\030\002 \001(\0162..meshtastic.Config" +
      ".BluetoothConfig.PairingMode\022\021\n\tfixed_pi" +
      "n\030\003 \001(\r\"8\n\013PairingMode\022\016\n\nRANDOM_PIN\020\000\022\r" +
      "\n\tFIXED_PIN\020\001\022\n\n\006NO_PIN\020\002\032\266\001\n\016SecurityCo" +
      "nfig\022\022\n\npublic_key\030\001 \001(\014\022\023\n\013private_key\030" +
      "\002 \001(\014\022\021\n\tadmin_key\030\003 \003(\014\022\022\n\nis_managed\030\004" +
      " \001(\010\022\026\n\016serial_enabled\030\005 \001(\010\022\035\n\025debug_lo" +
      "g_api_enabled\030\006 \001(\010\022\035\n\025admin_channel_ena" +
      "bled\030\010 \001(\010\032\022\n\020SessionkeyConfigB\021\n\017payloa" +
      "d_variantBa\n\023com.geeksville.meshB\014Config" +
      "ProtosZ\"github.com/meshtastic/go/generat" +
      "ed\252\002\024Meshtastic.Protobufs\272\002\000b\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.geeksville.mesh.DeviceUIProtos.getDescriptor(),
        });
    internal_static_meshtastic_Config_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_meshtastic_Config_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_descriptor,
        new java.lang.String[] { "Device", "Position", "Power", "Network", "Display", "Lora", "Bluetooth", "Security", "Sessionkey", "DeviceUi", "PayloadVariant", });
    internal_static_meshtastic_Config_DeviceConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(0);
    internal_static_meshtastic_Config_DeviceConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_DeviceConfig_descriptor,
        new java.lang.String[] { "Role", "SerialEnabled", "ButtonGpio", "BuzzerGpio", "RebroadcastMode", "NodeInfoBroadcastSecs", "DoubleTapAsButtonPress", "IsManaged", "DisableTripleClick", "Tzdef", "LedHeartbeatDisabled", "BuzzerMode", });
    internal_static_meshtastic_Config_PositionConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(1);
    internal_static_meshtastic_Config_PositionConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_PositionConfig_descriptor,
        new java.lang.String[] { "PositionBroadcastSecs", "PositionBroadcastSmartEnabled", "FixedPosition", "GpsEnabled", "GpsUpdateInterval", "GpsAttemptTime", "PositionFlags", "RxGpio", "TxGpio", "BroadcastSmartMinimumDistance", "BroadcastSmartMinimumIntervalSecs", "GpsEnGpio", "GpsMode", });
    internal_static_meshtastic_Config_PowerConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(2);
    internal_static_meshtastic_Config_PowerConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_PowerConfig_descriptor,
        new java.lang.String[] { "IsPowerSaving", "OnBatteryShutdownAfterSecs", "AdcMultiplierOverride", "WaitBluetoothSecs", "SdsSecs", "LsSecs", "MinWakeSecs", "DeviceBatteryInaAddress", "PowermonEnables", });
    internal_static_meshtastic_Config_NetworkConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(3);
    internal_static_meshtastic_Config_NetworkConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_NetworkConfig_descriptor,
        new java.lang.String[] { "WifiEnabled", "WifiSsid", "WifiPsk", "NtpServer", "EthEnabled", "AddressMode", "Ipv4Config", "RsyslogServer", "EnabledProtocols", "Ipv6Enabled", });
    internal_static_meshtastic_Config_NetworkConfig_IpV4Config_descriptor =
      internal_static_meshtastic_Config_NetworkConfig_descriptor.getNestedTypes().get(0);
    internal_static_meshtastic_Config_NetworkConfig_IpV4Config_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_NetworkConfig_IpV4Config_descriptor,
        new java.lang.String[] { "Ip", "Gateway", "Subnet", "Dns", });
    internal_static_meshtastic_Config_DisplayConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(4);
    internal_static_meshtastic_Config_DisplayConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_DisplayConfig_descriptor,
        new java.lang.String[] { "ScreenOnSecs", "GpsFormat", "AutoScreenCarouselSecs", "CompassNorthTop", "FlipScreen", "Units", "Oled", "Displaymode", "HeadingBold", "WakeOnTapOrMotion", "CompassOrientation", "Use12HClock", "UseLongNodeName", });
    internal_static_meshtastic_Config_LoRaConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(5);
    internal_static_meshtastic_Config_LoRaConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_LoRaConfig_descriptor,
        new java.lang.String[] { "UsePreset", "ModemPreset", "Bandwidth", "SpreadFactor", "CodingRate", "FrequencyOffset", "Region", "HopLimit", "TxEnabled", "TxPower", "ChannelNum", "OverrideDutyCycle", "Sx126XRxBoostedGain", "OverrideFrequency", "PaFanDisabled", "IgnoreIncoming", "IgnoreMqtt", "ConfigOkToMqtt", });
    internal_static_meshtastic_Config_BluetoothConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(6);
    internal_static_meshtastic_Config_BluetoothConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_BluetoothConfig_descriptor,
        new java.lang.String[] { "Enabled", "Mode", "FixedPin", });
    internal_static_meshtastic_Config_SecurityConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(7);
    internal_static_meshtastic_Config_SecurityConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_SecurityConfig_descriptor,
        new java.lang.String[] { "PublicKey", "PrivateKey", "AdminKey", "IsManaged", "SerialEnabled", "DebugLogApiEnabled", "AdminChannelEnabled", });
    internal_static_meshtastic_Config_SessionkeyConfig_descriptor =
      internal_static_meshtastic_Config_descriptor.getNestedTypes().get(8);
    internal_static_meshtastic_Config_SessionkeyConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_meshtastic_Config_SessionkeyConfig_descriptor,
        new java.lang.String[] { });
    com.geeksville.mesh.DeviceUIProtos.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
